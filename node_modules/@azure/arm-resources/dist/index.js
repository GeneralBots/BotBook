'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ExpressionEvaluationOptionsScopeType} that the service accepts. */
exports.KnownExpressionEvaluationOptionsScopeType = void 0;
(function (KnownExpressionEvaluationOptionsScopeType) {
    /** NotSpecified */
    KnownExpressionEvaluationOptionsScopeType["NotSpecified"] = "NotSpecified";
    /** Outer */
    KnownExpressionEvaluationOptionsScopeType["Outer"] = "Outer";
    /** Inner */
    KnownExpressionEvaluationOptionsScopeType["Inner"] = "Inner";
})(exports.KnownExpressionEvaluationOptionsScopeType || (exports.KnownExpressionEvaluationOptionsScopeType = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** NotSpecified */
    KnownProvisioningState["NotSpecified"] = "NotSpecified";
    /** Accepted */
    KnownProvisioningState["Accepted"] = "Accepted";
    /** Running */
    KnownProvisioningState["Running"] = "Running";
    /** Ready */
    KnownProvisioningState["Ready"] = "Ready";
    /** Creating */
    KnownProvisioningState["Creating"] = "Creating";
    /** Created */
    KnownProvisioningState["Created"] = "Created";
    /** Deleting */
    KnownProvisioningState["Deleting"] = "Deleting";
    /** Deleted */
    KnownProvisioningState["Deleted"] = "Deleted";
    /** Canceled */
    KnownProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Updating */
    KnownProvisioningState["Updating"] = "Updating";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link AliasPathTokenType} that the service accepts. */
exports.KnownAliasPathTokenType = void 0;
(function (KnownAliasPathTokenType) {
    /** The token type is not specified. */
    KnownAliasPathTokenType["NotSpecified"] = "NotSpecified";
    /** The token type can be anything. */
    KnownAliasPathTokenType["Any"] = "Any";
    /** The token type is string. */
    KnownAliasPathTokenType["String"] = "String";
    /** The token type is object. */
    KnownAliasPathTokenType["Object"] = "Object";
    /** The token type is array. */
    KnownAliasPathTokenType["Array"] = "Array";
    /** The token type is integer. */
    KnownAliasPathTokenType["Integer"] = "Integer";
    /** The token type is number. */
    KnownAliasPathTokenType["Number"] = "Number";
    /** The token type is boolean. */
    KnownAliasPathTokenType["Boolean"] = "Boolean";
})(exports.KnownAliasPathTokenType || (exports.KnownAliasPathTokenType = {}));
/** Known values of {@link AliasPathAttributes} that the service accepts. */
exports.KnownAliasPathAttributes = void 0;
(function (KnownAliasPathAttributes) {
    /** The token that the alias path is referring to has no attributes. */
    KnownAliasPathAttributes["None"] = "None";
    /** The token that the alias path is referring to is modifiable by policies with 'modify' effect. */
    KnownAliasPathAttributes["Modifiable"] = "Modifiable";
})(exports.KnownAliasPathAttributes || (exports.KnownAliasPathAttributes = {}));
/** Known values of {@link ProviderAuthorizationConsentState} that the service accepts. */
exports.KnownProviderAuthorizationConsentState = void 0;
(function (KnownProviderAuthorizationConsentState) {
    /** NotSpecified */
    KnownProviderAuthorizationConsentState["NotSpecified"] = "NotSpecified";
    /** Required */
    KnownProviderAuthorizationConsentState["Required"] = "Required";
    /** NotRequired */
    KnownProviderAuthorizationConsentState["NotRequired"] = "NotRequired";
    /** Consented */
    KnownProviderAuthorizationConsentState["Consented"] = "Consented";
})(exports.KnownProviderAuthorizationConsentState || (exports.KnownProviderAuthorizationConsentState = {}));
/** Known values of {@link ExtendedLocationType} that the service accepts. */
exports.KnownExtendedLocationType = void 0;
(function (KnownExtendedLocationType) {
    /** EdgeZone */
    KnownExtendedLocationType["EdgeZone"] = "EdgeZone";
})(exports.KnownExtendedLocationType || (exports.KnownExtendedLocationType = {}));
/** Known values of {@link TagsPatchOperation} that the service accepts. */
exports.KnownTagsPatchOperation = void 0;
(function (KnownTagsPatchOperation) {
    /** The 'replace' option replaces the entire set of existing tags with a new set. */
    KnownTagsPatchOperation["Replace"] = "Replace";
    /** The 'merge' option allows adding tags with new names and updating the values of tags with existing names. */
    KnownTagsPatchOperation["Merge"] = "Merge";
    /** The 'delete' option allows selectively deleting tags based on given names or name\/value pairs. */
    KnownTagsPatchOperation["Delete"] = "Delete";
})(exports.KnownTagsPatchOperation || (exports.KnownTagsPatchOperation = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const Deployment = {
    type: {
        name: "Composite",
        className: "Deployment",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeploymentProperties"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DeploymentProperties = {
    type: {
        name: "Composite",
        className: "DeploymentProperties",
        modelProperties: {
            template: {
                serializedName: "template",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            templateLink: {
                serializedName: "templateLink",
                type: {
                    name: "Composite",
                    className: "TemplateLink"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            parametersLink: {
                serializedName: "parametersLink",
                type: {
                    name: "Composite",
                    className: "ParametersLink"
                }
            },
            mode: {
                serializedName: "mode",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Incremental", "Complete"]
                }
            },
            debugSetting: {
                serializedName: "debugSetting",
                type: {
                    name: "Composite",
                    className: "DebugSetting"
                }
            },
            onErrorDeployment: {
                serializedName: "onErrorDeployment",
                type: {
                    name: "Composite",
                    className: "OnErrorDeployment"
                }
            },
            expressionEvaluationOptions: {
                serializedName: "expressionEvaluationOptions",
                type: {
                    name: "Composite",
                    className: "ExpressionEvaluationOptions"
                }
            }
        }
    }
};
const TemplateLink = {
    type: {
        name: "Composite",
        className: "TemplateLink",
        modelProperties: {
            uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            relativePath: {
                serializedName: "relativePath",
                type: {
                    name: "String"
                }
            },
            contentVersion: {
                serializedName: "contentVersion",
                type: {
                    name: "String"
                }
            },
            queryString: {
                serializedName: "queryString",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParametersLink = {
    type: {
        name: "Composite",
        className: "ParametersLink",
        modelProperties: {
            uri: {
                serializedName: "uri",
                required: true,
                type: {
                    name: "String"
                }
            },
            contentVersion: {
                serializedName: "contentVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DebugSetting = {
    type: {
        name: "Composite",
        className: "DebugSetting",
        modelProperties: {
            detailLevel: {
                serializedName: "detailLevel",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OnErrorDeployment = {
    type: {
        name: "Composite",
        className: "OnErrorDeployment",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["LastSuccessful", "SpecificDeployment"]
                }
            },
            deploymentName: {
                serializedName: "deploymentName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressionEvaluationOptions = {
    type: {
        name: "Composite",
        className: "ExpressionEvaluationOptions",
        modelProperties: {
            scope: {
                serializedName: "scope",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentExtended = {
    type: {
        name: "Composite",
        className: "DeploymentExtended",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeploymentPropertiesExtended"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DeploymentPropertiesExtended = {
    type: {
        name: "Composite",
        className: "DeploymentPropertiesExtended",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            correlationId: {
                serializedName: "correlationId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            duration: {
                serializedName: "duration",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            outputs: {
                serializedName: "outputs",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            providers: {
                serializedName: "providers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Provider"
                        }
                    }
                }
            },
            dependencies: {
                serializedName: "dependencies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Dependency"
                        }
                    }
                }
            },
            templateLink: {
                serializedName: "templateLink",
                type: {
                    name: "Composite",
                    className: "TemplateLink"
                }
            },
            parameters: {
                serializedName: "parameters",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            parametersLink: {
                serializedName: "parametersLink",
                type: {
                    name: "Composite",
                    className: "ParametersLink"
                }
            },
            mode: {
                serializedName: "mode",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Incremental", "Complete"]
                }
            },
            debugSetting: {
                serializedName: "debugSetting",
                type: {
                    name: "Composite",
                    className: "DebugSetting"
                }
            },
            onErrorDeployment: {
                serializedName: "onErrorDeployment",
                type: {
                    name: "Composite",
                    className: "OnErrorDeploymentExtended"
                }
            },
            templateHash: {
                serializedName: "templateHash",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            outputResources: {
                serializedName: "outputResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            },
            validatedResources: {
                serializedName: "validatedResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            }
        }
    }
};
const Provider = {
    type: {
        name: "Composite",
        className: "Provider",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            namespace: {
                serializedName: "namespace",
                type: {
                    name: "String"
                }
            },
            registrationState: {
                serializedName: "registrationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            registrationPolicy: {
                serializedName: "registrationPolicy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceTypes: {
                serializedName: "resourceTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProviderResourceType"
                        }
                    }
                }
            },
            providerAuthorizationConsentState: {
                serializedName: "providerAuthorizationConsentState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProviderResourceType = {
    type: {
        name: "Composite",
        className: "ProviderResourceType",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            locations: {
                serializedName: "locations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            locationMappings: {
                serializedName: "locationMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProviderExtendedLocation"
                        }
                    }
                }
            },
            aliases: {
                serializedName: "aliases",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Alias"
                        }
                    }
                }
            },
            apiVersions: {
                serializedName: "apiVersions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            defaultApiVersion: {
                serializedName: "defaultApiVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            zoneMappings: {
                serializedName: "zoneMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ZoneMapping"
                        }
                    }
                }
            },
            apiProfiles: {
                serializedName: "apiProfiles",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiProfile"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ProviderExtendedLocation = {
    type: {
        name: "Composite",
        className: "ProviderExtendedLocation",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            extendedLocations: {
                serializedName: "extendedLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Alias = {
    type: {
        name: "Composite",
        className: "Alias",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            paths: {
                serializedName: "paths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AliasPath"
                        }
                    }
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "PlainText", "Mask"]
                }
            },
            defaultPath: {
                serializedName: "defaultPath",
                type: {
                    name: "String"
                }
            },
            defaultPattern: {
                serializedName: "defaultPattern",
                type: {
                    name: "Composite",
                    className: "AliasPattern"
                }
            },
            defaultMetadata: {
                serializedName: "defaultMetadata",
                type: {
                    name: "Composite",
                    className: "AliasPathMetadata"
                }
            }
        }
    }
};
const AliasPath = {
    type: {
        name: "Composite",
        className: "AliasPath",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            apiVersions: {
                serializedName: "apiVersions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            pattern: {
                serializedName: "pattern",
                type: {
                    name: "Composite",
                    className: "AliasPattern"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Composite",
                    className: "AliasPathMetadata"
                }
            }
        }
    }
};
const AliasPattern = {
    type: {
        name: "Composite",
        className: "AliasPattern",
        modelProperties: {
            phrase: {
                serializedName: "phrase",
                type: {
                    name: "String"
                }
            },
            variable: {
                serializedName: "variable",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "Extract"]
                }
            }
        }
    }
};
const AliasPathMetadata = {
    type: {
        name: "Composite",
        className: "AliasPathMetadata",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ZoneMapping = {
    type: {
        name: "Composite",
        className: "ZoneMapping",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ApiProfile = {
    type: {
        name: "Composite",
        className: "ApiProfile",
        modelProperties: {
            profileVersion: {
                serializedName: "profileVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Dependency = {
    type: {
        name: "Composite",
        className: "Dependency",
        modelProperties: {
            dependsOn: {
                serializedName: "dependsOn",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BasicDependency"
                        }
                    }
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BasicDependency = {
    type: {
        name: "Composite",
        className: "BasicDependency",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OnErrorDeploymentExtended = {
    type: {
        name: "Composite",
        className: "OnErrorDeploymentExtended",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["LastSuccessful", "SpecificDeployment"]
                }
            },
            deploymentName: {
                serializedName: "deploymentName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceReference = {
    type: {
        name: "Composite",
        className: "ResourceReference",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentValidateResult = {
    type: {
        name: "Composite",
        className: "DeploymentValidateResult",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeploymentPropertiesExtended"
                }
            }
        }
    }
};
const DeploymentExportResult = {
    type: {
        name: "Composite",
        className: "DeploymentExportResult",
        modelProperties: {
            template: {
                serializedName: "template",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const DeploymentListResult = {
    type: {
        name: "Composite",
        className: "DeploymentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeploymentExtended"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScopedDeployment = {
    type: {
        name: "Composite",
        className: "ScopedDeployment",
        modelProperties: {
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeploymentProperties"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ScopedDeploymentWhatIf = {
    type: {
        name: "Composite",
        className: "ScopedDeploymentWhatIf",
        modelProperties: {
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeploymentWhatIfProperties"
                }
            }
        }
    }
};
const DeploymentWhatIfSettings = {
    type: {
        name: "Composite",
        className: "DeploymentWhatIfSettings",
        modelProperties: {
            resultFormat: {
                serializedName: "resultFormat",
                type: {
                    name: "Enum",
                    allowedValues: ["ResourceIdOnly", "FullResourcePayloads"]
                }
            }
        }
    }
};
const WhatIfOperationResult = {
    type: {
        name: "Composite",
        className: "WhatIfOperationResult",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            },
            changes: {
                serializedName: "properties.changes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WhatIfChange"
                        }
                    }
                }
            }
        }
    }
};
const WhatIfChange = {
    type: {
        name: "Composite",
        className: "WhatIfChange",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            changeType: {
                serializedName: "changeType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Create",
                        "Delete",
                        "Ignore",
                        "Deploy",
                        "NoChange",
                        "Modify",
                        "Unsupported"
                    ]
                }
            },
            unsupportedReason: {
                serializedName: "unsupportedReason",
                type: {
                    name: "String"
                }
            },
            before: {
                serializedName: "before",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            after: {
                serializedName: "after",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            delta: {
                serializedName: "delta",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WhatIfPropertyChange"
                        }
                    }
                }
            }
        }
    }
};
const WhatIfPropertyChange = {
    type: {
        name: "Composite",
        className: "WhatIfPropertyChange",
        modelProperties: {
            path: {
                serializedName: "path",
                required: true,
                type: {
                    name: "String"
                }
            },
            propertyChangeType: {
                serializedName: "propertyChangeType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Create", "Delete", "Modify", "Array", "NoEffect"]
                }
            },
            before: {
                serializedName: "before",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            after: {
                serializedName: "after",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            children: {
                serializedName: "children",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WhatIfPropertyChange"
                        }
                    }
                }
            }
        }
    }
};
const DeploymentWhatIf = {
    type: {
        name: "Composite",
        className: "DeploymentWhatIf",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeploymentWhatIfProperties"
                }
            }
        }
    }
};
const ProviderPermissionListResult = {
    type: {
        name: "Composite",
        className: "ProviderPermissionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProviderPermission"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProviderPermission = {
    type: {
        name: "Composite",
        className: "ProviderPermission",
        modelProperties: {
            applicationId: {
                serializedName: "applicationId",
                type: {
                    name: "String"
                }
            },
            roleDefinition: {
                serializedName: "roleDefinition",
                type: {
                    name: "Composite",
                    className: "RoleDefinition"
                }
            },
            managedByRoleDefinition: {
                serializedName: "managedByRoleDefinition",
                type: {
                    name: "Composite",
                    className: "RoleDefinition"
                }
            },
            providerAuthorizationConsentState: {
                serializedName: "providerAuthorizationConsentState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleDefinition = {
    type: {
        name: "Composite",
        className: "RoleDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            isServiceRole: {
                serializedName: "isServiceRole",
                type: {
                    name: "Boolean"
                }
            },
            permissions: {
                serializedName: "permissions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Permission"
                        }
                    }
                }
            },
            scopes: {
                serializedName: "scopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Permission = {
    type: {
        name: "Composite",
        className: "Permission",
        modelProperties: {
            actions: {
                serializedName: "actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            notActions: {
                serializedName: "notActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dataActions: {
                serializedName: "dataActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            notDataActions: {
                serializedName: "notDataActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ProviderRegistrationRequest = {
    type: {
        name: "Composite",
        className: "ProviderRegistrationRequest",
        modelProperties: {
            thirdPartyProviderConsent: {
                serializedName: "thirdPartyProviderConsent",
                type: {
                    name: "Composite",
                    className: "ProviderConsentDefinition"
                }
            }
        }
    }
};
const ProviderConsentDefinition = {
    type: {
        name: "Composite",
        className: "ProviderConsentDefinition",
        modelProperties: {
            consentToAuthorization: {
                serializedName: "consentToAuthorization",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ProviderListResult = {
    type: {
        name: "Composite",
        className: "ProviderListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Provider"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProviderResourceTypeListResult = {
    type: {
        name: "Composite",
        className: "ProviderResourceTypeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProviderResourceType"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceListResult = {
    type: {
        name: "Composite",
        className: "ResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GenericResourceExpanded"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Plan = {
    type: {
        name: "Composite",
        className: "Plan",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            product: {
                serializedName: "product",
                type: {
                    name: "String"
                }
            },
            promotionCode: {
                serializedName: "promotionCode",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            },
            model: {
                serializedName: "model",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Identity = {
    type: {
        name: "Composite",
        className: "Identity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "IdentityUserAssignedIdentitiesValue"
                        }
                    }
                }
            }
        }
    }
};
const IdentityUserAssignedIdentitiesValue = {
    type: {
        name: "Composite",
        className: "IdentityUserAssignedIdentitiesValue",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ExtendedLocation = {
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceGroup = {
    type: {
        name: "Composite",
        className: "ResourceGroup",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ResourceGroupProperties"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            managedBy: {
                serializedName: "managedBy",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ResourceGroupProperties = {
    type: {
        name: "Composite",
        className: "ResourceGroupProperties",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceGroupPatchable = {
    type: {
        name: "Composite",
        className: "ResourceGroupPatchable",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ResourceGroupProperties"
                }
            },
            managedBy: {
                serializedName: "managedBy",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ExportTemplateRequest = {
    type: {
        name: "Composite",
        className: "ExportTemplateRequest",
        modelProperties: {
            resources: {
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            options: {
                serializedName: "options",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceGroupExportResult = {
    type: {
        name: "Composite",
        className: "ResourceGroupExportResult",
        modelProperties: {
            template: {
                serializedName: "template",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            }
        }
    }
};
const ResourceGroupListResult = {
    type: {
        name: "Composite",
        className: "ResourceGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourcesMoveInfo = {
    type: {
        name: "Composite",
        className: "ResourcesMoveInfo",
        modelProperties: {
            resources: {
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            targetResourceGroup: {
                serializedName: "targetResourceGroup",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagValue = {
    type: {
        name: "Composite",
        className: "TagValue",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tagValue: {
                serializedName: "tagValue",
                type: {
                    name: "String"
                }
            },
            count: {
                serializedName: "count",
                type: {
                    name: "Composite",
                    className: "TagCount"
                }
            }
        }
    }
};
const TagCount = {
    type: {
        name: "Composite",
        className: "TagCount",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TagDetails = {
    type: {
        name: "Composite",
        className: "TagDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tagName: {
                serializedName: "tagName",
                type: {
                    name: "String"
                }
            },
            count: {
                serializedName: "count",
                type: {
                    name: "Composite",
                    className: "TagCount"
                }
            },
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TagValue"
                        }
                    }
                }
            }
        }
    }
};
const TagsListResult = {
    type: {
        name: "Composite",
        className: "TagsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TagDetails"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentOperation = {
    type: {
        name: "Composite",
        className: "DeploymentOperation",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operationId: {
                serializedName: "operationId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeploymentOperationProperties"
                }
            }
        }
    }
};
const DeploymentOperationProperties = {
    type: {
        name: "Composite",
        className: "DeploymentOperationProperties",
        modelProperties: {
            provisioningOperation: {
                serializedName: "provisioningOperation",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "NotSpecified",
                        "Create",
                        "Delete",
                        "Waiting",
                        "AzureAsyncOperationWaiting",
                        "ResourceCacheWaiting",
                        "Action",
                        "Read",
                        "EvaluateDeploymentOutput",
                        "DeploymentCleanup"
                    ]
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            duration: {
                serializedName: "duration",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serviceRequestId: {
                serializedName: "serviceRequestId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statusMessage: {
                serializedName: "statusMessage",
                type: {
                    name: "Composite",
                    className: "StatusMessage"
                }
            },
            targetResource: {
                serializedName: "targetResource",
                type: {
                    name: "Composite",
                    className: "TargetResource"
                }
            },
            request: {
                serializedName: "request",
                type: {
                    name: "Composite",
                    className: "HttpMessage"
                }
            },
            response: {
                serializedName: "response",
                type: {
                    name: "Composite",
                    className: "HttpMessage"
                }
            }
        }
    }
};
const StatusMessage = {
    type: {
        name: "Composite",
        className: "StatusMessage",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            }
        }
    }
};
const TargetResource = {
    type: {
        name: "Composite",
        className: "TargetResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HttpMessage = {
    type: {
        name: "Composite",
        className: "HttpMessage",
        modelProperties: {
            content: {
                serializedName: "content",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const DeploymentOperationsListResult = {
    type: {
        name: "Composite",
        className: "DeploymentOperationsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeploymentOperation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TemplateHashResult = {
    type: {
        name: "Composite",
        className: "TemplateHashResult",
        modelProperties: {
            minifiedTemplate: {
                serializedName: "minifiedTemplate",
                type: {
                    name: "String"
                }
            },
            templateHash: {
                serializedName: "templateHash",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagsResource = {
    type: {
        name: "Composite",
        className: "TagsResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "Tags"
                }
            }
        }
    }
};
const Tags = {
    type: {
        name: "Composite",
        className: "Tags",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const TagsPatchResource = {
    type: {
        name: "Composite",
        className: "TagsPatchResource",
        modelProperties: {
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "Tags"
                }
            }
        }
    }
};
const DeploymentExtendedFilter = {
    type: {
        name: "Composite",
        className: "DeploymentExtendedFilter",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenericResourceFilter = {
    type: {
        name: "Composite",
        className: "GenericResourceFilter",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            tagname: {
                serializedName: "tagname",
                type: {
                    name: "String"
                }
            },
            tagvalue: {
                serializedName: "tagvalue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceGroupFilter = {
    type: {
        name: "Composite",
        className: "ResourceGroupFilter",
        modelProperties: {
            tagName: {
                serializedName: "tagName",
                type: {
                    name: "String"
                }
            },
            tagValue: {
                serializedName: "tagValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceProviderOperationDisplayProperties = {
    type: {
        name: "Composite",
        className: "ResourceProviderOperationDisplayProperties",
        modelProperties: {
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentWhatIfProperties = {
    type: {
        name: "Composite",
        className: "DeploymentWhatIfProperties",
        modelProperties: Object.assign(Object.assign({}, DeploymentProperties.type.modelProperties), { whatIfSettings: {
                serializedName: "whatIfSettings",
                type: {
                    name: "Composite",
                    className: "DeploymentWhatIfSettings"
                }
            } })
    }
};
const GenericResource = {
    type: {
        name: "Composite",
        className: "GenericResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { plan: {
                serializedName: "plan",
                type: {
                    name: "Composite",
                    className: "Plan"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, kind: {
                constraints: {
                    Pattern: new RegExp("^[-\\w\\._,\\(\\)]+$")
                },
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, managedBy: {
                serializedName: "managedBy",
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            } })
    }
};
const GenericResourceExpanded = {
    type: {
        name: "Composite",
        className: "GenericResourceExpanded",
        modelProperties: Object.assign(Object.assign({}, GenericResource.type.modelProperties), { createdTime: {
                serializedName: "createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DeploymentsWhatIfAtTenantScopeHeaders = {
    type: {
        name: "Composite",
        className: "DeploymentsWhatIfAtTenantScopeHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentsWhatIfAtManagementGroupScopeHeaders = {
    type: {
        name: "Composite",
        className: "DeploymentsWhatIfAtManagementGroupScopeHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentsWhatIfAtSubscriptionScopeHeaders = {
    type: {
        name: "Composite",
        className: "DeploymentsWhatIfAtSubscriptionScopeHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentsWhatIfHeaders = {
    type: {
        name: "Composite",
        className: "DeploymentsWhatIfHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    CloudError: CloudError,
    ErrorResponse: ErrorResponse,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    Deployment: Deployment,
    DeploymentProperties: DeploymentProperties,
    TemplateLink: TemplateLink,
    ParametersLink: ParametersLink,
    DebugSetting: DebugSetting,
    OnErrorDeployment: OnErrorDeployment,
    ExpressionEvaluationOptions: ExpressionEvaluationOptions,
    DeploymentExtended: DeploymentExtended,
    DeploymentPropertiesExtended: DeploymentPropertiesExtended,
    Provider: Provider,
    ProviderResourceType: ProviderResourceType,
    ProviderExtendedLocation: ProviderExtendedLocation,
    Alias: Alias,
    AliasPath: AliasPath,
    AliasPattern: AliasPattern,
    AliasPathMetadata: AliasPathMetadata,
    ZoneMapping: ZoneMapping,
    ApiProfile: ApiProfile,
    Dependency: Dependency,
    BasicDependency: BasicDependency,
    OnErrorDeploymentExtended: OnErrorDeploymentExtended,
    ResourceReference: ResourceReference,
    DeploymentValidateResult: DeploymentValidateResult,
    DeploymentExportResult: DeploymentExportResult,
    DeploymentListResult: DeploymentListResult,
    ScopedDeployment: ScopedDeployment,
    ScopedDeploymentWhatIf: ScopedDeploymentWhatIf,
    DeploymentWhatIfSettings: DeploymentWhatIfSettings,
    WhatIfOperationResult: WhatIfOperationResult,
    WhatIfChange: WhatIfChange,
    WhatIfPropertyChange: WhatIfPropertyChange,
    DeploymentWhatIf: DeploymentWhatIf,
    ProviderPermissionListResult: ProviderPermissionListResult,
    ProviderPermission: ProviderPermission,
    RoleDefinition: RoleDefinition,
    Permission: Permission,
    ProviderRegistrationRequest: ProviderRegistrationRequest,
    ProviderConsentDefinition: ProviderConsentDefinition,
    ProviderListResult: ProviderListResult,
    ProviderResourceTypeListResult: ProviderResourceTypeListResult,
    ResourceListResult: ResourceListResult,
    Plan: Plan,
    Sku: Sku,
    Identity: Identity,
    IdentityUserAssignedIdentitiesValue: IdentityUserAssignedIdentitiesValue,
    Resource: Resource,
    ExtendedLocation: ExtendedLocation,
    ResourceGroup: ResourceGroup,
    ResourceGroupProperties: ResourceGroupProperties,
    ResourceGroupPatchable: ResourceGroupPatchable,
    ExportTemplateRequest: ExportTemplateRequest,
    ResourceGroupExportResult: ResourceGroupExportResult,
    ResourceGroupListResult: ResourceGroupListResult,
    ResourcesMoveInfo: ResourcesMoveInfo,
    TagValue: TagValue,
    TagCount: TagCount,
    TagDetails: TagDetails,
    TagsListResult: TagsListResult,
    DeploymentOperation: DeploymentOperation,
    DeploymentOperationProperties: DeploymentOperationProperties,
    StatusMessage: StatusMessage,
    TargetResource: TargetResource,
    HttpMessage: HttpMessage,
    DeploymentOperationsListResult: DeploymentOperationsListResult,
    TemplateHashResult: TemplateHashResult,
    TagsResource: TagsResource,
    Tags: Tags,
    TagsPatchResource: TagsPatchResource,
    DeploymentExtendedFilter: DeploymentExtendedFilter,
    GenericResourceFilter: GenericResourceFilter,
    ResourceGroupFilter: ResourceGroupFilter,
    ResourceProviderOperationDisplayProperties: ResourceProviderOperationDisplayProperties,
    SubResource: SubResource,
    DeploymentWhatIfProperties: DeploymentWhatIfProperties,
    GenericResource: GenericResource,
    GenericResourceExpanded: GenericResourceExpanded,
    DeploymentsWhatIfAtTenantScopeHeaders: DeploymentsWhatIfAtTenantScopeHeaders,
    DeploymentsWhatIfAtManagementGroupScopeHeaders: DeploymentsWhatIfAtManagementGroupScopeHeaders,
    DeploymentsWhatIfAtSubscriptionScopeHeaders: DeploymentsWhatIfAtSubscriptionScopeHeaders,
    DeploymentsWhatIfHeaders: DeploymentsWhatIfHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-04-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const scope = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const deploymentName = {
    parameterPath: "deploymentName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$"),
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "deploymentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: Deployment
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: ScopedDeployment
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: ScopedDeploymentWhatIf
};
const groupId = {
    parameterPath: "groupId",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "groupId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: DeploymentWhatIf
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$"),
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const template = {
    parameterPath: "template",
    mapper: {
        serializedName: "template",
        required: true,
        type: {
            name: "Dictionary",
            value: { type: { name: "any" } }
        }
    }
};
const resourceProviderNamespace = {
    parameterPath: "resourceProviderNamespace",
    mapper: {
        serializedName: "resourceProviderNamespace",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties = {
    parameterPath: ["options", "properties"],
    mapper: ProviderRegistrationRequest
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: ResourcesMoveInfo
};
const sourceResourceGroupName = {
    parameterPath: "sourceResourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$"),
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "sourceResourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parentResourcePath = {
    parameterPath: "parentResourcePath",
    mapper: {
        serializedName: "parentResourcePath",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceType = {
    parameterPath: "resourceType",
    mapper: {
        serializedName: "resourceType",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceName = {
    parameterPath: "resourceName",
    mapper: {
        serializedName: "resourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: GenericResource
};
const resourceId = {
    parameterPath: "resourceId",
    mapper: {
        serializedName: "resourceId",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: ResourceGroup
};
const forceDeletionTypes = {
    parameterPath: ["options", "forceDeletionTypes"],
    mapper: {
        serializedName: "forceDeletionTypes",
        type: {
            name: "String"
        }
    }
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: ResourceGroupPatchable
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: ExportTemplateRequest
};
const resourceGroupName1 = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const tagName = {
    parameterPath: "tagName",
    mapper: {
        serializedName: "tagName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const tagValue = {
    parameterPath: "tagValue",
    mapper: {
        serializedName: "tagValue",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: TagsResource
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: TagsPatchResource
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Microsoft.Resources REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Microsoft.Resources REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$6);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/providers/Microsoft.Resources/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Deployments operations. */
class DeploymentsImpl {
    /**
     * Initialize a new instance of the class Deployments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all the deployments at the given scope.
     * @param scope The resource scope.
     * @param options The options parameters.
     */
    listAtScope(scope, options) {
        const iter = this.listAtScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtScopePagingPage(scope, options, settings);
            }
        };
    }
    listAtScopePagingPage(scope, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAtScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAtScope(scope, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAtScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAtScopePagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAtScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAtScopePagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all the deployments at the tenant scope.
     * @param options The options parameters.
     */
    listAtTenantScope(options) {
        const iter = this.listAtTenantScopePagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtTenantScopePagingPage(options, settings);
            }
        };
    }
    listAtTenantScopePagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAtTenantScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAtTenantScope(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAtTenantScopeNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAtTenantScopePagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAtTenantScopePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAtTenantScopePagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all the deployments for a management group.
     * @param groupId The management group ID.
     * @param options The options parameters.
     */
    listAtManagementGroupScope(groupId, options) {
        const iter = this.listAtManagementGroupScopePagingAll(groupId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtManagementGroupScopePagingPage(groupId, options, settings);
            }
        };
    }
    listAtManagementGroupScopePagingPage(groupId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAtManagementGroupScope(groupId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAtManagementGroupScopeNext(groupId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAtManagementGroupScopePagingAll(groupId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAtManagementGroupScopePagingPage(groupId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Get all the deployments for a subscription.
     * @param options The options parameters.
     */
    listAtSubscriptionScope(options) {
        const iter = this.listAtSubscriptionScopePagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtSubscriptionScopePagingPage(options, settings);
            }
        };
    }
    listAtSubscriptionScopePagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAtSubscriptionScope(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAtSubscriptionScopeNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAtSubscriptionScopePagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAtSubscriptionScopePagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Get all the deployments for a resource group.
     * @param resourceGroupName The name of the resource group with the deployments to get. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtScope(scope, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { scope, deploymentName, options },
                spec: deleteAtScopeOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtScopeAndWait(scope, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteAtScope(scope, deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, checkExistenceAtScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtScope(scope, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { scope, deploymentName, parameters, options },
                spec: createOrUpdateAtScopeOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtScopeAndWait(scope, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateAtScope(scope, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, getAtScopeOperationSpec$2);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, cancelAtScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidateAtScope(scope, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { scope, deploymentName, parameters, options },
                spec: validateAtScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidateAtScopeAndWait(scope, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateAtScope(scope, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Exports the template used for specified deployment.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, exportTemplateAtScopeOperationSpec);
    }
    /**
     * Get all the deployments at the given scope.
     * @param scope The resource scope.
     * @param options The options parameters.
     */
    _listAtScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listAtScopeOperationSpec$1);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtTenantScope(deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { deploymentName, options },
                spec: deleteAtTenantScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtTenantScopeAndWait(deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteAtTenantScope(deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, checkExistenceAtTenantScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtTenantScope(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { deploymentName, parameters, options },
                spec: createOrUpdateAtTenantScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtTenantScopeAndWait(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateAtTenantScope(deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, getAtTenantScopeOperationSpec$2);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, cancelAtTenantScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidateAtTenantScope(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { deploymentName, parameters, options },
                spec: validateAtTenantScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidateAtTenantScopeAndWait(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateAtTenantScope(deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the tenant group.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginWhatIfAtTenantScope(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { deploymentName, parameters, options },
                spec: whatIfAtTenantScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the tenant group.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginWhatIfAtTenantScopeAndWait(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginWhatIfAtTenantScope(deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Exports the template used for specified deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, exportTemplateAtTenantScopeOperationSpec);
    }
    /**
     * Get all the deployments at the tenant scope.
     * @param options The options parameters.
     */
    _listAtTenantScope(options) {
        return this.client.sendOperationRequest({ options }, listAtTenantScopeOperationSpec$2);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtManagementGroupScope(groupId, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { groupId, deploymentName, options },
                spec: deleteAtManagementGroupScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtManagementGroupScopeAndWait(groupId, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteAtManagementGroupScope(groupId, deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, checkExistenceAtManagementGroupScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { groupId, deploymentName, parameters, options },
                spec: createOrUpdateAtManagementGroupScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, getAtManagementGroupScopeOperationSpec$1);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, cancelAtManagementGroupScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidateAtManagementGroupScope(groupId, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { groupId, deploymentName, parameters, options },
                spec: validateAtManagementGroupScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidateAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateAtManagementGroupScope(groupId, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the management
     * group.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginWhatIfAtManagementGroupScope(groupId, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { groupId, deploymentName, parameters, options },
                spec: whatIfAtManagementGroupScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the management
     * group.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginWhatIfAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginWhatIfAtManagementGroupScope(groupId, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Exports the template used for specified deployment.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, exportTemplateAtManagementGroupScopeOperationSpec);
    }
    /**
     * Get all the deployments for a management group.
     * @param groupId The management group ID.
     * @param options The options parameters.
     */
    _listAtManagementGroupScope(groupId, options) {
        return this.client.sendOperationRequest({ groupId, options }, listAtManagementGroupScopeOperationSpec$1);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtSubscriptionScope(deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { deploymentName, options },
                spec: deleteAtSubscriptionScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtSubscriptionScopeAndWait(deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteAtSubscriptionScope(deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, checkExistenceAtSubscriptionScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtSubscriptionScope(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { deploymentName, parameters, options },
                spec: createOrUpdateAtSubscriptionScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtSubscriptionScopeAndWait(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateAtSubscriptionScope(deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, getAtSubscriptionScopeOperationSpec$1);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, cancelAtSubscriptionScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidateAtSubscriptionScope(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { deploymentName, parameters, options },
                spec: validateAtSubscriptionScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidateAtSubscriptionScopeAndWait(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateAtSubscriptionScope(deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to What If.
     * @param options The options parameters.
     */
    beginWhatIfAtSubscriptionScope(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { deploymentName, parameters, options },
                spec: whatIfAtSubscriptionScopeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to What If.
     * @param options The options parameters.
     */
    beginWhatIfAtSubscriptionScopeAndWait(deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginWhatIfAtSubscriptionScope(deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Exports the template used for specified deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, exportTemplateAtSubscriptionScopeOperationSpec);
    }
    /**
     * Get all the deployments for a subscription.
     * @param options The options parameters.
     */
    _listAtSubscriptionScope(options) {
        return this.client.sendOperationRequest({ options }, listAtSubscriptionScopeOperationSpec$1);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. Deleting a template deployment does not affect the
     * state of the resource group. This is an asynchronous operation that returns a status of 202 until
     * the template deployment is successfully deleted. The Location response header contains the URI that
     * is used to obtain the status of the process. While the process is running, a call to the URI in the
     * Location header returns a status of 202. When the process finishes, the URI in the Location header
     * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location
     * header returns an error-level status code.
     * @param resourceGroupName The name of the resource group with the deployment to delete. The name is
     *                          case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, deploymentName, options },
                spec: deleteOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. Deleting a template deployment does not affect the
     * state of the resource group. This is an asynchronous operation that returns a status of 202 until
     * the template deployment is successfully deleted. The Location response header contains the URI that
     * is used to obtain the status of the process. While the process is running, a call to the URI in the
     * Location header returns a status of 202. When the process finishes, the URI in the Location header
     * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location
     * header returns an error-level status code.
     * @param resourceGroupName The name of the resource group with the deployment to delete. The name is
     *                          case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param resourceGroupName The name of the resource group with the deployment to check. The name is
     *                          case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistence(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, checkExistenceOperationSpec$2);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case
     *                          insensitive. The resource group must already exist.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, deploymentName, parameters, options },
                spec: createOrUpdateOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case
     *                          insensitive. The resource group must already exist.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    get(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, getOperationSpec$4);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resource group partially deployed.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancel(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, cancelOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidate(resourceGroupName, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, deploymentName, parameters, options },
                spec: validateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginValidateAndWait(resourceGroupName, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidate(resourceGroupName, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginWhatIf(resourceGroupName, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, deploymentName, parameters, options },
                spec: whatIfOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginWhatIfAndWait(resourceGroupName, deploymentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginWhatIf(resourceGroupName, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Exports the template used for specified deployment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplate(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, exportTemplateOperationSpec$1);
    }
    /**
     * Get all the deployments for a resource group.
     * @param resourceGroupName The name of the resource group with the deployments to get. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Calculate the hash of the given template.
     * @param template The template provided to calculate hash.
     * @param options The options parameters.
     */
    calculateTemplateHash(template, options) {
        return this.client.sendOperationRequest({ template, options }, calculateTemplateHashOperationSpec);
    }
    /**
     * ListAtScopeNext
     * @param scope The resource scope.
     * @param nextLink The nextLink from the previous successful call to the ListAtScope method.
     * @param options The options parameters.
     */
    _listAtScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listAtScopeNextOperationSpec$1);
    }
    /**
     * ListAtTenantScopeNext
     * @param nextLink The nextLink from the previous successful call to the ListAtTenantScope method.
     * @param options The options parameters.
     */
    _listAtTenantScopeNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAtTenantScopeNextOperationSpec$2);
    }
    /**
     * ListAtManagementGroupScopeNext
     * @param groupId The management group ID.
     * @param nextLink The nextLink from the previous successful call to the ListAtManagementGroupScope
     *                 method.
     * @param options The options parameters.
     */
    _listAtManagementGroupScopeNext(groupId, nextLink, options) {
        return this.client.sendOperationRequest({ groupId, nextLink, options }, listAtManagementGroupScopeNextOperationSpec$1);
    }
    /**
     * ListAtSubscriptionScopeNext
     * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionScope
     *                 method.
     * @param options The options parameters.
     */
    _listAtSubscriptionScopeNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAtSubscriptionScopeNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group with the deployments to get. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteAtScopeOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        scope,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const checkExistenceAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        scope,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateAtScopeOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        201: {
            bodyMapper: DeploymentExtended
        },
        202: {
            bodyMapper: DeploymentExtended
        },
        204: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        scope,
        deploymentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const getAtScopeOperationSpec$2 = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        scope,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const cancelAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        scope,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const validateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentValidateResult
        },
        201: {
            bodyMapper: DeploymentValidateResult
        },
        202: {
            bodyMapper: DeploymentValidateResult
        },
        204: {
            bodyMapper: DeploymentValidateResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        scope,
        deploymentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const exportTemplateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentExportResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        scope,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listAtScopeOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$6
};
const deleteAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, deploymentName],
    headerParameters: [accept],
    serializer: serializer$6
};
const checkExistenceAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, deploymentName],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        201: {
            bodyMapper: DeploymentExtended
        },
        202: {
            bodyMapper: DeploymentExtended
        },
        204: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [$host, deploymentName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const getAtTenantScopeOperationSpec$2 = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, deploymentName],
    headerParameters: [accept],
    serializer: serializer$6
};
const cancelAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, deploymentName],
    headerParameters: [accept],
    serializer: serializer$6
};
const validateAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentValidateResult
        },
        201: {
            bodyMapper: DeploymentValidateResult
        },
        202: {
            bodyMapper: DeploymentValidateResult
        },
        204: {
            bodyMapper: DeploymentValidateResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [$host, deploymentName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const whatIfAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WhatIfOperationResult
        },
        201: {
            bodyMapper: WhatIfOperationResult
        },
        202: {
            bodyMapper: WhatIfOperationResult
        },
        204: {
            bodyMapper: WhatIfOperationResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [$host, deploymentName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const exportTemplateAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentExportResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, deploymentName],
    headerParameters: [accept],
    serializer: serializer$6
};
const listAtTenantScopeOperationSpec$2 = {
    path: "/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$6
};
const deleteAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const checkExistenceAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        201: {
            bodyMapper: DeploymentExtended
        },
        202: {
            bodyMapper: DeploymentExtended
        },
        204: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        groupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const getAtManagementGroupScopeOperationSpec$1 = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const cancelAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const validateAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentValidateResult
        },
        201: {
            bodyMapper: DeploymentValidateResult
        },
        202: {
            bodyMapper: DeploymentValidateResult
        },
        204: {
            bodyMapper: DeploymentValidateResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        groupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const whatIfAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WhatIfOperationResult
        },
        201: {
            bodyMapper: WhatIfOperationResult
        },
        202: {
            bodyMapper: WhatIfOperationResult
        },
        204: {
            bodyMapper: WhatIfOperationResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        groupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const exportTemplateAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentExportResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listAtManagementGroupScopeOperationSpec$1 = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, groupId],
    headerParameters: [accept],
    serializer: serializer$6
};
const deleteAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const checkExistenceAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        201: {
            bodyMapper: DeploymentExtended
        },
        202: {
            bodyMapper: DeploymentExtended
        },
        204: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const getAtSubscriptionScopeOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const cancelAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const validateAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentValidateResult
        },
        201: {
            bodyMapper: DeploymentValidateResult
        },
        202: {
            bodyMapper: DeploymentValidateResult
        },
        204: {
            bodyMapper: DeploymentValidateResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const whatIfAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WhatIfOperationResult
        },
        201: {
            bodyMapper: WhatIfOperationResult
        },
        202: {
            bodyMapper: WhatIfOperationResult
        },
        204: {
            bodyMapper: WhatIfOperationResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const exportTemplateAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentExportResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listAtSubscriptionScopeOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$6
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const checkExistenceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        201: {
            bodyMapper: DeploymentExtended
        },
        202: {
            bodyMapper: DeploymentExtended
        },
        204: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentExtended
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const validateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentValidateResult
        },
        201: {
            bodyMapper: DeploymentValidateResult
        },
        202: {
            bodyMapper: DeploymentValidateResult
        },
        204: {
            bodyMapper: DeploymentValidateResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const whatIfOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WhatIfOperationResult
        },
        201: {
            bodyMapper: WhatIfOperationResult
        },
        202: {
            bodyMapper: WhatIfOperationResult
        },
        204: {
            bodyMapper: WhatIfOperationResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const exportTemplateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentExportResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const calculateTemplateHashOperationSpec = {
    path: "/providers/Microsoft.Resources/calculateTemplateHash",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TemplateHashResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: template,
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listAtScopeNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$6
};
const listAtTenantScopeNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$6
};
const listAtManagementGroupScopeNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink, groupId],
    headerParameters: [accept],
    serializer: serializer$6
};
const listAtSubscriptionScopeNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Providers operations. */
class ProvidersImpl {
    /**
     * Initialize a new instance of the class Providers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all resource providers for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all resource providers for the tenant.
     * @param options The options parameters.
     */
    listAtTenantScope(options) {
        const iter = this.listAtTenantScopePagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtTenantScopePagingPage(options, settings);
            }
        };
    }
    listAtTenantScopePagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAtTenantScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAtTenantScope(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAtTenantScopeNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAtTenantScopePagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAtTenantScopePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAtTenantScopePagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Unregisters a subscription from a resource provider.
     * @param resourceProviderNamespace The namespace of the resource provider to unregister.
     * @param options The options parameters.
     */
    unregister(resourceProviderNamespace, options) {
        return this.client.sendOperationRequest({ resourceProviderNamespace, options }, unregisterOperationSpec);
    }
    /**
     * Registers a management group with a resource provider.
     * @param resourceProviderNamespace The namespace of the resource provider to register.
     * @param groupId The management group ID.
     * @param options The options parameters.
     */
    registerAtManagementGroupScope(resourceProviderNamespace, groupId, options) {
        return this.client.sendOperationRequest({ resourceProviderNamespace, groupId, options }, registerAtManagementGroupScopeOperationSpec);
    }
    /**
     * Get the provider permissions.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param options The options parameters.
     */
    providerPermissions(resourceProviderNamespace, options) {
        return this.client.sendOperationRequest({ resourceProviderNamespace, options }, providerPermissionsOperationSpec);
    }
    /**
     * Registers a subscription with a resource provider.
     * @param resourceProviderNamespace The namespace of the resource provider to register.
     * @param options The options parameters.
     */
    register(resourceProviderNamespace, options) {
        return this.client.sendOperationRequest({ resourceProviderNamespace, options }, registerOperationSpec);
    }
    /**
     * Gets all resource providers for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$5);
    }
    /**
     * Gets all resource providers for the tenant.
     * @param options The options parameters.
     */
    _listAtTenantScope(options) {
        return this.client.sendOperationRequest({ options }, listAtTenantScopeOperationSpec$1);
    }
    /**
     * Gets the specified resource provider.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param options The options parameters.
     */
    get(resourceProviderNamespace, options) {
        return this.client.sendOperationRequest({ resourceProviderNamespace, options }, getOperationSpec$3);
    }
    /**
     * Gets the specified resource provider at the tenant level.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param options The options parameters.
     */
    getAtTenantScope(resourceProviderNamespace, options) {
        return this.client.sendOperationRequest({ resourceProviderNamespace, options }, getAtTenantScopeOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
    /**
     * ListAtTenantScopeNext
     * @param nextLink The nextLink from the previous successful call to the ListAtTenantScope method.
     * @param options The options parameters.
     */
    _listAtTenantScopeNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAtTenantScopeNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const unregisterOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}/unregister",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Provider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceProviderNamespace
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const registerAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/{resourceProviderNamespace}/register",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        groupId,
        resourceProviderNamespace
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const providerPermissionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}/providerPermissions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderPermissionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceProviderNamespace
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const registerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}/register",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Provider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: properties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceProviderNamespace
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$5
};
const listAtTenantScopeOperationSpec$1 = {
    path: "/providers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Provider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceProviderNamespace
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getAtTenantScopeOperationSpec$1 = {
    path: "/providers/{resourceProviderNamespace}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Provider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [$host, resourceProviderNamespace],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listAtTenantScopeNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ProviderResourceTypes operations. */
class ProviderResourceTypesImpl {
    /**
     * Initialize a new instance of the class ProviderResourceTypes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the resource types for a specified resource provider.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param options The options parameters.
     */
    list(resourceProviderNamespace, options) {
        return this.client.sendOperationRequest({ resourceProviderNamespace, options }, listOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}/resourceTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderResourceTypeListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceProviderNamespace
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Resources operations. */
class ResourcesImpl {
    /**
     * Initialize a new instance of the class Resources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all the resources for a resource group.
     * @param resourceGroupName The resource group with the resources to get.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all the resources in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all the resources for a resource group.
     * @param resourceGroupName The resource group with the resources to get.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * The resources to be moved must be in the same source resource group in the source subscription being
     * used. The target resource group may be in a different subscription. When moving resources, both the
     * source group and the target group are locked for the duration of the operation. Write and delete
     * operations are blocked on the groups until the move completes.
     * @param sourceResourceGroupName The name of the resource group from the source subscription
     *                                containing the resources to be moved.
     * @param parameters Parameters for moving resources.
     * @param options The options parameters.
     */
    beginMoveResources(sourceResourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { sourceResourceGroupName, parameters, options },
                spec: moveResourcesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The resources to be moved must be in the same source resource group in the source subscription being
     * used. The target resource group may be in a different subscription. When moving resources, both the
     * source group and the target group are locked for the duration of the operation. Write and delete
     * operations are blocked on the groups until the move completes.
     * @param sourceResourceGroupName The name of the resource group from the source subscription
     *                                containing the resources to be moved.
     * @param parameters Parameters for moving resources.
     * @param options The options parameters.
     */
    beginMoveResourcesAndWait(sourceResourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMoveResources(sourceResourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation checks whether the specified resources can be moved to the target. The resources to
     * be moved must be in the same source resource group in the source subscription being used. The target
     * resource group may be in a different subscription. If validation succeeds, it returns HTTP response
     * code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an
     * error message. Retrieve the URL in the Location header value to check the result of the long-running
     * operation.
     * @param sourceResourceGroupName The name of the resource group from the source subscription
     *                                containing the resources to be validated for move.
     * @param parameters Parameters for moving resources.
     * @param options The options parameters.
     */
    beginValidateMoveResources(sourceResourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { sourceResourceGroupName, parameters, options },
                spec: validateMoveResourcesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation checks whether the specified resources can be moved to the target. The resources to
     * be moved must be in the same source resource group in the source subscription being used. The target
     * resource group may be in a different subscription. If validation succeeds, it returns HTTP response
     * code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an
     * error message. Retrieve the URL in the Location header value to check the result of the long-running
     * operation.
     * @param sourceResourceGroupName The name of the resource group from the source subscription
     *                                containing the resources to be validated for move.
     * @param parameters Parameters for moving resources.
     * @param options The options parameters.
     */
    beginValidateMoveResourcesAndWait(sourceResourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateMoveResources(sourceResourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get all the resources in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * Checks whether a resource exists.
     * @param resourceGroupName The name of the resource group containing the resource to check. The name
     *                          is case insensitive.
     * @param resourceProviderNamespace The resource provider of the resource to check.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type.
     * @param resourceName The name of the resource to check whether it exists.
     * @param apiVersion The API version to use for the operation.
     * @param options The options parameters.
     */
    checkExistence(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            apiVersion,
            options
        }, checkExistenceOperationSpec$1);
    }
    /**
     * Deletes a resource.
     * @param resourceGroupName The name of the resource group that contains the resource to delete. The
     *                          name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type.
     * @param resourceName The name of the resource to delete.
     * @param apiVersion The API version to use for the operation.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    resourceProviderNamespace,
                    parentResourcePath,
                    resourceType,
                    resourceName,
                    apiVersion,
                    options
                },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a resource.
     * @param resourceGroupName The name of the resource group that contains the resource to delete. The
     *                          name is case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type.
     * @param resourceName The name of the resource to delete.
     * @param apiVersion The API version to use for the operation.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates a resource.
     * @param resourceGroupName The name of the resource group for the resource. The name is case
     *                          insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource to create.
     * @param resourceName The name of the resource to create.
     * @param apiVersion The API version to use for the operation.
     * @param parameters Parameters for creating or updating the resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    resourceProviderNamespace,
                    parentResourcePath,
                    resourceType,
                    resourceName,
                    apiVersion,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a resource.
     * @param resourceGroupName The name of the resource group for the resource. The name is case
     *                          insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource to create.
     * @param resourceName The name of the resource to create.
     * @param apiVersion The API version to use for the operation.
     * @param parameters Parameters for creating or updating the resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a resource.
     * @param resourceGroupName The name of the resource group for the resource. The name is case
     *                          insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource to update.
     * @param resourceName The name of the resource to update.
     * @param apiVersion The API version to use for the operation.
     * @param parameters Parameters for updating the resource.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    resourceProviderNamespace,
                    parentResourcePath,
                    resourceType,
                    resourceName,
                    apiVersion,
                    parameters,
                    options
                },
                spec: updateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a resource.
     * @param resourceGroupName The name of the resource group for the resource. The name is case
     *                          insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource to update.
     * @param resourceName The name of the resource to update.
     * @param apiVersion The API version to use for the operation.
     * @param parameters Parameters for updating the resource.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a resource.
     * @param resourceGroupName The name of the resource group containing the resource to get. The name is
     *                          case insensitive.
     * @param resourceProviderNamespace The namespace of the resource provider.
     * @param parentResourcePath The parent resource identity.
     * @param resourceType The resource type of the resource.
     * @param resourceName The name of the resource to get.
     * @param apiVersion The API version to use for the operation.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceProviderNamespace, parentResourcePath, resourceType, resourceName, apiVersion, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceProviderNamespace,
            parentResourcePath,
            resourceType,
            resourceName,
            apiVersion,
            options
        }, getOperationSpec$2);
    }
    /**
     * Checks by ID whether a resource exists.
     * @param resourceId The fully qualified ID of the resource, including the resource name and resource
     *                   type. Use the format,
     *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}
     * @param apiVersion The API version to use for the operation.
     * @param options The options parameters.
     */
    checkExistenceById(resourceId, apiVersion, options) {
        return this.client.sendOperationRequest({ resourceId, apiVersion, options }, checkExistenceByIdOperationSpec);
    }
    /**
     * Deletes a resource by ID.
     * @param resourceId The fully qualified ID of the resource, including the resource name and resource
     *                   type. Use the format,
     *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}
     * @param apiVersion The API version to use for the operation.
     * @param options The options parameters.
     */
    beginDeleteById(resourceId, apiVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceId, apiVersion, options },
                spec: deleteByIdOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a resource by ID.
     * @param resourceId The fully qualified ID of the resource, including the resource name and resource
     *                   type. Use the format,
     *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}
     * @param apiVersion The API version to use for the operation.
     * @param options The options parameters.
     */
    beginDeleteByIdAndWait(resourceId, apiVersion, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteById(resourceId, apiVersion, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create a resource by ID.
     * @param resourceId The fully qualified ID of the resource, including the resource name and resource
     *                   type. Use the format,
     *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}
     * @param apiVersion The API version to use for the operation.
     * @param parameters Create or update resource parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateById(resourceId, apiVersion, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceId, apiVersion, parameters, options },
                spec: createOrUpdateByIdOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a resource by ID.
     * @param resourceId The fully qualified ID of the resource, including the resource name and resource
     *                   type. Use the format,
     *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}
     * @param apiVersion The API version to use for the operation.
     * @param parameters Create or update resource parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateByIdAndWait(resourceId, apiVersion, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateById(resourceId, apiVersion, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a resource by ID.
     * @param resourceId The fully qualified ID of the resource, including the resource name and resource
     *                   type. Use the format,
     *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}
     * @param apiVersion The API version to use for the operation.
     * @param parameters Update resource parameters.
     * @param options The options parameters.
     */
    beginUpdateById(resourceId, apiVersion, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceId, apiVersion, parameters, options },
                spec: updateByIdOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a resource by ID.
     * @param resourceId The fully qualified ID of the resource, including the resource name and resource
     *                   type. Use the format,
     *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}
     * @param apiVersion The API version to use for the operation.
     * @param parameters Update resource parameters.
     * @param options The options parameters.
     */
    beginUpdateByIdAndWait(resourceId, apiVersion, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateById(resourceId, apiVersion, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a resource by ID.
     * @param resourceId The fully qualified ID of the resource, including the resource name and resource
     *                   type. Use the format,
     *                   /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}
     * @param apiVersion The API version to use for the operation.
     * @param options The options parameters.
     */
    getById(resourceId, apiVersion, options) {
        return this.client.sendOperationRequest({ resourceId, apiVersion, options }, getByIdOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group with the resources to get.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/resources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        top,
        expand
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const moveResourcesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/moveResources",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        sourceResourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const validateMoveResourcesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/validateMoveResources",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        sourceResourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        top,
        expand
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const checkExistenceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GenericResource
        },
        201: {
            bodyMapper: GenericResource
        },
        202: {
            bodyMapper: GenericResource
        },
        204: {
            bodyMapper: GenericResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: GenericResource
        },
        201: {
            bodyMapper: GenericResource
        },
        202: {
            bodyMapper: GenericResource
        },
        204: {
            bodyMapper: GenericResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GenericResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const checkExistenceByIdOperationSpec = {
    path: "/{resourceId}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, resourceId],
    headerParameters: [accept],
    serializer: serializer$3
};
const deleteByIdOperationSpec = {
    path: "/{resourceId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, resourceId],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateByIdOperationSpec = {
    path: "/{resourceId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GenericResource
        },
        201: {
            bodyMapper: GenericResource
        },
        202: {
            bodyMapper: GenericResource
        },
        204: {
            bodyMapper: GenericResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion1],
    urlParameters: [$host, resourceId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const updateByIdOperationSpec = {
    path: "/{resourceId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: GenericResource
        },
        201: {
            bodyMapper: GenericResource
        },
        202: {
            bodyMapper: GenericResource
        },
        204: {
            bodyMapper: GenericResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion1],
    urlParameters: [$host, resourceId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const getByIdOperationSpec = {
    path: "/{resourceId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GenericResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, resourceId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ResourceGroups operations. */
class ResourceGroupsImpl {
    /**
     * Initialize a new instance of the class ResourceGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the resource groups for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Checks whether a resource group exists.
     * @param resourceGroupName The name of the resource group to check. The name is case insensitive.
     * @param options The options parameters.
     */
    checkExistence(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, checkExistenceOperationSpec);
    }
    /**
     * Creates or updates a resource group.
     * @param resourceGroupName The name of the resource group to create or update. Can include
     *                          alphanumeric, underscore, parentheses, hyphen, period (except at end), and Unicode characters that
     *                          match the allowed characters.
     * @param parameters Parameters supplied to the create or update a resource group.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, parameters, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * When you delete a resource group, all of its resources are also deleted. Deleting a resource group
     * deletes all of its template deployments and currently stored operations.
     * @param resourceGroupName The name of the resource group to delete. The name is case insensitive.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, options },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * When you delete a resource group, all of its resources are also deleted. Deleting a resource group
     * deletes all of its template deployments and currently stored operations.
     * @param resourceGroupName The name of the resource group to delete. The name is case insensitive.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a resource group.
     * @param resourceGroupName The name of the resource group to get. The name is case insensitive.
     * @param options The options parameters.
     */
    get(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, getOperationSpec$1);
    }
    /**
     * Resource groups can be updated through a simple PATCH operation to a group address. The format of
     * the request is the same as that for creating a resource group. If a field is unspecified, the
     * current value is retained.
     * @param resourceGroupName The name of the resource group to update. The name is case insensitive.
     * @param parameters Parameters supplied to update a resource group.
     * @param options The options parameters.
     */
    update(resourceGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, parameters, options }, updateOperationSpec);
    }
    /**
     * Captures the specified resource group as a template.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param parameters Parameters for exporting the template.
     * @param options The options parameters.
     */
    beginExportTemplate(resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, parameters, options },
                spec: exportTemplateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Captures the specified resource group as a template.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param parameters Parameters for exporting the template.
     * @param options The options parameters.
     */
    beginExportTemplateAndWait(resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExportTemplate(resourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all the resource groups for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkExistenceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ResourceGroup
        },
        201: {
            bodyMapper: ResourceGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, forceDeletionTypes],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ResourceGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const exportTemplateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ResourceGroupExportResult
        },
        201: {
            bodyMapper: ResourceGroupExportResult
        },
        202: {
            bodyMapper: ResourceGroupExportResult
        },
        204: {
            bodyMapper: ResourceGroupExportResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TagsOperations operations. */
class TagsOperationsImpl {
    /**
     * Initialize a new instance of the class TagsOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * This operation performs a union of predefined tags, resource tags, resource group tags and
     * subscription tags, and returns a summary of usage for each tag name and value under the given
     * subscription. In case of a large number of tags, this operation may return a previously cached
     * result.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * This operation allows deleting a value from the list of predefined values for an existing predefined
     * tag name. The value being deleted must not be in use as a tag value for the given tag name for any
     * resource.
     * @param tagName The name of the tag.
     * @param tagValue The value of the tag to delete.
     * @param options The options parameters.
     */
    deleteValue(tagName, tagValue, options) {
        return this.client.sendOperationRequest({ tagName, tagValue, options }, deleteValueOperationSpec);
    }
    /**
     * This operation allows adding a value to the list of predefined values for an existing predefined tag
     * name. A tag value can have a maximum of 256 characters.
     * @param tagName The name of the tag.
     * @param tagValue The value of the tag to create.
     * @param options The options parameters.
     */
    createOrUpdateValue(tagName, tagValue, options) {
        return this.client.sendOperationRequest({ tagName, tagValue, options }, createOrUpdateValueOperationSpec);
    }
    /**
     * This operation allows adding a name to the list of predefined tag names for the given subscription.
     * A tag name can have a maximum of 512 characters and is case-insensitive. Tag names cannot have the
     * following prefixes which are reserved for Azure use: 'microsoft', 'azure', 'windows'.
     * @param tagName The name of the tag to create.
     * @param options The options parameters.
     */
    createOrUpdate(tagName, options) {
        return this.client.sendOperationRequest({ tagName, options }, createOrUpdateOperationSpec);
    }
    /**
     * This operation allows deleting a name from the list of predefined tag names for the given
     * subscription. The name being deleted must not be in use as a tag name for any resource. All
     * predefined values for the given name must have already been deleted.
     * @param tagName The name of the tag.
     * @param options The options parameters.
     */
    delete(tagName, options) {
        return this.client.sendOperationRequest({ tagName, options }, deleteOperationSpec);
    }
    /**
     * This operation performs a union of predefined tags, resource tags, resource group tags and
     * subscription tags, and returns a summary of usage for each tag name and value under the given
     * subscription. In case of a large number of tags, this operation may return a previously cached
     * result.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * This operation allows adding or replacing the entire set of tags on the specified resource or
     * subscription. The specified entity can have a maximum of 50 tags.
     * @param scope The resource scope.
     * @param parameters Wrapper resource for tags API requests and responses.
     * @param options The options parameters.
     */
    createOrUpdateAtScope(scope, parameters, options) {
        return this.client.sendOperationRequest({ scope, parameters, options }, createOrUpdateAtScopeOperationSpec);
    }
    /**
     * This operation allows replacing, merging or selectively deleting tags on the specified resource or
     * subscription. The specified entity can have a maximum of 50 tags at the end of the operation. The
     * 'replace' option replaces the entire set of existing tags with a new set. The 'merge' option allows
     * adding tags with new names and updating the values of tags with existing names. The 'delete' option
     * allows selectively deleting tags based on given names or name/value pairs.
     * @param scope The resource scope.
     * @param parameters Wrapper resource for tags patch API request only.
     * @param options The options parameters.
     */
    updateAtScope(scope, parameters, options) {
        return this.client.sendOperationRequest({ scope, parameters, options }, updateAtScopeOperationSpec);
    }
    /**
     * Gets the entire set of tags on a resource or subscription.
     * @param scope The resource scope.
     * @param options The options parameters.
     */
    getAtScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, getAtScopeOperationSpec$1);
    }
    /**
     * Deletes the entire set of tags on a resource or subscription.
     * @param scope The resource scope.
     * @param options The options parameters.
     */
    deleteAtScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, deleteAtScopeOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteValueOperationSpec = {
    path: "/subscriptions/{subscriptionId}/tagNames/{tagName}/tagValues/{tagValue}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        tagName,
        tagValue
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateValueOperationSpec = {
    path: "/subscriptions/{subscriptionId}/tagNames/{tagName}/tagValues/{tagValue}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TagValue
        },
        201: {
            bodyMapper: TagValue
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        tagName,
        tagValue
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/tagNames/{tagName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TagDetails
        },
        201: {
            bodyMapper: TagDetails
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        tagName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/tagNames/{tagName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        tagName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/tagNames",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/tags/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TagsResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const updateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/tags/default",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: TagsResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [$host, scope],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const getAtScopeOperationSpec$1 = {
    path: "/{scope}/providers/Microsoft.Resources/tags/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagsResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/tags/default",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DeploymentOperations operations. */
class DeploymentOperationsImpl {
    /**
     * Initialize a new instance of the class DeploymentOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    listAtScope(scope, deploymentName, options) {
        const iter = this.listAtScopePagingAll(scope, deploymentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtScopePagingPage(scope, deploymentName, options, settings);
            }
        };
    }
    listAtScopePagingPage(scope, deploymentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAtScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAtScope(scope, deploymentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAtScopeNext(scope, deploymentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAtScopePagingAll(scope, deploymentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAtScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAtScopePagingPage(scope, deploymentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    listAtTenantScope(deploymentName, options) {
        const iter = this.listAtTenantScopePagingAll(deploymentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtTenantScopePagingPage(deploymentName, options, settings);
            }
        };
    }
    listAtTenantScopePagingPage(deploymentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAtTenantScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAtTenantScope(deploymentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAtTenantScopeNext(deploymentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAtTenantScopePagingAll(deploymentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAtTenantScopePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAtTenantScopePagingPage(deploymentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    listAtManagementGroupScope(groupId, deploymentName, options) {
        const iter = this.listAtManagementGroupScopePagingAll(groupId, deploymentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtManagementGroupScopePagingPage(groupId, deploymentName, options, settings);
            }
        };
    }
    listAtManagementGroupScopePagingPage(groupId, deploymentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAtManagementGroupScope(groupId, deploymentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAtManagementGroupScopeNext(groupId, deploymentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAtManagementGroupScopePagingAll(groupId, deploymentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAtManagementGroupScopePagingPage(groupId, deploymentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    listAtSubscriptionScope(deploymentName, options) {
        const iter = this.listAtSubscriptionScopePagingAll(deploymentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAtSubscriptionScopePagingPage(deploymentName, options, settings);
            }
        };
    }
    listAtSubscriptionScopePagingPage(deploymentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAtSubscriptionScope(deploymentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAtSubscriptionScopeNext(deploymentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAtSubscriptionScopePagingAll(deploymentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAtSubscriptionScopePagingPage(deploymentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    list(resourceGroupName, deploymentName, options) {
        const iter = this.listPagingAll(resourceGroupName, deploymentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, deploymentName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, deploymentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, deploymentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, deploymentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, deploymentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, deploymentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Gets a deployments operation.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param operationId The ID of the operation to get.
     * @param options The options parameters.
     */
    getAtScope(scope, deploymentName, operationId, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, operationId, options }, getAtScopeOperationSpec);
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    _listAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, listAtScopeOperationSpec);
    }
    /**
     * Gets a deployments operation.
     * @param deploymentName The name of the deployment.
     * @param operationId The ID of the operation to get.
     * @param options The options parameters.
     */
    getAtTenantScope(deploymentName, operationId, options) {
        return this.client.sendOperationRequest({ deploymentName, operationId, options }, getAtTenantScopeOperationSpec);
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    _listAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, listAtTenantScopeOperationSpec);
    }
    /**
     * Gets a deployments operation.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param operationId The ID of the operation to get.
     * @param options The options parameters.
     */
    getAtManagementGroupScope(groupId, deploymentName, operationId, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, operationId, options }, getAtManagementGroupScopeOperationSpec);
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    _listAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, listAtManagementGroupScopeOperationSpec);
    }
    /**
     * Gets a deployments operation.
     * @param deploymentName The name of the deployment.
     * @param operationId The ID of the operation to get.
     * @param options The options parameters.
     */
    getAtSubscriptionScope(deploymentName, operationId, options) {
        return this.client.sendOperationRequest({ deploymentName, operationId, options }, getAtSubscriptionScopeOperationSpec);
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    _listAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, listAtSubscriptionScopeOperationSpec);
    }
    /**
     * Gets a deployments operation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param operationId The ID of the operation to get.
     * @param options The options parameters.
     */
    get(resourceGroupName, deploymentName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, operationId, options }, getOperationSpec);
    }
    /**
     * Gets all deployments operations for a deployment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    _list(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, listOperationSpec);
    }
    /**
     * ListAtScopeNext
     * @param scope The resource scope.
     * @param deploymentName The name of the deployment.
     * @param nextLink The nextLink from the previous successful call to the ListAtScope method.
     * @param options The options parameters.
     */
    _listAtScopeNext(scope, deploymentName, nextLink, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, nextLink, options }, listAtScopeNextOperationSpec);
    }
    /**
     * ListAtTenantScopeNext
     * @param deploymentName The name of the deployment.
     * @param nextLink The nextLink from the previous successful call to the ListAtTenantScope method.
     * @param options The options parameters.
     */
    _listAtTenantScopeNext(deploymentName, nextLink, options) {
        return this.client.sendOperationRequest({ deploymentName, nextLink, options }, listAtTenantScopeNextOperationSpec);
    }
    /**
     * ListAtManagementGroupScopeNext
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param nextLink The nextLink from the previous successful call to the ListAtManagementGroupScope
     *                 method.
     * @param options The options parameters.
     */
    _listAtManagementGroupScopeNext(groupId, deploymentName, nextLink, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, nextLink, options }, listAtManagementGroupScopeNextOperationSpec);
    }
    /**
     * ListAtSubscriptionScopeNext
     * @param deploymentName The name of the deployment.
     * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionScope
     *                 method.
     * @param options The options parameters.
     */
    _listAtSubscriptionScopeNext(deploymentName, nextLink, options) {
        return this.client.sendOperationRequest({ deploymentName, nextLink, options }, listAtSubscriptionScopeNextOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, deploymentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        scope,
        deploymentName,
        operationId
    ],
    headerParameters: [accept],
    serializer
};
const listAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        scope,
        deploymentName
    ],
    headerParameters: [accept],
    serializer
};
const getAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        operationId
    ],
    headerParameters: [accept],
    serializer
};
const listAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [$host, deploymentName],
    headerParameters: [accept],
    serializer
};
const getAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        groupId,
        operationId
    ],
    headerParameters: [accept],
    serializer
};
const listAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        deploymentName,
        groupId
    ],
    headerParameters: [accept],
    serializer
};
const getAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        operationId
    ],
    headerParameters: [accept],
    serializer
};
const listAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/deployments/{deploymentName}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName,
        operationId
    ],
    headerParameters: [accept],
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/deployments/{deploymentName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer
};
const listAtScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        scope,
        deploymentName
    ],
    headerParameters: [accept],
    serializer
};
const listAtTenantScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        deploymentName
    ],
    headerParameters: [accept],
    serializer
};
const listAtManagementGroupScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        deploymentName,
        groupId
    ],
    headerParameters: [accept],
    serializer
};
const listAtSubscriptionScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        deploymentName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentOperationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        deploymentName,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ResourceManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ResourceManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The Microsoft Azure subscription ID.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-resources/5.2.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-04-01";
        this.operations = new OperationsImpl(this);
        this.deployments = new DeploymentsImpl(this);
        this.providers = new ProvidersImpl(this);
        this.providerResourceTypes = new ProviderResourceTypesImpl(this);
        this.resources = new ResourcesImpl(this);
        this.resourceGroups = new ResourceGroupsImpl(this);
        this.tagsOperations = new TagsOperationsImpl(this);
        this.deploymentOperations = new DeploymentOperationsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.ResourceManagementClient = ResourceManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
