/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from "tslib";
import * as coreClient from "@azure/core-client";
import * as coreRestPipeline from "@azure/core-rest-pipeline";
import { setContinuationToken } from "./pagingHelper";
import { AppServiceCertificateOrdersImpl, CertificateOrdersDiagnosticsImpl, CertificateRegistrationProviderImpl, DomainsImpl, TopLevelDomainsImpl, DomainRegistrationProviderImpl, AppServiceEnvironmentsImpl, AppServicePlansImpl, CertificatesImpl, ContainerAppsImpl, ContainerAppsRevisionsImpl, DeletedWebAppsImpl, DiagnosticsImpl, GlobalImpl, KubeEnvironmentsImpl, ProviderImpl, RecommendationsImpl, ResourceHealthMetadataOperationsImpl, GetUsagesInLocationImpl, StaticSitesImpl, WebAppsImpl, WorkflowsImpl, WorkflowRunsImpl, WorkflowRunActionsImpl, WorkflowRunActionRepetitionsImpl, WorkflowRunActionRepetitionsRequestHistoriesImpl, WorkflowRunActionScopeRepetitionsImpl, WorkflowTriggersImpl, WorkflowTriggerHistoriesImpl, WorkflowVersionsImpl, } from "./operations";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
/// <reference lib="esnext.asynciterable" />
export class WebSiteManagementClient extends coreClient.ServiceClient {
    constructor(credentials, subscriptionIdOrOptions, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        let subscriptionId;
        if (typeof subscriptionIdOrOptions === "string") {
            subscriptionId = subscriptionIdOrOptions;
        }
        else if (typeof subscriptionIdOrOptions === "object") {
            options = subscriptionIdOrOptions;
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials,
        };
        const packageDetails = `azsdk-js-arm-appservice/15.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline.bearerTokenAuthenticationPolicyName,
            });
            this.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient.authorizeRequestOnClaimChallenge,
                },
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-12-01";
        this.appServiceCertificateOrders = new AppServiceCertificateOrdersImpl(this);
        this.certificateOrdersDiagnostics = new CertificateOrdersDiagnosticsImpl(this);
        this.certificateRegistrationProvider =
            new CertificateRegistrationProviderImpl(this);
        this.domains = new DomainsImpl(this);
        this.topLevelDomains = new TopLevelDomainsImpl(this);
        this.domainRegistrationProvider = new DomainRegistrationProviderImpl(this);
        this.appServiceEnvironments = new AppServiceEnvironmentsImpl(this);
        this.appServicePlans = new AppServicePlansImpl(this);
        this.certificates = new CertificatesImpl(this);
        this.containerApps = new ContainerAppsImpl(this);
        this.containerAppsRevisions = new ContainerAppsRevisionsImpl(this);
        this.deletedWebApps = new DeletedWebAppsImpl(this);
        this.diagnostics = new DiagnosticsImpl(this);
        this.global = new GlobalImpl(this);
        this.kubeEnvironments = new KubeEnvironmentsImpl(this);
        this.provider = new ProviderImpl(this);
        this.recommendations = new RecommendationsImpl(this);
        this.resourceHealthMetadataOperations =
            new ResourceHealthMetadataOperationsImpl(this);
        this.getUsagesInLocation = new GetUsagesInLocationImpl(this);
        this.staticSites = new StaticSitesImpl(this);
        this.webApps = new WebAppsImpl(this);
        this.workflows = new WorkflowsImpl(this);
        this.workflowRuns = new WorkflowRunsImpl(this);
        this.workflowRunActions = new WorkflowRunActionsImpl(this);
        this.workflowRunActionRepetitions = new WorkflowRunActionRepetitionsImpl(this);
        this.workflowRunActionRepetitionsRequestHistories =
            new WorkflowRunActionRepetitionsRequestHistoriesImpl(this);
        this.workflowRunActionScopeRepetitions =
            new WorkflowRunActionScopeRepetitionsImpl(this);
        this.workflowTriggers = new WorkflowTriggersImpl(this);
        this.workflowTriggerHistories = new WorkflowTriggerHistoriesImpl(this);
        this.workflowVersions = new WorkflowVersionsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return __awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            },
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Description for Gets the source controls available for Azure websites.
     * @param options The options parameters.
     */
    listSourceControls(options) {
        const iter = this.listSourceControlsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSourceControlsPagingPage(options, settings);
            },
        };
    }
    listSourceControlsPagingPage(options, settings) {
        return __asyncGenerator(this, arguments, function* listSourceControlsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listSourceControls(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listSourceControlsNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listSourceControlsPagingAll(options) {
        return __asyncGenerator(this, arguments, function* listSourceControlsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSourceControlsPagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Gets a list of meters for a given location.
     * @param options The options parameters.
     */
    listBillingMeters(options) {
        const iter = this.listBillingMetersPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBillingMetersPagingPage(options, settings);
            },
        };
    }
    listBillingMetersPagingPage(options, settings) {
        return __asyncGenerator(this, arguments, function* listBillingMetersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listBillingMeters(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listBillingMetersNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listBillingMetersPagingAll(options) {
        return __asyncGenerator(this, arguments, function* listBillingMetersPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listBillingMetersPagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get custom hostnames under this subscription
     * @param options The options parameters.
     */
    listCustomHostNameSites(options) {
        const iter = this.listCustomHostNameSitesPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCustomHostNameSitesPagingPage(options, settings);
            },
        };
    }
    listCustomHostNameSitesPagingPage(options, settings) {
        return __asyncGenerator(this, arguments, function* listCustomHostNameSitesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listCustomHostNameSites(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listCustomHostNameSitesNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listCustomHostNameSitesPagingAll(options) {
        return __asyncGenerator(this, arguments, function* listCustomHostNameSitesPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listCustomHostNameSitesPagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for get a list of available ASE regions and its supported Skus.
     * @param options The options parameters.
     */
    listAseRegions(options) {
        const iter = this.listAseRegionsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAseRegionsPagingPage(options, settings);
            },
        };
    }
    listAseRegionsPagingPage(options, settings) {
        return __asyncGenerator(this, arguments, function* listAseRegionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listAseRegions(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listAseRegionsNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listAseRegionsPagingAll(options) {
        return __asyncGenerator(this, arguments, function* listAseRegionsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listAseRegionsPagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get a list of available geographical regions.
     * @param options The options parameters.
     */
    listGeoRegions(options) {
        const iter = this.listGeoRegionsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGeoRegionsPagingPage(options, settings);
            },
        };
    }
    listGeoRegionsPagingPage(options, settings) {
        return __asyncGenerator(this, arguments, function* listGeoRegionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listGeoRegions(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listGeoRegionsNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listGeoRegionsPagingAll(options) {
        return __asyncGenerator(this, arguments, function* listGeoRegionsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listGeoRegionsPagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for List all apps that are assigned to a hostname.
     * @param nameIdentifier Hostname information.
     * @param options The options parameters.
     */
    listSiteIdentifiersAssignedToHostName(nameIdentifier, options) {
        const iter = this.listSiteIdentifiersAssignedToHostNamePagingAll(nameIdentifier, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteIdentifiersAssignedToHostNamePagingPage(nameIdentifier, options, settings);
            },
        };
    }
    listSiteIdentifiersAssignedToHostNamePagingPage(nameIdentifier, options, settings) {
        return __asyncGenerator(this, arguments, function* listSiteIdentifiersAssignedToHostNamePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listSiteIdentifiersAssignedToHostName(nameIdentifier, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listSiteIdentifiersAssignedToHostNameNext(nameIdentifier, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listSiteIdentifiersAssignedToHostNamePagingAll(nameIdentifier, options) {
        return __asyncGenerator(this, arguments, function* listSiteIdentifiersAssignedToHostNamePagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSiteIdentifiersAssignedToHostNamePagingPage(nameIdentifier, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for List all premier add-on offers.
     * @param options The options parameters.
     */
    listPremierAddOnOffers(options) {
        const iter = this.listPremierAddOnOffersPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPremierAddOnOffersPagingPage(options, settings);
            },
        };
    }
    listPremierAddOnOffersPagingPage(options, settings) {
        return __asyncGenerator(this, arguments, function* listPremierAddOnOffersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listPremierAddOnOffers(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listPremierAddOnOffersNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listPremierAddOnOffersPagingAll(options) {
        return __asyncGenerator(this, arguments, function* listPremierAddOnOffersPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listPremierAddOnOffersPagingPage(options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Gets publishing user
     * @param options The options parameters.
     */
    getPublishingUser(options) {
        return this.sendOperationRequest({ options }, getPublishingUserOperationSpec);
    }
    /**
     * Description for Updates publishing user
     * @param userDetails Details of publishing user
     * @param options The options parameters.
     */
    updatePublishingUser(userDetails, options) {
        return this.sendOperationRequest({ userDetails, options }, updatePublishingUserOperationSpec);
    }
    /**
     * Description for Gets the source controls available for Azure websites.
     * @param options The options parameters.
     */
    _listSourceControls(options) {
        return this.sendOperationRequest({ options }, listSourceControlsOperationSpec);
    }
    /**
     * Description for Gets source control token
     * @param sourceControlType Type of source control
     * @param options The options parameters.
     */
    getSourceControl(sourceControlType, options) {
        return this.sendOperationRequest({ sourceControlType, options }, getSourceControlOperationSpec);
    }
    /**
     * Description for Updates source control token
     * @param sourceControlType Type of source control
     * @param requestMessage Source control token information
     * @param options The options parameters.
     */
    updateSourceControl(sourceControlType, requestMessage, options) {
        return this.sendOperationRequest({ sourceControlType, requestMessage, options }, updateSourceControlOperationSpec);
    }
    /**
     * Description for Gets a list of meters for a given location.
     * @param options The options parameters.
     */
    _listBillingMeters(options) {
        return this.sendOperationRequest({ options }, listBillingMetersOperationSpec);
    }
    /**
     * Description for Check if a resource name is available.
     * @param name Resource name to verify.
     * @param typeParam Resource type used for verification.
     * @param options The options parameters.
     */
    checkNameAvailability(name, typeParam, options) {
        return this.sendOperationRequest({ name, typeParam, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Get custom hostnames under this subscription
     * @param options The options parameters.
     */
    _listCustomHostNameSites(options) {
        return this.sendOperationRequest({ options }, listCustomHostNameSitesOperationSpec);
    }
    /**
     * Description for Gets list of available geo regions plus ministamps
     * @param options The options parameters.
     */
    getSubscriptionDeploymentLocations(options) {
        return this.sendOperationRequest({ options }, getSubscriptionDeploymentLocationsOperationSpec);
    }
    /**
     * Description for get a list of available ASE regions and its supported Skus.
     * @param options The options parameters.
     */
    _listAseRegions(options) {
        return this.sendOperationRequest({ options }, listAseRegionsOperationSpec);
    }
    /**
     * Description for Get a list of available geographical regions.
     * @param options The options parameters.
     */
    _listGeoRegions(options) {
        return this.sendOperationRequest({ options }, listGeoRegionsOperationSpec);
    }
    /**
     * Description for List all apps that are assigned to a hostname.
     * @param nameIdentifier Hostname information.
     * @param options The options parameters.
     */
    _listSiteIdentifiersAssignedToHostName(nameIdentifier, options) {
        return this.sendOperationRequest({ nameIdentifier, options }, listSiteIdentifiersAssignedToHostNameOperationSpec);
    }
    /**
     * Description for List all premier add-on offers.
     * @param options The options parameters.
     */
    _listPremierAddOnOffers(options) {
        return this.sendOperationRequest({ options }, listPremierAddOnOffersOperationSpec);
    }
    /**
     * Description for List all SKUs.
     * @param options The options parameters.
     */
    listSkus(options) {
        return this.sendOperationRequest({ options }, listSkusOperationSpec);
    }
    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the
     * Network Security Group rules.
     * @param parameters VNET information
     * @param options The options parameters.
     */
    verifyHostingEnvironmentVnet(parameters, options) {
        return this.sendOperationRequest({ parameters, options }, verifyHostingEnvironmentVnetOperationSpec);
    }
    /**
     * Description for Move resources between resource groups.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @param options The options parameters.
     */
    move(resourceGroupName, moveResourceEnvelope, options) {
        return this.sendOperationRequest({ resourceGroupName, moveResourceEnvelope, options }, moveOperationSpec);
    }
    /**
     * Description for Validate if a resource can be created.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Request with the resources to validate.
     * @param options The options parameters.
     */
    validate(resourceGroupName, validateRequest, options) {
        return this.sendOperationRequest({ resourceGroupName, validateRequest, options }, validateOperationSpec);
    }
    /**
     * Description for Validate whether a resource can be moved.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @param options The options parameters.
     */
    validateMove(resourceGroupName, moveResourceEnvelope, options) {
        return this.sendOperationRequest({ resourceGroupName, moveResourceEnvelope, options }, validateMoveOperationSpec);
    }
    /**
     * ListSourceControlsNext
     * @param nextLink The nextLink from the previous successful call to the ListSourceControls method.
     * @param options The options parameters.
     */
    _listSourceControlsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listSourceControlsNextOperationSpec);
    }
    /**
     * ListBillingMetersNext
     * @param nextLink The nextLink from the previous successful call to the ListBillingMeters method.
     * @param options The options parameters.
     */
    _listBillingMetersNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listBillingMetersNextOperationSpec);
    }
    /**
     * ListCustomHostNameSitesNext
     * @param nextLink The nextLink from the previous successful call to the ListCustomHostNameSites
     *                 method.
     * @param options The options parameters.
     */
    _listCustomHostNameSitesNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listCustomHostNameSitesNextOperationSpec);
    }
    /**
     * ListAseRegionsNext
     * @param nextLink The nextLink from the previous successful call to the ListAseRegions method.
     * @param options The options parameters.
     */
    _listAseRegionsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listAseRegionsNextOperationSpec);
    }
    /**
     * ListGeoRegionsNext
     * @param nextLink The nextLink from the previous successful call to the ListGeoRegions method.
     * @param options The options parameters.
     */
    _listGeoRegionsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listGeoRegionsNextOperationSpec);
    }
    /**
     * ListSiteIdentifiersAssignedToHostNameNext
     * @param nameIdentifier Hostname information.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSiteIdentifiersAssignedToHostName method.
     * @param options The options parameters.
     */
    _listSiteIdentifiersAssignedToHostNameNext(nameIdentifier, nextLink, options) {
        return this.sendOperationRequest({ nameIdentifier, nextLink, options }, listSiteIdentifiersAssignedToHostNameNextOperationSpec);
    }
    /**
     * ListPremierAddOnOffersNext
     * @param nextLink The nextLink from the previous successful call to the ListPremierAddOnOffers method.
     * @param options The options parameters.
     */
    _listPremierAddOnOffersNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listPremierAddOnOffersNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const getPublishingUserOperationSpec = {
    path: "/providers/Microsoft.Web/publishingUsers/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.User,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
};
const updatePublishingUserOperationSpec = {
    path: "/providers/Microsoft.Web/publishingUsers/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.User,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    requestBody: Parameters.userDetails,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listSourceControlsOperationSpec = {
    path: "/providers/Microsoft.Web/sourcecontrols",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SourceControlCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
};
const getSourceControlOperationSpec = {
    path: "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SourceControl,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.sourceControlType],
    headerParameters: [Parameters.accept],
    serializer,
};
const updateSourceControlOperationSpec = {
    path: "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.SourceControl,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    requestBody: Parameters.requestMessage,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.sourceControlType],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listBillingMetersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/billingMeters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BillingMeterCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [
        Parameters.apiVersion,
        Parameters.billingLocation,
        Parameters.osType,
    ],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept],
    serializer,
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ResourceNameAvailability,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    requestBody: {
        parameterPath: {
            name: ["name"],
            typeParam: ["typeParam"],
            isFqdn: ["options", "isFqdn"],
            environmentId: ["options", "environmentId"],
        },
        mapper: Object.assign(Object.assign({}, Mappers.ResourceNameAvailabilityRequest), { required: true }),
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listCustomHostNameSitesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/customhostnameSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.CustomHostnameSitesCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [Parameters.apiVersion, Parameters.hostname],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept],
    serializer,
};
const getSubscriptionDeploymentLocationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deploymentLocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentLocations,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept],
    serializer,
};
const listAseRegionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/aseRegions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AseRegionCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept],
    serializer,
};
const listGeoRegionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.GeoRegionCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [
        Parameters.apiVersion,
        Parameters.sku,
        Parameters.linuxWorkersEnabled,
        Parameters.xenonWorkersEnabled,
        Parameters.linuxDynamicWorkersEnabled,
    ],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept],
    serializer,
};
const listSiteIdentifiersAssignedToHostNameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/listSitesAssignedToHostName",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.IdentifierCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    requestBody: Parameters.nameIdentifier,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listPremierAddOnOffersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.PremierAddOnOfferCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept],
    serializer,
};
const listSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SkuInfos,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept],
    serializer,
};
const verifyHostingEnvironmentVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/verifyHostingEnvironmentVnet",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.VnetValidationFailureDetails,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    requestBody: Parameters.parameters1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const moveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    requestBody: Parameters.moveResourceEnvelope,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const validateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ValidateResponse,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    requestBody: Parameters.validateRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const validateMoveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    requestBody: Parameters.moveResourceEnvelope,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listSourceControlsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SourceControlCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    urlParameters: [Parameters.$host, Parameters.nextLink],
    headerParameters: [Parameters.accept],
    serializer,
};
const listBillingMetersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BillingMeterCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.nextLink,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listCustomHostNameSitesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.CustomHostnameSitesCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.nextLink,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listAseRegionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AseRegionCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.nextLink,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listGeoRegionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.GeoRegionCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.nextLink,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listSiteIdentifiersAssignedToHostNameNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.IdentifierCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.nextLink,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listPremierAddOnOffersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.PremierAddOnOfferCollection,
        },
        default: {
            bodyMapper: Mappers.DefaultErrorResponse,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.nextLink,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
//# sourceMappingURL=webSiteManagementClient.js.map