'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ResourceNotRenewableReason} that the service accepts. */
exports.KnownResourceNotRenewableReason = void 0;
(function (KnownResourceNotRenewableReason) {
    /** RegistrationStatusNotSupportedForRenewal */
    KnownResourceNotRenewableReason["RegistrationStatusNotSupportedForRenewal"] = "RegistrationStatusNotSupportedForRenewal";
    /** ExpirationNotInRenewalTimeRange */
    KnownResourceNotRenewableReason["ExpirationNotInRenewalTimeRange"] = "ExpirationNotInRenewalTimeRange";
    /** SubscriptionNotActive */
    KnownResourceNotRenewableReason["SubscriptionNotActive"] = "SubscriptionNotActive";
})(exports.KnownResourceNotRenewableReason || (exports.KnownResourceNotRenewableReason = {}));
/** Known values of {@link LoadBalancingMode} that the service accepts. */
exports.KnownLoadBalancingMode = void 0;
(function (KnownLoadBalancingMode) {
    /** None */
    KnownLoadBalancingMode["None"] = "None";
    /** Web */
    KnownLoadBalancingMode["Web"] = "Web";
    /** Publishing */
    KnownLoadBalancingMode["Publishing"] = "Publishing";
    /** WebPublishing */
    KnownLoadBalancingMode["WebPublishing"] = "Web, Publishing";
})(exports.KnownLoadBalancingMode || (exports.KnownLoadBalancingMode = {}));
/** Known values of {@link UpgradePreference} that the service accepts. */
exports.KnownUpgradePreference = void 0;
(function (KnownUpgradePreference) {
    /** No preference on when this App Service Environment will be upgraded */
    KnownUpgradePreference["None"] = "None";
    /** This App Service Environment will be upgraded before others in the same region that have Upgrade Preference 'Late' */
    KnownUpgradePreference["Early"] = "Early";
    /** This App Service Environment will be upgraded after others in the same region that have Upgrade Preference 'Early' */
    KnownUpgradePreference["Late"] = "Late";
    /** ASEv3 only. Once an upgrade is available, this App Service Environment will wait 10 days for the upgrade to be manually initiated. After 10 days the upgrade will begin automatically */
    KnownUpgradePreference["Manual"] = "Manual";
})(exports.KnownUpgradePreference || (exports.KnownUpgradePreference = {}));
/** Known values of {@link UpgradeAvailability} that the service accepts. */
exports.KnownUpgradeAvailability = void 0;
(function (KnownUpgradeAvailability) {
    /** No upgrade is currently available for this App Service Environment */
    KnownUpgradeAvailability["None"] = "None";
    /** An upgrade is ready to be manually initiated on this App Service Environment */
    KnownUpgradeAvailability["Ready"] = "Ready";
})(exports.KnownUpgradeAvailability || (exports.KnownUpgradeAvailability = {}));
/** Known values of {@link ScmType} that the service accepts. */
exports.KnownScmType = void 0;
(function (KnownScmType) {
    /** None */
    KnownScmType["None"] = "None";
    /** Dropbox */
    KnownScmType["Dropbox"] = "Dropbox";
    /** Tfs */
    KnownScmType["Tfs"] = "Tfs";
    /** LocalGit */
    KnownScmType["LocalGit"] = "LocalGit";
    /** GitHub */
    KnownScmType["GitHub"] = "GitHub";
    /** CodePlexGit */
    KnownScmType["CodePlexGit"] = "CodePlexGit";
    /** CodePlexHg */
    KnownScmType["CodePlexHg"] = "CodePlexHg";
    /** BitbucketGit */
    KnownScmType["BitbucketGit"] = "BitbucketGit";
    /** BitbucketHg */
    KnownScmType["BitbucketHg"] = "BitbucketHg";
    /** ExternalGit */
    KnownScmType["ExternalGit"] = "ExternalGit";
    /** ExternalHg */
    KnownScmType["ExternalHg"] = "ExternalHg";
    /** OneDrive */
    KnownScmType["OneDrive"] = "OneDrive";
    /** VSO */
    KnownScmType["VSO"] = "VSO";
    /** Vstsrm */
    KnownScmType["Vstsrm"] = "VSTSRM";
})(exports.KnownScmType || (exports.KnownScmType = {}));
/** Known values of {@link IpFilterTag} that the service accepts. */
exports.KnownIpFilterTag = void 0;
(function (KnownIpFilterTag) {
    /** Default */
    KnownIpFilterTag["Default"] = "Default";
    /** XffProxy */
    KnownIpFilterTag["XffProxy"] = "XffProxy";
    /** ServiceTag */
    KnownIpFilterTag["ServiceTag"] = "ServiceTag";
})(exports.KnownIpFilterTag || (exports.KnownIpFilterTag = {}));
/** Known values of {@link DefaultAction} that the service accepts. */
exports.KnownDefaultAction = void 0;
(function (KnownDefaultAction) {
    /** Allow */
    KnownDefaultAction["Allow"] = "Allow";
    /** Deny */
    KnownDefaultAction["Deny"] = "Deny";
})(exports.KnownDefaultAction || (exports.KnownDefaultAction = {}));
/** Known values of {@link SupportedTlsVersions} that the service accepts. */
exports.KnownSupportedTlsVersions = void 0;
(function (KnownSupportedTlsVersions) {
    /** One0 */
    KnownSupportedTlsVersions["One0"] = "1.0";
    /** One1 */
    KnownSupportedTlsVersions["One1"] = "1.1";
    /** One2 */
    KnownSupportedTlsVersions["One2"] = "1.2";
    /** One3 */
    KnownSupportedTlsVersions["One3"] = "1.3";
})(exports.KnownSupportedTlsVersions || (exports.KnownSupportedTlsVersions = {}));
/** Known values of {@link TlsCipherSuites} that the service accepts. */
exports.KnownTlsCipherSuites = void 0;
(function (KnownTlsCipherSuites) {
    /** TLSAES256GCMSHA384 */
    KnownTlsCipherSuites["TLSAES256GCMSHA384"] = "TLS_AES_256_GCM_SHA384";
    /** TLSAES128GCMSHA256 */
    KnownTlsCipherSuites["TLSAES128GCMSHA256"] = "TLS_AES_128_GCM_SHA256";
    /** TLSEcdheEcdsaWithAES256GCMSHA384 */
    KnownTlsCipherSuites["TLSEcdheEcdsaWithAES256GCMSHA384"] = "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
    /** TLSEcdheEcdsaWithAES128CBCSHA256 */
    KnownTlsCipherSuites["TLSEcdheEcdsaWithAES128CBCSHA256"] = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
    /** TLSEcdheEcdsaWithAES128GCMSHA256 */
    KnownTlsCipherSuites["TLSEcdheEcdsaWithAES128GCMSHA256"] = "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
    /** TLSEcdheRSAWithAES256GCMSHA384 */
    KnownTlsCipherSuites["TLSEcdheRSAWithAES256GCMSHA384"] = "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
    /** TLSEcdheRSAWithAES128GCMSHA256 */
    KnownTlsCipherSuites["TLSEcdheRSAWithAES128GCMSHA256"] = "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
    /** TLSEcdheRSAWithAES256CBCSHA384 */
    KnownTlsCipherSuites["TLSEcdheRSAWithAES256CBCSHA384"] = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
    /** TLSEcdheRSAWithAES128CBCSHA256 */
    KnownTlsCipherSuites["TLSEcdheRSAWithAES128CBCSHA256"] = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
    /** TLSEcdheRSAWithAES256CBCSHA */
    KnownTlsCipherSuites["TLSEcdheRSAWithAES256CBCSHA"] = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
    /** TLSEcdheRSAWithAES128CBCSHA */
    KnownTlsCipherSuites["TLSEcdheRSAWithAES128CBCSHA"] = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
    /** TLSRSAWithAES256GCMSHA384 */
    KnownTlsCipherSuites["TLSRSAWithAES256GCMSHA384"] = "TLS_RSA_WITH_AES_256_GCM_SHA384";
    /** TLSRSAWithAES128GCMSHA256 */
    KnownTlsCipherSuites["TLSRSAWithAES128GCMSHA256"] = "TLS_RSA_WITH_AES_128_GCM_SHA256";
    /** TLSRSAWithAES256CBCSHA256 */
    KnownTlsCipherSuites["TLSRSAWithAES256CBCSHA256"] = "TLS_RSA_WITH_AES_256_CBC_SHA256";
    /** TLSRSAWithAES128CBCSHA256 */
    KnownTlsCipherSuites["TLSRSAWithAES128CBCSHA256"] = "TLS_RSA_WITH_AES_128_CBC_SHA256";
    /** TLSRSAWithAES256CBCSHA */
    KnownTlsCipherSuites["TLSRSAWithAES256CBCSHA"] = "TLS_RSA_WITH_AES_256_CBC_SHA";
    /** TLSRSAWithAES128CBCSHA */
    KnownTlsCipherSuites["TLSRSAWithAES128CBCSHA"] = "TLS_RSA_WITH_AES_128_CBC_SHA";
})(exports.KnownTlsCipherSuites || (exports.KnownTlsCipherSuites = {}));
/** Known values of {@link FtpsState} that the service accepts. */
exports.KnownFtpsState = void 0;
(function (KnownFtpsState) {
    /** AllAllowed */
    KnownFtpsState["AllAllowed"] = "AllAllowed";
    /** FtpsOnly */
    KnownFtpsState["FtpsOnly"] = "FtpsOnly";
    /** Disabled */
    KnownFtpsState["Disabled"] = "Disabled";
})(exports.KnownFtpsState || (exports.KnownFtpsState = {}));
/** Known values of {@link AzureStorageProtocol} that the service accepts. */
exports.KnownAzureStorageProtocol = void 0;
(function (KnownAzureStorageProtocol) {
    /** Smb */
    KnownAzureStorageProtocol["Smb"] = "Smb";
    /** Http */
    KnownAzureStorageProtocol["Http"] = "Http";
    /** Nfs */
    KnownAzureStorageProtocol["Nfs"] = "Nfs";
})(exports.KnownAzureStorageProtocol || (exports.KnownAzureStorageProtocol = {}));
/** Known values of {@link FunctionsDeploymentStorageType} that the service accepts. */
exports.KnownFunctionsDeploymentStorageType = void 0;
(function (KnownFunctionsDeploymentStorageType) {
    /** BlobContainer */
    KnownFunctionsDeploymentStorageType["BlobContainer"] = "blobContainer";
})(exports.KnownFunctionsDeploymentStorageType || (exports.KnownFunctionsDeploymentStorageType = {}));
/** Known values of {@link AuthenticationType} that the service accepts. */
exports.KnownAuthenticationType = void 0;
(function (KnownAuthenticationType) {
    /** SystemAssignedIdentity */
    KnownAuthenticationType["SystemAssignedIdentity"] = "SystemAssignedIdentity";
    /** UserAssignedIdentity */
    KnownAuthenticationType["UserAssignedIdentity"] = "UserAssignedIdentity";
    /** StorageAccountConnectionString */
    KnownAuthenticationType["StorageAccountConnectionString"] = "StorageAccountConnectionString";
})(exports.KnownAuthenticationType || (exports.KnownAuthenticationType = {}));
/** Known values of {@link RuntimeName} that the service accepts. */
exports.KnownRuntimeName = void 0;
(function (KnownRuntimeName) {
    /** DotnetIsolated */
    KnownRuntimeName["DotnetIsolated"] = "dotnet-isolated";
    /** Node */
    KnownRuntimeName["Node"] = "node";
    /** Java */
    KnownRuntimeName["Java"] = "java";
    /** Powershell */
    KnownRuntimeName["Powershell"] = "powershell";
    /** Python */
    KnownRuntimeName["Python"] = "python";
    /** Custom */
    KnownRuntimeName["Custom"] = "custom";
})(exports.KnownRuntimeName || (exports.KnownRuntimeName = {}));
/** Known values of {@link DaprLogLevel} that the service accepts. */
exports.KnownDaprLogLevel = void 0;
(function (KnownDaprLogLevel) {
    /** Info */
    KnownDaprLogLevel["Info"] = "info";
    /** Debug */
    KnownDaprLogLevel["Debug"] = "debug";
    /** Warn */
    KnownDaprLogLevel["Warn"] = "warn";
    /** Error */
    KnownDaprLogLevel["Error"] = "error";
})(exports.KnownDaprLogLevel || (exports.KnownDaprLogLevel = {}));
/** Known values of {@link RouteType} that the service accepts. */
exports.KnownRouteType = void 0;
(function (KnownRouteType) {
    /** Default */
    KnownRouteType["Default"] = "DEFAULT";
    /** Inherited */
    KnownRouteType["Inherited"] = "INHERITED";
    /** Static */
    KnownRouteType["Static"] = "STATIC";
})(exports.KnownRouteType || (exports.KnownRouteType = {}));
/** Known values of {@link ContainerAppProvisioningState} that the service accepts. */
exports.KnownContainerAppProvisioningState = void 0;
(function (KnownContainerAppProvisioningState) {
    /** InProgress */
    KnownContainerAppProvisioningState["InProgress"] = "InProgress";
    /** Succeeded */
    KnownContainerAppProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownContainerAppProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownContainerAppProvisioningState["Canceled"] = "Canceled";
})(exports.KnownContainerAppProvisioningState || (exports.KnownContainerAppProvisioningState = {}));
/** Known values of {@link ActiveRevisionsMode} that the service accepts. */
exports.KnownActiveRevisionsMode = void 0;
(function (KnownActiveRevisionsMode) {
    /** Multiple */
    KnownActiveRevisionsMode["Multiple"] = "multiple";
    /** Single */
    KnownActiveRevisionsMode["Single"] = "single";
})(exports.KnownActiveRevisionsMode || (exports.KnownActiveRevisionsMode = {}));
/** Known values of {@link IngressTransportMethod} that the service accepts. */
exports.KnownIngressTransportMethod = void 0;
(function (KnownIngressTransportMethod) {
    /** Auto */
    KnownIngressTransportMethod["Auto"] = "auto";
    /** Http */
    KnownIngressTransportMethod["Http"] = "http";
    /** Http2 */
    KnownIngressTransportMethod["Http2"] = "http2";
})(exports.KnownIngressTransportMethod || (exports.KnownIngressTransportMethod = {}));
/** Known values of {@link RevisionHealthState} that the service accepts. */
exports.KnownRevisionHealthState = void 0;
(function (KnownRevisionHealthState) {
    /** Healthy */
    KnownRevisionHealthState["Healthy"] = "Healthy";
    /** Unhealthy */
    KnownRevisionHealthState["Unhealthy"] = "Unhealthy";
    /** None */
    KnownRevisionHealthState["None"] = "None";
})(exports.KnownRevisionHealthState || (exports.KnownRevisionHealthState = {}));
/** Known values of {@link RevisionProvisioningState} that the service accepts. */
exports.KnownRevisionProvisioningState = void 0;
(function (KnownRevisionProvisioningState) {
    /** Provisioning */
    KnownRevisionProvisioningState["Provisioning"] = "Provisioning";
    /** Provisioned */
    KnownRevisionProvisioningState["Provisioned"] = "Provisioned";
    /** Failed */
    KnownRevisionProvisioningState["Failed"] = "Failed";
    /** Deprovisioning */
    KnownRevisionProvisioningState["Deprovisioning"] = "Deprovisioning";
    /** Deprovisioned */
    KnownRevisionProvisioningState["Deprovisioned"] = "Deprovisioned";
})(exports.KnownRevisionProvisioningState || (exports.KnownRevisionProvisioningState = {}));
/** Known values of {@link ProviderOsTypeSelected} that the service accepts. */
exports.KnownProviderOsTypeSelected = void 0;
(function (KnownProviderOsTypeSelected) {
    /** Windows */
    KnownProviderOsTypeSelected["Windows"] = "Windows";
    /** Linux */
    KnownProviderOsTypeSelected["Linux"] = "Linux";
    /** WindowsFunctions */
    KnownProviderOsTypeSelected["WindowsFunctions"] = "WindowsFunctions";
    /** LinuxFunctions */
    KnownProviderOsTypeSelected["LinuxFunctions"] = "LinuxFunctions";
    /** All */
    KnownProviderOsTypeSelected["All"] = "All";
})(exports.KnownProviderOsTypeSelected || (exports.KnownProviderOsTypeSelected = {}));
/** Known values of {@link ProviderStackOsType} that the service accepts. */
exports.KnownProviderStackOsType = void 0;
(function (KnownProviderStackOsType) {
    /** Windows */
    KnownProviderStackOsType["Windows"] = "Windows";
    /** Linux */
    KnownProviderStackOsType["Linux"] = "Linux";
    /** All */
    KnownProviderStackOsType["All"] = "All";
})(exports.KnownProviderStackOsType || (exports.KnownProviderStackOsType = {}));
/** Known values of {@link ResourceScopeType} that the service accepts. */
exports.KnownResourceScopeType = void 0;
(function (KnownResourceScopeType) {
    /** ServerFarm */
    KnownResourceScopeType["ServerFarm"] = "ServerFarm";
    /** Subscription */
    KnownResourceScopeType["Subscription"] = "Subscription";
    /** WebSite */
    KnownResourceScopeType["WebSite"] = "WebSite";
})(exports.KnownResourceScopeType || (exports.KnownResourceScopeType = {}));
/** Known values of {@link CheckNameResourceTypes} that the service accepts. */
exports.KnownCheckNameResourceTypes = void 0;
(function (KnownCheckNameResourceTypes) {
    /** Site */
    KnownCheckNameResourceTypes["Site"] = "Site";
    /** Slot */
    KnownCheckNameResourceTypes["Slot"] = "Slot";
    /** HostingEnvironment */
    KnownCheckNameResourceTypes["HostingEnvironment"] = "HostingEnvironment";
    /** PublishingUser */
    KnownCheckNameResourceTypes["PublishingUser"] = "PublishingUser";
    /** MicrosoftWebSites */
    KnownCheckNameResourceTypes["MicrosoftWebSites"] = "Microsoft.Web/sites";
    /** MicrosoftWebSitesSlots */
    KnownCheckNameResourceTypes["MicrosoftWebSitesSlots"] = "Microsoft.Web/sites/slots";
    /** MicrosoftWebHostingEnvironments */
    KnownCheckNameResourceTypes["MicrosoftWebHostingEnvironments"] = "Microsoft.Web/hostingEnvironments";
    /** MicrosoftWebPublishingUsers */
    KnownCheckNameResourceTypes["MicrosoftWebPublishingUsers"] = "Microsoft.Web/publishingUsers";
})(exports.KnownCheckNameResourceTypes || (exports.KnownCheckNameResourceTypes = {}));
/** Known values of {@link InAvailabilityReasonType} that the service accepts. */
exports.KnownInAvailabilityReasonType = void 0;
(function (KnownInAvailabilityReasonType) {
    /** Invalid */
    KnownInAvailabilityReasonType["Invalid"] = "Invalid";
    /** AlreadyExists */
    KnownInAvailabilityReasonType["AlreadyExists"] = "AlreadyExists";
})(exports.KnownInAvailabilityReasonType || (exports.KnownInAvailabilityReasonType = {}));
/** Known values of {@link SkuName} that the service accepts. */
exports.KnownSkuName = void 0;
(function (KnownSkuName) {
    /** Free */
    KnownSkuName["Free"] = "Free";
    /** Shared */
    KnownSkuName["Shared"] = "Shared";
    /** Basic */
    KnownSkuName["Basic"] = "Basic";
    /** Standard */
    KnownSkuName["Standard"] = "Standard";
    /** Premium */
    KnownSkuName["Premium"] = "Premium";
    /** Dynamic */
    KnownSkuName["Dynamic"] = "Dynamic";
    /** Isolated */
    KnownSkuName["Isolated"] = "Isolated";
    /** IsolatedV2 */
    KnownSkuName["IsolatedV2"] = "IsolatedV2";
    /** PremiumV2 */
    KnownSkuName["PremiumV2"] = "PremiumV2";
    /** PremiumV3 */
    KnownSkuName["PremiumV3"] = "PremiumV3";
    /** PremiumContainer */
    KnownSkuName["PremiumContainer"] = "PremiumContainer";
    /** ElasticPremium */
    KnownSkuName["ElasticPremium"] = "ElasticPremium";
    /** ElasticIsolated */
    KnownSkuName["ElasticIsolated"] = "ElasticIsolated";
    /** FlexConsumption */
    KnownSkuName["FlexConsumption"] = "FlexConsumption";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
/** Known values of {@link ValidateResourceTypes} that the service accepts. */
exports.KnownValidateResourceTypes = void 0;
(function (KnownValidateResourceTypes) {
    /** ServerFarm */
    KnownValidateResourceTypes["ServerFarm"] = "ServerFarm";
    /** Site */
    KnownValidateResourceTypes["Site"] = "Site";
    /** MicrosoftWebHostingEnvironments */
    KnownValidateResourceTypes["MicrosoftWebHostingEnvironments"] = "Microsoft.Web/hostingEnvironments";
})(exports.KnownValidateResourceTypes || (exports.KnownValidateResourceTypes = {}));
/** Known values of {@link EnterpriseGradeCdnStatus} that the service accepts. */
exports.KnownEnterpriseGradeCdnStatus = void 0;
(function (KnownEnterpriseGradeCdnStatus) {
    /** Enabled */
    KnownEnterpriseGradeCdnStatus["Enabled"] = "Enabled";
    /** Enabling */
    KnownEnterpriseGradeCdnStatus["Enabling"] = "Enabling";
    /** Disabled */
    KnownEnterpriseGradeCdnStatus["Disabled"] = "Disabled";
    /** Disabling */
    KnownEnterpriseGradeCdnStatus["Disabling"] = "Disabling";
})(exports.KnownEnterpriseGradeCdnStatus || (exports.KnownEnterpriseGradeCdnStatus = {}));
/** Known values of {@link BuildStatus} that the service accepts. */
exports.KnownBuildStatus = void 0;
(function (KnownBuildStatus) {
    /** WaitingForDeployment */
    KnownBuildStatus["WaitingForDeployment"] = "WaitingForDeployment";
    /** Uploading */
    KnownBuildStatus["Uploading"] = "Uploading";
    /** Deploying */
    KnownBuildStatus["Deploying"] = "Deploying";
    /** Ready */
    KnownBuildStatus["Ready"] = "Ready";
    /** Failed */
    KnownBuildStatus["Failed"] = "Failed";
    /** Deleting */
    KnownBuildStatus["Deleting"] = "Deleting";
    /** Detached */
    KnownBuildStatus["Detached"] = "Detached";
})(exports.KnownBuildStatus || (exports.KnownBuildStatus = {}));
/** Known values of {@link TriggerTypes} that the service accepts. */
exports.KnownTriggerTypes = void 0;
(function (KnownTriggerTypes) {
    /** HttpTrigger */
    KnownTriggerTypes["HttpTrigger"] = "HttpTrigger";
    /** Unknown */
    KnownTriggerTypes["Unknown"] = "Unknown";
})(exports.KnownTriggerTypes || (exports.KnownTriggerTypes = {}));
/** Known values of {@link BasicAuthName} that the service accepts. */
exports.KnownBasicAuthName = void 0;
(function (KnownBasicAuthName) {
    /** Default */
    KnownBasicAuthName["Default"] = "default";
})(exports.KnownBasicAuthName || (exports.KnownBasicAuthName = {}));
/** Known values of {@link CustomDomainStatus} that the service accepts. */
exports.KnownCustomDomainStatus = void 0;
(function (KnownCustomDomainStatus) {
    /** RetrievingValidationToken */
    KnownCustomDomainStatus["RetrievingValidationToken"] = "RetrievingValidationToken";
    /** Validating */
    KnownCustomDomainStatus["Validating"] = "Validating";
    /** Adding */
    KnownCustomDomainStatus["Adding"] = "Adding";
    /** Ready */
    KnownCustomDomainStatus["Ready"] = "Ready";
    /** Failed */
    KnownCustomDomainStatus["Failed"] = "Failed";
    /** Deleting */
    KnownCustomDomainStatus["Deleting"] = "Deleting";
    /** Unhealthy */
    KnownCustomDomainStatus["Unhealthy"] = "Unhealthy";
})(exports.KnownCustomDomainStatus || (exports.KnownCustomDomainStatus = {}));
/** Known values of {@link DatabaseType} that the service accepts. */
exports.KnownDatabaseType = void 0;
(function (KnownDatabaseType) {
    /** SqlAzure */
    KnownDatabaseType["SqlAzure"] = "SqlAzure";
    /** MySql */
    KnownDatabaseType["MySql"] = "MySql";
    /** LocalMySql */
    KnownDatabaseType["LocalMySql"] = "LocalMySql";
    /** PostgreSql */
    KnownDatabaseType["PostgreSql"] = "PostgreSql";
})(exports.KnownDatabaseType || (exports.KnownDatabaseType = {}));
/** Known values of {@link DeploymentBuildStatus} that the service accepts. */
exports.KnownDeploymentBuildStatus = void 0;
(function (KnownDeploymentBuildStatus) {
    /** TimedOut */
    KnownDeploymentBuildStatus["TimedOut"] = "TimedOut";
    /** RuntimeFailed */
    KnownDeploymentBuildStatus["RuntimeFailed"] = "RuntimeFailed";
    /** BuildAborted */
    KnownDeploymentBuildStatus["BuildAborted"] = "BuildAborted";
    /** BuildFailed */
    KnownDeploymentBuildStatus["BuildFailed"] = "BuildFailed";
    /** BuildRequestReceived */
    KnownDeploymentBuildStatus["BuildRequestReceived"] = "BuildRequestReceived";
    /** BuildPending */
    KnownDeploymentBuildStatus["BuildPending"] = "BuildPending";
    /** BuildInProgress */
    KnownDeploymentBuildStatus["BuildInProgress"] = "BuildInProgress";
    /** BuildSuccessful */
    KnownDeploymentBuildStatus["BuildSuccessful"] = "BuildSuccessful";
    /** PostBuildRestartRequired */
    KnownDeploymentBuildStatus["PostBuildRestartRequired"] = "PostBuildRestartRequired";
    /** StartPolling */
    KnownDeploymentBuildStatus["StartPolling"] = "StartPolling";
    /** StartPollingWithRestart */
    KnownDeploymentBuildStatus["StartPollingWithRestart"] = "StartPollingWithRestart";
    /** RuntimeStarting */
    KnownDeploymentBuildStatus["RuntimeStarting"] = "RuntimeStarting";
    /** RuntimeSuccessful */
    KnownDeploymentBuildStatus["RuntimeSuccessful"] = "RuntimeSuccessful";
})(exports.KnownDeploymentBuildStatus || (exports.KnownDeploymentBuildStatus = {}));
/** Known values of {@link PublishingProfileFormat} that the service accepts. */
exports.KnownPublishingProfileFormat = void 0;
(function (KnownPublishingProfileFormat) {
    /** FileZilla3 */
    KnownPublishingProfileFormat["FileZilla3"] = "FileZilla3";
    /** WebDeploy */
    KnownPublishingProfileFormat["WebDeploy"] = "WebDeploy";
    /** Ftp */
    KnownPublishingProfileFormat["Ftp"] = "Ftp";
})(exports.KnownPublishingProfileFormat || (exports.KnownPublishingProfileFormat = {}));
/** Known values of {@link WorkflowState} that the service accepts. */
exports.KnownWorkflowState = void 0;
(function (KnownWorkflowState) {
    /** NotSpecified */
    KnownWorkflowState["NotSpecified"] = "NotSpecified";
    /** Completed */
    KnownWorkflowState["Completed"] = "Completed";
    /** Enabled */
    KnownWorkflowState["Enabled"] = "Enabled";
    /** Disabled */
    KnownWorkflowState["Disabled"] = "Disabled";
    /** Deleted */
    KnownWorkflowState["Deleted"] = "Deleted";
    /** Suspended */
    KnownWorkflowState["Suspended"] = "Suspended";
})(exports.KnownWorkflowState || (exports.KnownWorkflowState = {}));
/** Known values of {@link KeyType} that the service accepts. */
exports.KnownKeyType = void 0;
(function (KnownKeyType) {
    /** NotSpecified */
    KnownKeyType["NotSpecified"] = "NotSpecified";
    /** Primary */
    KnownKeyType["Primary"] = "Primary";
    /** Secondary */
    KnownKeyType["Secondary"] = "Secondary";
})(exports.KnownKeyType || (exports.KnownKeyType = {}));
/** Known values of {@link WorkflowStatus} that the service accepts. */
exports.KnownWorkflowStatus = void 0;
(function (KnownWorkflowStatus) {
    /** NotSpecified */
    KnownWorkflowStatus["NotSpecified"] = "NotSpecified";
    /** Paused */
    KnownWorkflowStatus["Paused"] = "Paused";
    /** Running */
    KnownWorkflowStatus["Running"] = "Running";
    /** Waiting */
    KnownWorkflowStatus["Waiting"] = "Waiting";
    /** Succeeded */
    KnownWorkflowStatus["Succeeded"] = "Succeeded";
    /** Skipped */
    KnownWorkflowStatus["Skipped"] = "Skipped";
    /** Suspended */
    KnownWorkflowStatus["Suspended"] = "Suspended";
    /** Cancelled */
    KnownWorkflowStatus["Cancelled"] = "Cancelled";
    /** Failed */
    KnownWorkflowStatus["Failed"] = "Failed";
    /** Faulted */
    KnownWorkflowStatus["Faulted"] = "Faulted";
    /** TimedOut */
    KnownWorkflowStatus["TimedOut"] = "TimedOut";
    /** Aborted */
    KnownWorkflowStatus["Aborted"] = "Aborted";
    /** Ignored */
    KnownWorkflowStatus["Ignored"] = "Ignored";
})(exports.KnownWorkflowStatus || (exports.KnownWorkflowStatus = {}));
/** Known values of {@link ParameterType} that the service accepts. */
exports.KnownParameterType = void 0;
(function (KnownParameterType) {
    /** NotSpecified */
    KnownParameterType["NotSpecified"] = "NotSpecified";
    /** String */
    KnownParameterType["String"] = "String";
    /** SecureString */
    KnownParameterType["SecureString"] = "SecureString";
    /** Int */
    KnownParameterType["Int"] = "Int";
    /** Float */
    KnownParameterType["Float"] = "Float";
    /** Bool */
    KnownParameterType["Bool"] = "Bool";
    /** Array */
    KnownParameterType["Array"] = "Array";
    /** Object */
    KnownParameterType["Object"] = "Object";
    /** SecureObject */
    KnownParameterType["SecureObject"] = "SecureObject";
})(exports.KnownParameterType || (exports.KnownParameterType = {}));
/** Known values of {@link WorkflowTriggerProvisioningState} that the service accepts. */
exports.KnownWorkflowTriggerProvisioningState = void 0;
(function (KnownWorkflowTriggerProvisioningState) {
    /** NotSpecified */
    KnownWorkflowTriggerProvisioningState["NotSpecified"] = "NotSpecified";
    /** Accepted */
    KnownWorkflowTriggerProvisioningState["Accepted"] = "Accepted";
    /** Running */
    KnownWorkflowTriggerProvisioningState["Running"] = "Running";
    /** Ready */
    KnownWorkflowTriggerProvisioningState["Ready"] = "Ready";
    /** Creating */
    KnownWorkflowTriggerProvisioningState["Creating"] = "Creating";
    /** Created */
    KnownWorkflowTriggerProvisioningState["Created"] = "Created";
    /** Deleting */
    KnownWorkflowTriggerProvisioningState["Deleting"] = "Deleting";
    /** Deleted */
    KnownWorkflowTriggerProvisioningState["Deleted"] = "Deleted";
    /** Canceled */
    KnownWorkflowTriggerProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownWorkflowTriggerProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownWorkflowTriggerProvisioningState["Succeeded"] = "Succeeded";
    /** Moving */
    KnownWorkflowTriggerProvisioningState["Moving"] = "Moving";
    /** Updating */
    KnownWorkflowTriggerProvisioningState["Updating"] = "Updating";
    /** Registering */
    KnownWorkflowTriggerProvisioningState["Registering"] = "Registering";
    /** Registered */
    KnownWorkflowTriggerProvisioningState["Registered"] = "Registered";
    /** Unregistering */
    KnownWorkflowTriggerProvisioningState["Unregistering"] = "Unregistering";
    /** Unregistered */
    KnownWorkflowTriggerProvisioningState["Unregistered"] = "Unregistered";
    /** Completed */
    KnownWorkflowTriggerProvisioningState["Completed"] = "Completed";
})(exports.KnownWorkflowTriggerProvisioningState || (exports.KnownWorkflowTriggerProvisioningState = {}));
/** Known values of {@link RecurrenceFrequency} that the service accepts. */
exports.KnownRecurrenceFrequency = void 0;
(function (KnownRecurrenceFrequency) {
    /** NotSpecified */
    KnownRecurrenceFrequency["NotSpecified"] = "NotSpecified";
    /** Second */
    KnownRecurrenceFrequency["Second"] = "Second";
    /** Minute */
    KnownRecurrenceFrequency["Minute"] = "Minute";
    /** Hour */
    KnownRecurrenceFrequency["Hour"] = "Hour";
    /** Day */
    KnownRecurrenceFrequency["Day"] = "Day";
    /** Week */
    KnownRecurrenceFrequency["Week"] = "Week";
    /** Month */
    KnownRecurrenceFrequency["Month"] = "Month";
    /** Year */
    KnownRecurrenceFrequency["Year"] = "Year";
})(exports.KnownRecurrenceFrequency || (exports.KnownRecurrenceFrequency = {}));
/** Known values of {@link WorkflowProvisioningState} that the service accepts. */
exports.KnownWorkflowProvisioningState = void 0;
(function (KnownWorkflowProvisioningState) {
    /** NotSpecified */
    KnownWorkflowProvisioningState["NotSpecified"] = "NotSpecified";
    /** Accepted */
    KnownWorkflowProvisioningState["Accepted"] = "Accepted";
    /** Running */
    KnownWorkflowProvisioningState["Running"] = "Running";
    /** Ready */
    KnownWorkflowProvisioningState["Ready"] = "Ready";
    /** Creating */
    KnownWorkflowProvisioningState["Creating"] = "Creating";
    /** Created */
    KnownWorkflowProvisioningState["Created"] = "Created";
    /** Deleting */
    KnownWorkflowProvisioningState["Deleting"] = "Deleting";
    /** Deleted */
    KnownWorkflowProvisioningState["Deleted"] = "Deleted";
    /** Canceled */
    KnownWorkflowProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownWorkflowProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownWorkflowProvisioningState["Succeeded"] = "Succeeded";
    /** Moving */
    KnownWorkflowProvisioningState["Moving"] = "Moving";
    /** Updating */
    KnownWorkflowProvisioningState["Updating"] = "Updating";
    /** Registering */
    KnownWorkflowProvisioningState["Registering"] = "Registering";
    /** Registered */
    KnownWorkflowProvisioningState["Registered"] = "Registered";
    /** Unregistering */
    KnownWorkflowProvisioningState["Unregistering"] = "Unregistering";
    /** Unregistered */
    KnownWorkflowProvisioningState["Unregistered"] = "Unregistered";
    /** Completed */
    KnownWorkflowProvisioningState["Completed"] = "Completed";
    /** Renewing */
    KnownWorkflowProvisioningState["Renewing"] = "Renewing";
    /** Pending */
    KnownWorkflowProvisioningState["Pending"] = "Pending";
    /** Waiting */
    KnownWorkflowProvisioningState["Waiting"] = "Waiting";
    /** InProgress */
    KnownWorkflowProvisioningState["InProgress"] = "InProgress";
})(exports.KnownWorkflowProvisioningState || (exports.KnownWorkflowProvisioningState = {}));
/** Known values of {@link OpenAuthenticationProviderType} that the service accepts. */
exports.KnownOpenAuthenticationProviderType = void 0;
(function (KnownOpenAuthenticationProviderType) {
    /** AAD */
    KnownOpenAuthenticationProviderType["AAD"] = "AAD";
})(exports.KnownOpenAuthenticationProviderType || (exports.KnownOpenAuthenticationProviderType = {}));
/** Known values of {@link WorkflowSkuName} that the service accepts. */
exports.KnownWorkflowSkuName = void 0;
(function (KnownWorkflowSkuName) {
    /** NotSpecified */
    KnownWorkflowSkuName["NotSpecified"] = "NotSpecified";
    /** Free */
    KnownWorkflowSkuName["Free"] = "Free";
    /** Shared */
    KnownWorkflowSkuName["Shared"] = "Shared";
    /** Basic */
    KnownWorkflowSkuName["Basic"] = "Basic";
    /** Standard */
    KnownWorkflowSkuName["Standard"] = "Standard";
    /** Premium */
    KnownWorkflowSkuName["Premium"] = "Premium";
})(exports.KnownWorkflowSkuName || (exports.KnownWorkflowSkuName = {}));
/** Known values of {@link Kind} that the service accepts. */
exports.KnownKind = void 0;
(function (KnownKind) {
    /** Stateful */
    KnownKind["Stateful"] = "Stateful";
    /** Stateless */
    KnownKind["Stateless"] = "Stateless";
})(exports.KnownKind || (exports.KnownKind = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AppServiceCertificateOrderCollection = {
    serializedName: "AppServiceCertificateOrderCollection",
    type: {
        name: "Composite",
        className: "AppServiceCertificateOrderCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AppServiceCertificateOrder",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServiceCertificateOrder",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AppServiceCertificate = {
    serializedName: "AppServiceCertificate",
    type: {
        name: "Composite",
        className: "AppServiceCertificate",
        modelProperties: {
            keyVaultId: {
                serializedName: "keyVaultId",
                xmlName: "keyVaultId",
                type: {
                    name: "String",
                },
            },
            keyVaultSecretName: {
                serializedName: "keyVaultSecretName",
                xmlName: "keyVaultSecretName",
                type: {
                    name: "String",
                },
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                xmlName: "provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown",
                    ],
                },
            },
        },
    },
};
const CertificateDetails = {
    serializedName: "CertificateDetails",
    type: {
        name: "Composite",
        className: "CertificateDetails",
        modelProperties: {
            version: {
                serializedName: "version",
                readOnly: true,
                xmlName: "version",
                type: {
                    name: "Number",
                },
            },
            serialNumber: {
                serializedName: "serialNumber",
                readOnly: true,
                xmlName: "serialNumber",
                type: {
                    name: "String",
                },
            },
            thumbprint: {
                serializedName: "thumbprint",
                readOnly: true,
                xmlName: "thumbprint",
                type: {
                    name: "String",
                },
            },
            subject: {
                serializedName: "subject",
                readOnly: true,
                xmlName: "subject",
                type: {
                    name: "String",
                },
            },
            notBefore: {
                serializedName: "notBefore",
                readOnly: true,
                xmlName: "notBefore",
                type: {
                    name: "DateTime",
                },
            },
            notAfter: {
                serializedName: "notAfter",
                readOnly: true,
                xmlName: "notAfter",
                type: {
                    name: "DateTime",
                },
            },
            signatureAlgorithm: {
                serializedName: "signatureAlgorithm",
                readOnly: true,
                xmlName: "signatureAlgorithm",
                type: {
                    name: "String",
                },
            },
            issuer: {
                serializedName: "issuer",
                readOnly: true,
                xmlName: "issuer",
                type: {
                    name: "String",
                },
            },
            rawData: {
                serializedName: "rawData",
                readOnly: true,
                xmlName: "rawData",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CertificateOrderContact = {
    serializedName: "CertificateOrderContact",
    type: {
        name: "Composite",
        className: "CertificateOrderContact",
        modelProperties: {
            email: {
                serializedName: "email",
                xmlName: "email",
                type: {
                    name: "String",
                },
            },
            nameFirst: {
                serializedName: "nameFirst",
                xmlName: "nameFirst",
                type: {
                    name: "String",
                },
            },
            nameLast: {
                serializedName: "nameLast",
                xmlName: "nameLast",
                type: {
                    name: "String",
                },
            },
            phone: {
                serializedName: "phone",
                xmlName: "phone",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Resource = {
    serializedName: "Resource",
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            kind: {
                serializedName: "kind",
                xmlName: "kind",
                type: {
                    name: "String",
                },
            },
            location: {
                serializedName: "location",
                required: true,
                xmlName: "location",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            tags: {
                serializedName: "tags",
                xmlName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const DefaultErrorResponse = {
    serializedName: "DefaultErrorResponse",
    type: {
        name: "Composite",
        className: "DefaultErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "DefaultErrorResponseError",
                },
            },
        },
    },
};
const DefaultErrorResponseError = {
    serializedName: "DefaultErrorResponseError",
    type: {
        name: "Composite",
        className: "DefaultErrorResponseError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                readOnly: true,
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                readOnly: true,
                xmlName: "target",
                type: {
                    name: "String",
                },
            },
            details: {
                serializedName: "details",
                xmlName: "details",
                xmlElementName: "DefaultErrorResponseErrorDetailsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DefaultErrorResponseErrorDetailsItem",
                        },
                    },
                },
            },
            innererror: {
                serializedName: "innererror",
                readOnly: true,
                xmlName: "innererror",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DefaultErrorResponseErrorDetailsItem = {
    serializedName: "DefaultErrorResponseErrorDetailsItem",
    type: {
        name: "Composite",
        className: "DefaultErrorResponseErrorDetailsItem",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                readOnly: true,
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                readOnly: true,
                xmlName: "target",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ProxyOnlyResource = {
    serializedName: "ProxyOnlyResource",
    type: {
        name: "Composite",
        className: "ProxyOnlyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            kind: {
                serializedName: "kind",
                xmlName: "kind",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AppServiceCertificateCollection = {
    serializedName: "AppServiceCertificateCollection",
    type: {
        name: "Composite",
        className: "AppServiceCertificateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AppServiceCertificateResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServiceCertificateResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const NameIdentifier = {
    serializedName: "NameIdentifier",
    type: {
        name: "Composite",
        className: "NameIdentifier",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SiteSealRequest = {
    serializedName: "SiteSealRequest",
    type: {
        name: "Composite",
        className: "SiteSealRequest",
        modelProperties: {
            lightTheme: {
                serializedName: "lightTheme",
                xmlName: "lightTheme",
                type: {
                    name: "Boolean",
                },
            },
            locale: {
                serializedName: "locale",
                xmlName: "locale",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SiteSeal = {
    serializedName: "SiteSeal",
    type: {
        name: "Composite",
        className: "SiteSeal",
        modelProperties: {
            html: {
                serializedName: "html",
                required: true,
                xmlName: "html",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CertificateOrderAction = {
    serializedName: "CertificateOrderAction",
    type: {
        name: "Composite",
        className: "CertificateOrderAction",
        modelProperties: {
            actionType: {
                serializedName: "actionType",
                readOnly: true,
                xmlName: "actionType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "CertificateIssued",
                        "CertificateOrderCanceled",
                        "CertificateOrderCreated",
                        "CertificateRevoked",
                        "DomainValidationComplete",
                        "FraudDetected",
                        "OrgNameChange",
                        "OrgValidationComplete",
                        "SanDrop",
                        "FraudCleared",
                        "CertificateExpired",
                        "CertificateExpirationWarning",
                        "FraudDocumentationRequired",
                        "Unknown",
                    ],
                },
            },
            createdAt: {
                serializedName: "createdAt",
                readOnly: true,
                xmlName: "createdAt",
                type: {
                    name: "DateTime",
                },
            },
        },
    },
};
const CertificateEmail = {
    serializedName: "CertificateEmail",
    type: {
        name: "Composite",
        className: "CertificateEmail",
        modelProperties: {
            emailId: {
                serializedName: "emailId",
                xmlName: "emailId",
                type: {
                    name: "String",
                },
            },
            timeStamp: {
                serializedName: "timeStamp",
                xmlName: "timeStamp",
                type: {
                    name: "DateTime",
                },
            },
        },
    },
};
const DetectorResponseCollection = {
    serializedName: "DetectorResponseCollection",
    type: {
        name: "Composite",
        className: "DetectorResponseCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DetectorResponse",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorResponse",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DetectorInfo = {
    serializedName: "DetectorInfo",
    type: {
        name: "Composite",
        className: "DetectorInfo",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                readOnly: true,
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
            author: {
                serializedName: "author",
                readOnly: true,
                xmlName: "author",
                type: {
                    name: "String",
                },
            },
            category: {
                serializedName: "category",
                readOnly: true,
                xmlName: "category",
                type: {
                    name: "String",
                },
            },
            supportTopicList: {
                serializedName: "supportTopicList",
                readOnly: true,
                xmlName: "supportTopicList",
                xmlElementName: "SupportTopic",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SupportTopic",
                        },
                    },
                },
            },
            analysisType: {
                serializedName: "analysisType",
                readOnly: true,
                xmlName: "analysisType",
                xmlElementName: "DetectorInfoAnalysisTypeItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["Detector", "Analysis", "CategoryOverview"],
                },
            },
            score: {
                serializedName: "score",
                readOnly: true,
                xmlName: "score",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const SupportTopic = {
    serializedName: "SupportTopic",
    type: {
        name: "Composite",
        className: "SupportTopic",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            pesId: {
                serializedName: "pesId",
                readOnly: true,
                xmlName: "pesId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DiagnosticData = {
    serializedName: "DiagnosticData",
    type: {
        name: "Composite",
        className: "DiagnosticData",
        modelProperties: {
            table: {
                serializedName: "table",
                xmlName: "table",
                type: {
                    name: "Composite",
                    className: "DataTableResponseObject",
                },
            },
            renderingProperties: {
                serializedName: "renderingProperties",
                xmlName: "renderingProperties",
                type: {
                    name: "Composite",
                    className: "Rendering",
                },
            },
        },
    },
};
const DataTableResponseObject = {
    serializedName: "DataTableResponseObject",
    type: {
        name: "Composite",
        className: "DataTableResponseObject",
        modelProperties: {
            tableName: {
                serializedName: "tableName",
                xmlName: "tableName",
                type: {
                    name: "String",
                },
            },
            columns: {
                serializedName: "columns",
                xmlName: "columns",
                xmlElementName: "DataTableResponseColumn",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataTableResponseColumn",
                        },
                    },
                },
            },
            rows: {
                serializedName: "rows",
                xmlName: "rows",
                xmlElementName: "DataTableResponseObjectRowsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String",
                                },
                            },
                        },
                    },
                },
            },
        },
    },
};
const DataTableResponseColumn = {
    serializedName: "DataTableResponseColumn",
    type: {
        name: "Composite",
        className: "DataTableResponseColumn",
        modelProperties: {
            columnName: {
                serializedName: "columnName",
                xmlName: "columnName",
                type: {
                    name: "String",
                },
            },
            dataType: {
                serializedName: "dataType",
                xmlName: "dataType",
                type: {
                    name: "String",
                },
            },
            columnType: {
                serializedName: "columnType",
                xmlName: "columnType",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Rendering = {
    serializedName: "Rendering",
    type: {
        name: "Composite",
        className: "Rendering",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "NoGraph",
                        "Table",
                        "TimeSeries",
                        "TimeSeriesPerInstance",
                        "PieChart",
                        "DataSummary",
                        "Email",
                        "Insights",
                        "DynamicInsight",
                        "Markdown",
                        "Detector",
                        "DropDown",
                        "Card",
                        "Solution",
                        "Guage",
                        "Form",
                        "ChangeSets",
                        "ChangeAnalysisOnboarding",
                        "ChangesView",
                        "AppInsight",
                        "DependencyGraph",
                        "DownTime",
                        "SummaryCard",
                        "SearchComponent",
                        "AppInsightEnablement",
                    ],
                },
            },
            title: {
                serializedName: "title",
                xmlName: "title",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Status = {
    serializedName: "Status",
    type: {
        name: "Composite",
        className: "Status",
        modelProperties: {
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
            statusId: {
                serializedName: "statusId",
                xmlName: "statusId",
                type: {
                    name: "Enum",
                    allowedValues: ["Critical", "Warning", "Info", "Success", "None"],
                },
            },
        },
    },
};
const DataProviderMetadata = {
    serializedName: "DataProviderMetadata",
    type: {
        name: "Composite",
        className: "DataProviderMetadata",
        modelProperties: {
            providerName: {
                serializedName: "providerName",
                xmlName: "providerName",
                type: {
                    name: "String",
                },
            },
            propertyBag: {
                serializedName: "propertyBag",
                readOnly: true,
                xmlName: "propertyBag",
                xmlElementName: "KeyValuePairStringObject",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyValuePairStringObject",
                        },
                    },
                },
            },
        },
    },
};
const KeyValuePairStringObject = {
    serializedName: "KeyValuePairStringObject",
    type: {
        name: "Composite",
        className: "KeyValuePairStringObject",
        modelProperties: {
            key: {
                serializedName: "key",
                readOnly: true,
                xmlName: "key",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
        },
    },
};
const QueryUtterancesResults = {
    serializedName: "QueryUtterancesResults",
    type: {
        name: "Composite",
        className: "QueryUtterancesResults",
        modelProperties: {
            query: {
                serializedName: "query",
                xmlName: "query",
                type: {
                    name: "String",
                },
            },
            results: {
                serializedName: "results",
                xmlName: "results",
                xmlElementName: "QueryUtterancesResult",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryUtterancesResult",
                        },
                    },
                },
            },
        },
    },
};
const QueryUtterancesResult = {
    serializedName: "QueryUtterancesResult",
    type: {
        name: "Composite",
        className: "QueryUtterancesResult",
        modelProperties: {
            sampleUtterance: {
                serializedName: "sampleUtterance",
                xmlName: "sampleUtterance",
                type: {
                    name: "Composite",
                    className: "SampleUtterance",
                },
            },
            score: {
                serializedName: "score",
                xmlName: "score",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const SampleUtterance = {
    serializedName: "SampleUtterance",
    type: {
        name: "Composite",
        className: "SampleUtterance",
        modelProperties: {
            text: {
                serializedName: "text",
                xmlName: "text",
                type: {
                    name: "String",
                },
            },
            links: {
                serializedName: "links",
                xmlName: "links",
                xmlElementName: "SampleUtteranceLinksItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            qid: {
                serializedName: "qid",
                xmlName: "qid",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CsmOperationCollection = {
    serializedName: "CsmOperationCollection",
    type: {
        name: "Composite",
        className: "CsmOperationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CsmOperationDescription",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CsmOperationDescription",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CsmOperationDescription = {
    serializedName: "CsmOperationDescription",
    type: {
        name: "Composite",
        className: "CsmOperationDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            isDataAction: {
                serializedName: "isDataAction",
                xmlName: "isDataAction",
                type: {
                    name: "Boolean",
                },
            },
            display: {
                serializedName: "display",
                xmlName: "display",
                type: {
                    name: "Composite",
                    className: "CsmOperationDisplay",
                },
            },
            origin: {
                serializedName: "origin",
                xmlName: "origin",
                type: {
                    name: "String",
                },
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "CsmOperationDescriptionProperties",
                },
            },
        },
    },
};
const CsmOperationDisplay = {
    serializedName: "CsmOperationDisplay",
    type: {
        name: "Composite",
        className: "CsmOperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                xmlName: "provider",
                type: {
                    name: "String",
                },
            },
            resource: {
                serializedName: "resource",
                xmlName: "resource",
                type: {
                    name: "String",
                },
            },
            operation: {
                serializedName: "operation",
                xmlName: "operation",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CsmOperationDescriptionProperties = {
    serializedName: "CsmOperationDescriptionProperties",
    type: {
        name: "Composite",
        className: "CsmOperationDescriptionProperties",
        modelProperties: {
            serviceSpecification: {
                serializedName: "serviceSpecification",
                xmlName: "serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification",
                },
            },
        },
    },
};
const ServiceSpecification = {
    serializedName: "ServiceSpecification",
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                xmlName: "metricSpecifications",
                xmlElementName: "MetricSpecification",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification",
                        },
                    },
                },
            },
            logSpecifications: {
                serializedName: "logSpecifications",
                xmlName: "logSpecifications",
                xmlElementName: "LogSpecification",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification",
                        },
                    },
                },
            },
        },
    },
};
const MetricSpecification = {
    serializedName: "MetricSpecification",
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            displayName: {
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String",
                },
            },
            displayDescription: {
                serializedName: "displayDescription",
                xmlName: "displayDescription",
                type: {
                    name: "String",
                },
            },
            unit: {
                serializedName: "unit",
                xmlName: "unit",
                type: {
                    name: "String",
                },
            },
            aggregationType: {
                serializedName: "aggregationType",
                xmlName: "aggregationType",
                type: {
                    name: "String",
                },
            },
            supportsInstanceLevelAggregation: {
                serializedName: "supportsInstanceLevelAggregation",
                xmlName: "supportsInstanceLevelAggregation",
                type: {
                    name: "Boolean",
                },
            },
            enableRegionalMdmAccount: {
                serializedName: "enableRegionalMdmAccount",
                xmlName: "enableRegionalMdmAccount",
                type: {
                    name: "Boolean",
                },
            },
            sourceMdmAccount: {
                serializedName: "sourceMdmAccount",
                xmlName: "sourceMdmAccount",
                type: {
                    name: "String",
                },
            },
            sourceMdmNamespace: {
                serializedName: "sourceMdmNamespace",
                xmlName: "sourceMdmNamespace",
                type: {
                    name: "String",
                },
            },
            metricFilterPattern: {
                serializedName: "metricFilterPattern",
                xmlName: "metricFilterPattern",
                type: {
                    name: "String",
                },
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                xmlName: "fillGapWithZero",
                type: {
                    name: "Boolean",
                },
            },
            isInternal: {
                serializedName: "isInternal",
                xmlName: "isInternal",
                type: {
                    name: "Boolean",
                },
            },
            dimensions: {
                serializedName: "dimensions",
                xmlName: "dimensions",
                xmlElementName: "Dimension",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Dimension",
                        },
                    },
                },
            },
            category: {
                serializedName: "category",
                xmlName: "category",
                type: {
                    name: "String",
                },
            },
            availabilities: {
                serializedName: "availabilities",
                xmlName: "availabilities",
                xmlElementName: "MetricAvailability",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricAvailability",
                        },
                    },
                },
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                xmlName: "supportedTimeGrainTypes",
                xmlElementName: "MetricSpecificationSupportedTimeGrainTypesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                xmlName: "supportedAggregationTypes",
                xmlElementName: "MetricSpecificationSupportedAggregationTypesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const Dimension = {
    serializedName: "Dimension",
    type: {
        name: "Composite",
        className: "Dimension",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            displayName: {
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String",
                },
            },
            internalName: {
                serializedName: "internalName",
                xmlName: "internalName",
                type: {
                    name: "String",
                },
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                xmlName: "toBeExportedForShoebox",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const MetricAvailability = {
    serializedName: "MetricAvailability",
    type: {
        name: "Composite",
        className: "MetricAvailability",
        modelProperties: {
            timeGrain: {
                serializedName: "timeGrain",
                xmlName: "timeGrain",
                type: {
                    name: "String",
                },
            },
            blobDuration: {
                serializedName: "blobDuration",
                xmlName: "blobDuration",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const LogSpecification = {
    serializedName: "LogSpecification",
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            displayName: {
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String",
                },
            },
            blobDuration: {
                serializedName: "blobDuration",
                xmlName: "blobDuration",
                type: {
                    name: "String",
                },
            },
            logFilterPattern: {
                serializedName: "logFilterPattern",
                xmlName: "logFilterPattern",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DomainAvailabilityCheckResult = {
    serializedName: "DomainAvailabilityCheckResult",
    type: {
        name: "Composite",
        className: "DomainAvailabilityCheckResult",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            available: {
                serializedName: "available",
                xmlName: "available",
                type: {
                    name: "Boolean",
                },
            },
            domainType: {
                serializedName: "domainType",
                xmlName: "domainType",
                type: {
                    name: "Enum",
                    allowedValues: ["Regular", "SoftDeleted"],
                },
            },
        },
    },
};
const DomainCollection = {
    serializedName: "DomainCollection",
    type: {
        name: "Composite",
        className: "DomainCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Domain",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Domain",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Contact = {
    serializedName: "Contact",
    type: {
        name: "Composite",
        className: "Contact",
        modelProperties: {
            addressMailing: {
                serializedName: "addressMailing",
                xmlName: "addressMailing",
                type: {
                    name: "Composite",
                    className: "Address",
                },
            },
            email: {
                serializedName: "email",
                required: true,
                xmlName: "email",
                type: {
                    name: "String",
                },
            },
            fax: {
                serializedName: "fax",
                xmlName: "fax",
                type: {
                    name: "String",
                },
            },
            jobTitle: {
                serializedName: "jobTitle",
                xmlName: "jobTitle",
                type: {
                    name: "String",
                },
            },
            nameFirst: {
                serializedName: "nameFirst",
                required: true,
                xmlName: "nameFirst",
                type: {
                    name: "String",
                },
            },
            nameLast: {
                serializedName: "nameLast",
                required: true,
                xmlName: "nameLast",
                type: {
                    name: "String",
                },
            },
            nameMiddle: {
                serializedName: "nameMiddle",
                xmlName: "nameMiddle",
                type: {
                    name: "String",
                },
            },
            organization: {
                serializedName: "organization",
                xmlName: "organization",
                type: {
                    name: "String",
                },
            },
            phone: {
                serializedName: "phone",
                required: true,
                xmlName: "phone",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Address = {
    serializedName: "Address",
    type: {
        name: "Composite",
        className: "Address",
        modelProperties: {
            address1: {
                serializedName: "address1",
                required: true,
                xmlName: "address1",
                type: {
                    name: "String",
                },
            },
            address2: {
                serializedName: "address2",
                xmlName: "address2",
                type: {
                    name: "String",
                },
            },
            city: {
                serializedName: "city",
                required: true,
                xmlName: "city",
                type: {
                    name: "String",
                },
            },
            country: {
                serializedName: "country",
                required: true,
                xmlName: "country",
                type: {
                    name: "String",
                },
            },
            postalCode: {
                serializedName: "postalCode",
                required: true,
                xmlName: "postalCode",
                type: {
                    name: "String",
                },
            },
            state: {
                serializedName: "state",
                required: true,
                xmlName: "state",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const HostName = {
    serializedName: "HostName",
    type: {
        name: "Composite",
        className: "HostName",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            siteNames: {
                serializedName: "siteNames",
                xmlName: "siteNames",
                xmlElementName: "HostNameSiteNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            azureResourceName: {
                serializedName: "azureResourceName",
                xmlName: "azureResourceName",
                type: {
                    name: "String",
                },
            },
            azureResourceType: {
                serializedName: "azureResourceType",
                xmlName: "azureResourceType",
                type: {
                    name: "Enum",
                    allowedValues: ["Website", "TrafficManager"],
                },
            },
            customHostNameDnsRecordType: {
                serializedName: "customHostNameDnsRecordType",
                xmlName: "customHostNameDnsRecordType",
                type: {
                    name: "Enum",
                    allowedValues: ["CName", "A"],
                },
            },
            hostNameType: {
                serializedName: "hostNameType",
                xmlName: "hostNameType",
                type: {
                    name: "Enum",
                    allowedValues: ["Verified", "Managed"],
                },
            },
        },
    },
};
const DomainPurchaseConsent = {
    serializedName: "DomainPurchaseConsent",
    type: {
        name: "Composite",
        className: "DomainPurchaseConsent",
        modelProperties: {
            agreementKeys: {
                serializedName: "agreementKeys",
                xmlName: "agreementKeys",
                xmlElementName: "DomainPurchaseConsentAgreementKeysItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            agreedBy: {
                serializedName: "agreedBy",
                xmlName: "agreedBy",
                type: {
                    name: "String",
                },
            },
            agreedAt: {
                serializedName: "agreedAt",
                xmlName: "agreedAt",
                type: {
                    name: "DateTime",
                },
            },
        },
    },
};
const DomainControlCenterSsoRequest = {
    serializedName: "DomainControlCenterSsoRequest",
    type: {
        name: "Composite",
        className: "DomainControlCenterSsoRequest",
        modelProperties: {
            url: {
                serializedName: "url",
                readOnly: true,
                xmlName: "url",
                type: {
                    name: "String",
                },
            },
            postParameterKey: {
                serializedName: "postParameterKey",
                readOnly: true,
                xmlName: "postParameterKey",
                type: {
                    name: "String",
                },
            },
            postParameterValue: {
                serializedName: "postParameterValue",
                readOnly: true,
                xmlName: "postParameterValue",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DomainRecommendationSearchParameters = {
    serializedName: "DomainRecommendationSearchParameters",
    type: {
        name: "Composite",
        className: "DomainRecommendationSearchParameters",
        modelProperties: {
            keywords: {
                serializedName: "keywords",
                xmlName: "keywords",
                type: {
                    name: "String",
                },
            },
            maxDomainRecommendations: {
                serializedName: "maxDomainRecommendations",
                xmlName: "maxDomainRecommendations",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const NameIdentifierCollection = {
    serializedName: "NameIdentifierCollection",
    type: {
        name: "Composite",
        className: "NameIdentifierCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "NameIdentifier",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameIdentifier",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DomainOwnershipIdentifierCollection = {
    serializedName: "DomainOwnershipIdentifierCollection",
    type: {
        name: "Composite",
        className: "DomainOwnershipIdentifierCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DomainOwnershipIdentifier",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DomainOwnershipIdentifier",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TopLevelDomainCollection = {
    serializedName: "TopLevelDomainCollection",
    type: {
        name: "Composite",
        className: "TopLevelDomainCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "TopLevelDomain",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopLevelDomain",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TopLevelDomainAgreementOption = {
    serializedName: "TopLevelDomainAgreementOption",
    type: {
        name: "Composite",
        className: "TopLevelDomainAgreementOption",
        modelProperties: {
            includePrivacy: {
                serializedName: "includePrivacy",
                xmlName: "includePrivacy",
                type: {
                    name: "Boolean",
                },
            },
            forTransfer: {
                serializedName: "forTransfer",
                xmlName: "forTransfer",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const TldLegalAgreementCollection = {
    serializedName: "TldLegalAgreementCollection",
    type: {
        name: "Composite",
        className: "TldLegalAgreementCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "TldLegalAgreement",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TldLegalAgreement",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TldLegalAgreement = {
    serializedName: "TldLegalAgreement",
    type: {
        name: "Composite",
        className: "TldLegalAgreement",
        modelProperties: {
            agreementKey: {
                serializedName: "agreementKey",
                required: true,
                xmlName: "agreementKey",
                type: {
                    name: "String",
                },
            },
            title: {
                serializedName: "title",
                required: true,
                xmlName: "title",
                type: {
                    name: "String",
                },
            },
            content: {
                serializedName: "content",
                required: true,
                xmlName: "content",
                type: {
                    name: "String",
                },
            },
            url: {
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AppServiceEnvironmentCollection = {
    serializedName: "AppServiceEnvironmentCollection",
    type: {
        name: "Composite",
        className: "AppServiceEnvironmentCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AppServiceEnvironmentResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServiceEnvironmentResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AppServiceEnvironment = {
    serializedName: "AppServiceEnvironment",
    type: {
        name: "Composite",
        className: "AppServiceEnvironment",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                xmlName: "provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting",
                    ],
                },
            },
            status: {
                serializedName: "status",
                readOnly: true,
                xmlName: "status",
                type: {
                    name: "Enum",
                    allowedValues: ["Preparing", "Ready", "Scaling", "Deleting"],
                },
            },
            virtualNetwork: {
                serializedName: "virtualNetwork",
                xmlName: "virtualNetwork",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkProfile",
                },
            },
            internalLoadBalancingMode: {
                serializedName: "internalLoadBalancingMode",
                xmlName: "internalLoadBalancingMode",
                type: {
                    name: "String",
                },
            },
            multiSize: {
                serializedName: "multiSize",
                xmlName: "multiSize",
                type: {
                    name: "String",
                },
            },
            multiRoleCount: {
                serializedName: "multiRoleCount",
                readOnly: true,
                xmlName: "multiRoleCount",
                type: {
                    name: "Number",
                },
            },
            ipsslAddressCount: {
                serializedName: "ipsslAddressCount",
                xmlName: "ipsslAddressCount",
                type: {
                    name: "Number",
                },
            },
            dnsSuffix: {
                serializedName: "dnsSuffix",
                xmlName: "dnsSuffix",
                type: {
                    name: "String",
                },
            },
            maximumNumberOfMachines: {
                serializedName: "maximumNumberOfMachines",
                readOnly: true,
                xmlName: "maximumNumberOfMachines",
                type: {
                    name: "Number",
                },
            },
            frontEndScaleFactor: {
                serializedName: "frontEndScaleFactor",
                xmlName: "frontEndScaleFactor",
                type: {
                    name: "Number",
                },
            },
            suspended: {
                serializedName: "suspended",
                readOnly: true,
                xmlName: "suspended",
                type: {
                    name: "Boolean",
                },
            },
            clusterSettings: {
                serializedName: "clusterSettings",
                xmlName: "clusterSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair",
                        },
                    },
                },
            },
            userWhitelistedIpRanges: {
                serializedName: "userWhitelistedIpRanges",
                xmlName: "userWhitelistedIpRanges",
                xmlElementName: "AppServiceEnvironmentUserWhitelistedIpRangesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            hasLinuxWorkers: {
                serializedName: "hasLinuxWorkers",
                readOnly: true,
                xmlName: "hasLinuxWorkers",
                type: {
                    name: "Boolean",
                },
            },
            upgradePreference: {
                defaultValue: "None",
                serializedName: "upgradePreference",
                xmlName: "upgradePreference",
                type: {
                    name: "String",
                },
            },
            dedicatedHostCount: {
                serializedName: "dedicatedHostCount",
                xmlName: "dedicatedHostCount",
                type: {
                    name: "Number",
                },
            },
            zoneRedundant: {
                serializedName: "zoneRedundant",
                xmlName: "zoneRedundant",
                type: {
                    name: "Boolean",
                },
            },
            customDnsSuffixConfiguration: {
                serializedName: "customDnsSuffixConfiguration",
                xmlName: "customDnsSuffixConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomDnsSuffixConfiguration",
                },
            },
            networkingConfiguration: {
                serializedName: "networkingConfiguration",
                xmlName: "networkingConfiguration",
                type: {
                    name: "Composite",
                    className: "AseV3NetworkingConfiguration",
                },
            },
            upgradeAvailability: {
                serializedName: "upgradeAvailability",
                readOnly: true,
                xmlName: "upgradeAvailability",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const VirtualNetworkProfile = {
    serializedName: "VirtualNetworkProfile",
    type: {
        name: "Composite",
        className: "VirtualNetworkProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            subnet: {
                serializedName: "subnet",
                xmlName: "subnet",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const NameValuePair = {
    serializedName: "NameValuePair",
    type: {
        name: "Composite",
        className: "NameValuePair",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StampCapacityCollection = {
    serializedName: "StampCapacityCollection",
    type: {
        name: "Composite",
        className: "StampCapacityCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StampCapacity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StampCapacity",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StampCapacity = {
    serializedName: "StampCapacity",
    type: {
        name: "Composite",
        className: "StampCapacity",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            availableCapacity: {
                serializedName: "availableCapacity",
                xmlName: "availableCapacity",
                type: {
                    name: "Number",
                },
            },
            totalCapacity: {
                serializedName: "totalCapacity",
                xmlName: "totalCapacity",
                type: {
                    name: "Number",
                },
            },
            unit: {
                serializedName: "unit",
                xmlName: "unit",
                type: {
                    name: "String",
                },
            },
            computeMode: {
                serializedName: "computeMode",
                xmlName: "computeMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Shared", "Dedicated", "Dynamic"],
                },
            },
            workerSize: {
                serializedName: "workerSize",
                xmlName: "workerSize",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Small",
                        "Medium",
                        "Large",
                        "D1",
                        "D2",
                        "D3",
                        "SmallV3",
                        "MediumV3",
                        "LargeV3",
                        "NestedSmall",
                        "NestedSmallLinux",
                        "Default",
                    ],
                },
            },
            workerSizeId: {
                serializedName: "workerSizeId",
                xmlName: "workerSizeId",
                type: {
                    name: "Number",
                },
            },
            excludeFromCapacityAllocation: {
                serializedName: "excludeFromCapacityAllocation",
                xmlName: "excludeFromCapacityAllocation",
                type: {
                    name: "Boolean",
                },
            },
            isApplicableForAllComputeModes: {
                serializedName: "isApplicableForAllComputeModes",
                xmlName: "isApplicableForAllComputeModes",
                type: {
                    name: "Boolean",
                },
            },
            siteMode: {
                serializedName: "siteMode",
                xmlName: "siteMode",
                type: {
                    name: "String",
                },
            },
            isLinux: {
                serializedName: "isLinux",
                xmlName: "isLinux",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const VirtualIPMapping = {
    serializedName: "VirtualIPMapping",
    type: {
        name: "Composite",
        className: "VirtualIPMapping",
        modelProperties: {
            virtualIP: {
                serializedName: "virtualIP",
                xmlName: "virtualIP",
                type: {
                    name: "String",
                },
            },
            internalHttpPort: {
                serializedName: "internalHttpPort",
                xmlName: "internalHttpPort",
                type: {
                    name: "Number",
                },
            },
            internalHttpsPort: {
                serializedName: "internalHttpsPort",
                xmlName: "internalHttpsPort",
                type: {
                    name: "Number",
                },
            },
            inUse: {
                serializedName: "inUse",
                xmlName: "inUse",
                type: {
                    name: "Boolean",
                },
            },
            serviceName: {
                serializedName: "serviceName",
                xmlName: "serviceName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WebAppCollection = {
    serializedName: "WebAppCollection",
    type: {
        name: "Composite",
        className: "WebAppCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Site",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Site",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const HostNameSslState = {
    serializedName: "HostNameSslState",
    type: {
        name: "Composite",
        className: "HostNameSslState",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            sslState: {
                serializedName: "sslState",
                xmlName: "sslState",
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "SniEnabled", "IpBasedEnabled"],
                },
            },
            virtualIP: {
                serializedName: "virtualIP",
                xmlName: "virtualIP",
                type: {
                    name: "String",
                },
            },
            thumbprint: {
                serializedName: "thumbprint",
                xmlName: "thumbprint",
                type: {
                    name: "String",
                },
            },
            toUpdate: {
                serializedName: "toUpdate",
                xmlName: "toUpdate",
                type: {
                    name: "Boolean",
                },
            },
            hostType: {
                serializedName: "hostType",
                xmlName: "hostType",
                type: {
                    name: "Enum",
                    allowedValues: ["Standard", "Repository"],
                },
            },
        },
    },
};
const SiteDnsConfig = {
    serializedName: "SiteDnsConfig",
    type: {
        name: "Composite",
        className: "SiteDnsConfig",
        modelProperties: {
            dnsServers: {
                serializedName: "dnsServers",
                xmlName: "dnsServers",
                xmlElementName: "SiteDnsConfigDnsServersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            dnsAltServer: {
                serializedName: "dnsAltServer",
                xmlName: "dnsAltServer",
                type: {
                    name: "String",
                },
            },
            dnsRetryAttemptTimeout: {
                serializedName: "dnsRetryAttemptTimeout",
                xmlName: "dnsRetryAttemptTimeout",
                type: {
                    name: "Number",
                },
            },
            dnsRetryAttemptCount: {
                serializedName: "dnsRetryAttemptCount",
                xmlName: "dnsRetryAttemptCount",
                type: {
                    name: "Number",
                },
            },
            dnsMaxCacheTimeout: {
                serializedName: "dnsMaxCacheTimeout",
                xmlName: "dnsMaxCacheTimeout",
                type: {
                    name: "Number",
                },
            },
            dnsLegacySortOrder: {
                serializedName: "dnsLegacySortOrder",
                readOnly: true,
                xmlName: "dnsLegacySortOrder",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const SiteConfig = {
    serializedName: "SiteConfig",
    type: {
        name: "Composite",
        className: "SiteConfig",
        modelProperties: {
            numberOfWorkers: {
                serializedName: "numberOfWorkers",
                xmlName: "numberOfWorkers",
                type: {
                    name: "Number",
                },
            },
            defaultDocuments: {
                serializedName: "defaultDocuments",
                xmlName: "defaultDocuments",
                xmlElementName: "SiteConfigDefaultDocumentsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            netFrameworkVersion: {
                defaultValue: "v4.6",
                serializedName: "netFrameworkVersion",
                xmlName: "netFrameworkVersion",
                type: {
                    name: "String",
                },
            },
            phpVersion: {
                serializedName: "phpVersion",
                xmlName: "phpVersion",
                type: {
                    name: "String",
                },
            },
            pythonVersion: {
                serializedName: "pythonVersion",
                xmlName: "pythonVersion",
                type: {
                    name: "String",
                },
            },
            nodeVersion: {
                serializedName: "nodeVersion",
                xmlName: "nodeVersion",
                type: {
                    name: "String",
                },
            },
            powerShellVersion: {
                serializedName: "powerShellVersion",
                xmlName: "powerShellVersion",
                type: {
                    name: "String",
                },
            },
            linuxFxVersion: {
                serializedName: "linuxFxVersion",
                xmlName: "linuxFxVersion",
                type: {
                    name: "String",
                },
            },
            windowsFxVersion: {
                serializedName: "windowsFxVersion",
                xmlName: "windowsFxVersion",
                type: {
                    name: "String",
                },
            },
            requestTracingEnabled: {
                serializedName: "requestTracingEnabled",
                xmlName: "requestTracingEnabled",
                type: {
                    name: "Boolean",
                },
            },
            requestTracingExpirationTime: {
                serializedName: "requestTracingExpirationTime",
                xmlName: "requestTracingExpirationTime",
                type: {
                    name: "DateTime",
                },
            },
            remoteDebuggingEnabled: {
                serializedName: "remoteDebuggingEnabled",
                xmlName: "remoteDebuggingEnabled",
                type: {
                    name: "Boolean",
                },
            },
            remoteDebuggingVersion: {
                serializedName: "remoteDebuggingVersion",
                xmlName: "remoteDebuggingVersion",
                type: {
                    name: "String",
                },
            },
            httpLoggingEnabled: {
                serializedName: "httpLoggingEnabled",
                xmlName: "httpLoggingEnabled",
                type: {
                    name: "Boolean",
                },
            },
            acrUseManagedIdentityCreds: {
                serializedName: "acrUseManagedIdentityCreds",
                xmlName: "acrUseManagedIdentityCreds",
                type: {
                    name: "Boolean",
                },
            },
            acrUserManagedIdentityID: {
                serializedName: "acrUserManagedIdentityID",
                xmlName: "acrUserManagedIdentityID",
                type: {
                    name: "String",
                },
            },
            logsDirectorySizeLimit: {
                serializedName: "logsDirectorySizeLimit",
                xmlName: "logsDirectorySizeLimit",
                type: {
                    name: "Number",
                },
            },
            detailedErrorLoggingEnabled: {
                serializedName: "detailedErrorLoggingEnabled",
                xmlName: "detailedErrorLoggingEnabled",
                type: {
                    name: "Boolean",
                },
            },
            publishingUsername: {
                serializedName: "publishingUsername",
                xmlName: "publishingUsername",
                type: {
                    name: "String",
                },
            },
            appSettings: {
                serializedName: "appSettings",
                xmlName: "appSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair",
                        },
                    },
                },
            },
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair",
                        },
                    },
                },
            },
            connectionStrings: {
                serializedName: "connectionStrings",
                xmlName: "connectionStrings",
                xmlElementName: "ConnStringInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnStringInfo",
                        },
                    },
                },
            },
            machineKey: {
                serializedName: "machineKey",
                xmlName: "machineKey",
                type: {
                    name: "Composite",
                    className: "SiteMachineKey",
                },
            },
            handlerMappings: {
                serializedName: "handlerMappings",
                xmlName: "handlerMappings",
                xmlElementName: "HandlerMapping",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HandlerMapping",
                        },
                    },
                },
            },
            documentRoot: {
                serializedName: "documentRoot",
                xmlName: "documentRoot",
                type: {
                    name: "String",
                },
            },
            scmType: {
                serializedName: "scmType",
                xmlName: "scmType",
                type: {
                    name: "String",
                },
            },
            use32BitWorkerProcess: {
                serializedName: "use32BitWorkerProcess",
                xmlName: "use32BitWorkerProcess",
                type: {
                    name: "Boolean",
                },
            },
            webSocketsEnabled: {
                serializedName: "webSocketsEnabled",
                xmlName: "webSocketsEnabled",
                type: {
                    name: "Boolean",
                },
            },
            alwaysOn: {
                serializedName: "alwaysOn",
                xmlName: "alwaysOn",
                type: {
                    name: "Boolean",
                },
            },
            javaVersion: {
                serializedName: "javaVersion",
                xmlName: "javaVersion",
                type: {
                    name: "String",
                },
            },
            javaContainer: {
                serializedName: "javaContainer",
                xmlName: "javaContainer",
                type: {
                    name: "String",
                },
            },
            javaContainerVersion: {
                serializedName: "javaContainerVersion",
                xmlName: "javaContainerVersion",
                type: {
                    name: "String",
                },
            },
            appCommandLine: {
                serializedName: "appCommandLine",
                xmlName: "appCommandLine",
                type: {
                    name: "String",
                },
            },
            managedPipelineMode: {
                serializedName: "managedPipelineMode",
                xmlName: "managedPipelineMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Integrated", "Classic"],
                },
            },
            virtualApplications: {
                serializedName: "virtualApplications",
                xmlName: "virtualApplications",
                xmlElementName: "VirtualApplication",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualApplication",
                        },
                    },
                },
            },
            loadBalancing: {
                serializedName: "loadBalancing",
                xmlName: "loadBalancing",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "WeightedRoundRobin",
                        "LeastRequests",
                        "LeastResponseTime",
                        "WeightedTotalTraffic",
                        "RequestHash",
                        "PerSiteRoundRobin",
                    ],
                },
            },
            experiments: {
                serializedName: "experiments",
                xmlName: "experiments",
                type: {
                    name: "Composite",
                    className: "Experiments",
                },
            },
            limits: {
                serializedName: "limits",
                xmlName: "limits",
                type: {
                    name: "Composite",
                    className: "SiteLimits",
                },
            },
            autoHealEnabled: {
                serializedName: "autoHealEnabled",
                xmlName: "autoHealEnabled",
                type: {
                    name: "Boolean",
                },
            },
            autoHealRules: {
                serializedName: "autoHealRules",
                xmlName: "autoHealRules",
                type: {
                    name: "Composite",
                    className: "AutoHealRules",
                },
            },
            tracingOptions: {
                serializedName: "tracingOptions",
                xmlName: "tracingOptions",
                type: {
                    name: "String",
                },
            },
            vnetName: {
                serializedName: "vnetName",
                xmlName: "vnetName",
                type: {
                    name: "String",
                },
            },
            vnetRouteAllEnabled: {
                serializedName: "vnetRouteAllEnabled",
                xmlName: "vnetRouteAllEnabled",
                type: {
                    name: "Boolean",
                },
            },
            vnetPrivatePortsCount: {
                serializedName: "vnetPrivatePortsCount",
                xmlName: "vnetPrivatePortsCount",
                type: {
                    name: "Number",
                },
            },
            cors: {
                serializedName: "cors",
                xmlName: "cors",
                type: {
                    name: "Composite",
                    className: "CorsSettings",
                },
            },
            push: {
                serializedName: "push",
                xmlName: "push",
                type: {
                    name: "Composite",
                    className: "PushSettings",
                },
            },
            apiDefinition: {
                serializedName: "apiDefinition",
                xmlName: "apiDefinition",
                type: {
                    name: "Composite",
                    className: "ApiDefinitionInfo",
                },
            },
            apiManagementConfig: {
                serializedName: "apiManagementConfig",
                xmlName: "apiManagementConfig",
                type: {
                    name: "Composite",
                    className: "ApiManagementConfig",
                },
            },
            autoSwapSlotName: {
                serializedName: "autoSwapSlotName",
                xmlName: "autoSwapSlotName",
                type: {
                    name: "String",
                },
            },
            localMySqlEnabled: {
                defaultValue: false,
                serializedName: "localMySqlEnabled",
                xmlName: "localMySqlEnabled",
                type: {
                    name: "Boolean",
                },
            },
            managedServiceIdentityId: {
                serializedName: "managedServiceIdentityId",
                xmlName: "managedServiceIdentityId",
                type: {
                    name: "Number",
                },
            },
            xManagedServiceIdentityId: {
                serializedName: "xManagedServiceIdentityId",
                xmlName: "xManagedServiceIdentityId",
                type: {
                    name: "Number",
                },
            },
            keyVaultReferenceIdentity: {
                serializedName: "keyVaultReferenceIdentity",
                xmlName: "keyVaultReferenceIdentity",
                type: {
                    name: "String",
                },
            },
            ipSecurityRestrictions: {
                serializedName: "ipSecurityRestrictions",
                xmlName: "ipSecurityRestrictions",
                xmlElementName: "IpSecurityRestriction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpSecurityRestriction",
                        },
                    },
                },
            },
            ipSecurityRestrictionsDefaultAction: {
                serializedName: "ipSecurityRestrictionsDefaultAction",
                xmlName: "ipSecurityRestrictionsDefaultAction",
                type: {
                    name: "String",
                },
            },
            scmIpSecurityRestrictions: {
                serializedName: "scmIpSecurityRestrictions",
                xmlName: "scmIpSecurityRestrictions",
                xmlElementName: "IpSecurityRestriction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpSecurityRestriction",
                        },
                    },
                },
            },
            scmIpSecurityRestrictionsDefaultAction: {
                serializedName: "scmIpSecurityRestrictionsDefaultAction",
                xmlName: "scmIpSecurityRestrictionsDefaultAction",
                type: {
                    name: "String",
                },
            },
            scmIpSecurityRestrictionsUseMain: {
                serializedName: "scmIpSecurityRestrictionsUseMain",
                xmlName: "scmIpSecurityRestrictionsUseMain",
                type: {
                    name: "Boolean",
                },
            },
            http20Enabled: {
                defaultValue: true,
                serializedName: "http20Enabled",
                xmlName: "http20Enabled",
                type: {
                    name: "Boolean",
                },
            },
            minTlsVersion: {
                serializedName: "minTlsVersion",
                xmlName: "minTlsVersion",
                type: {
                    name: "String",
                },
            },
            minTlsCipherSuite: {
                serializedName: "minTlsCipherSuite",
                xmlName: "minTlsCipherSuite",
                type: {
                    name: "String",
                },
            },
            scmMinTlsVersion: {
                serializedName: "scmMinTlsVersion",
                xmlName: "scmMinTlsVersion",
                type: {
                    name: "String",
                },
            },
            ftpsState: {
                serializedName: "ftpsState",
                xmlName: "ftpsState",
                type: {
                    name: "String",
                },
            },
            preWarmedInstanceCount: {
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 0,
                },
                serializedName: "preWarmedInstanceCount",
                xmlName: "preWarmedInstanceCount",
                type: {
                    name: "Number",
                },
            },
            functionAppScaleLimit: {
                constraints: {
                    InclusiveMinimum: 0,
                },
                serializedName: "functionAppScaleLimit",
                xmlName: "functionAppScaleLimit",
                type: {
                    name: "Number",
                },
            },
            elasticWebAppScaleLimit: {
                constraints: {
                    InclusiveMinimum: 0,
                },
                serializedName: "elasticWebAppScaleLimit",
                xmlName: "elasticWebAppScaleLimit",
                type: {
                    name: "Number",
                },
            },
            healthCheckPath: {
                serializedName: "healthCheckPath",
                xmlName: "healthCheckPath",
                type: {
                    name: "String",
                },
            },
            functionsRuntimeScaleMonitoringEnabled: {
                serializedName: "functionsRuntimeScaleMonitoringEnabled",
                xmlName: "functionsRuntimeScaleMonitoringEnabled",
                type: {
                    name: "Boolean",
                },
            },
            websiteTimeZone: {
                serializedName: "websiteTimeZone",
                xmlName: "websiteTimeZone",
                type: {
                    name: "String",
                },
            },
            minimumElasticInstanceCount: {
                constraints: {
                    InclusiveMaximum: 20,
                    InclusiveMinimum: 0,
                },
                serializedName: "minimumElasticInstanceCount",
                xmlName: "minimumElasticInstanceCount",
                type: {
                    name: "Number",
                },
            },
            azureStorageAccounts: {
                serializedName: "azureStorageAccounts",
                xmlName: "azureStorageAccounts",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AzureStorageInfoValue" },
                    },
                },
            },
            publicNetworkAccess: {
                serializedName: "publicNetworkAccess",
                xmlName: "publicNetworkAccess",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ConnStringInfo = {
    serializedName: "ConnStringInfo",
    type: {
        name: "Composite",
        className: "ConnStringInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            connectionString: {
                serializedName: "connectionString",
                xmlName: "connectionString",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "MySql",
                        "SQLServer",
                        "SQLAzure",
                        "Custom",
                        "NotificationHub",
                        "ServiceBus",
                        "EventHub",
                        "ApiHub",
                        "DocDb",
                        "RedisCache",
                        "PostgreSQL",
                    ],
                },
            },
        },
    },
};
const SiteMachineKey = {
    serializedName: "SiteMachineKey",
    type: {
        name: "Composite",
        className: "SiteMachineKey",
        modelProperties: {
            validation: {
                serializedName: "validation",
                xmlName: "validation",
                type: {
                    name: "String",
                },
            },
            validationKey: {
                serializedName: "validationKey",
                xmlName: "validationKey",
                type: {
                    name: "String",
                },
            },
            decryption: {
                serializedName: "decryption",
                xmlName: "decryption",
                type: {
                    name: "String",
                },
            },
            decryptionKey: {
                serializedName: "decryptionKey",
                xmlName: "decryptionKey",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const HandlerMapping = {
    serializedName: "HandlerMapping",
    type: {
        name: "Composite",
        className: "HandlerMapping",
        modelProperties: {
            extension: {
                serializedName: "extension",
                xmlName: "extension",
                type: {
                    name: "String",
                },
            },
            scriptProcessor: {
                serializedName: "scriptProcessor",
                xmlName: "scriptProcessor",
                type: {
                    name: "String",
                },
            },
            arguments: {
                serializedName: "arguments",
                xmlName: "arguments",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const VirtualApplication = {
    serializedName: "VirtualApplication",
    type: {
        name: "Composite",
        className: "VirtualApplication",
        modelProperties: {
            virtualPath: {
                serializedName: "virtualPath",
                xmlName: "virtualPath",
                type: {
                    name: "String",
                },
            },
            physicalPath: {
                serializedName: "physicalPath",
                xmlName: "physicalPath",
                type: {
                    name: "String",
                },
            },
            preloadEnabled: {
                serializedName: "preloadEnabled",
                xmlName: "preloadEnabled",
                type: {
                    name: "Boolean",
                },
            },
            virtualDirectories: {
                serializedName: "virtualDirectories",
                xmlName: "virtualDirectories",
                xmlElementName: "VirtualDirectory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualDirectory",
                        },
                    },
                },
            },
        },
    },
};
const VirtualDirectory = {
    serializedName: "VirtualDirectory",
    type: {
        name: "Composite",
        className: "VirtualDirectory",
        modelProperties: {
            virtualPath: {
                serializedName: "virtualPath",
                xmlName: "virtualPath",
                type: {
                    name: "String",
                },
            },
            physicalPath: {
                serializedName: "physicalPath",
                xmlName: "physicalPath",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Experiments = {
    serializedName: "Experiments",
    type: {
        name: "Composite",
        className: "Experiments",
        modelProperties: {
            rampUpRules: {
                serializedName: "rampUpRules",
                xmlName: "rampUpRules",
                xmlElementName: "RampUpRule",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RampUpRule",
                        },
                    },
                },
            },
        },
    },
};
const RampUpRule = {
    serializedName: "RampUpRule",
    type: {
        name: "Composite",
        className: "RampUpRule",
        modelProperties: {
            actionHostName: {
                serializedName: "actionHostName",
                xmlName: "actionHostName",
                type: {
                    name: "String",
                },
            },
            reroutePercentage: {
                serializedName: "reroutePercentage",
                xmlName: "reroutePercentage",
                type: {
                    name: "Number",
                },
            },
            changeStep: {
                serializedName: "changeStep",
                xmlName: "changeStep",
                type: {
                    name: "Number",
                },
            },
            changeIntervalInMinutes: {
                serializedName: "changeIntervalInMinutes",
                xmlName: "changeIntervalInMinutes",
                type: {
                    name: "Number",
                },
            },
            minReroutePercentage: {
                serializedName: "minReroutePercentage",
                xmlName: "minReroutePercentage",
                type: {
                    name: "Number",
                },
            },
            maxReroutePercentage: {
                serializedName: "maxReroutePercentage",
                xmlName: "maxReroutePercentage",
                type: {
                    name: "Number",
                },
            },
            changeDecisionCallbackUrl: {
                serializedName: "changeDecisionCallbackUrl",
                xmlName: "changeDecisionCallbackUrl",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SiteLimits = {
    serializedName: "SiteLimits",
    type: {
        name: "Composite",
        className: "SiteLimits",
        modelProperties: {
            maxPercentageCpu: {
                serializedName: "maxPercentageCpu",
                xmlName: "maxPercentageCpu",
                type: {
                    name: "Number",
                },
            },
            maxMemoryInMb: {
                serializedName: "maxMemoryInMb",
                xmlName: "maxMemoryInMb",
                type: {
                    name: "Number",
                },
            },
            maxDiskSizeInMb: {
                serializedName: "maxDiskSizeInMb",
                xmlName: "maxDiskSizeInMb",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const AutoHealRules = {
    serializedName: "AutoHealRules",
    type: {
        name: "Composite",
        className: "AutoHealRules",
        modelProperties: {
            triggers: {
                serializedName: "triggers",
                xmlName: "triggers",
                type: {
                    name: "Composite",
                    className: "AutoHealTriggers",
                },
            },
            actions: {
                serializedName: "actions",
                xmlName: "actions",
                type: {
                    name: "Composite",
                    className: "AutoHealActions",
                },
            },
        },
    },
};
const AutoHealTriggers = {
    serializedName: "AutoHealTriggers",
    type: {
        name: "Composite",
        className: "AutoHealTriggers",
        modelProperties: {
            requests: {
                serializedName: "requests",
                xmlName: "requests",
                type: {
                    name: "Composite",
                    className: "RequestsBasedTrigger",
                },
            },
            privateBytesInKB: {
                serializedName: "privateBytesInKB",
                xmlName: "privateBytesInKB",
                type: {
                    name: "Number",
                },
            },
            statusCodes: {
                serializedName: "statusCodes",
                xmlName: "statusCodes",
                xmlElementName: "StatusCodesBasedTrigger",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StatusCodesBasedTrigger",
                        },
                    },
                },
            },
            slowRequests: {
                serializedName: "slowRequests",
                xmlName: "slowRequests",
                type: {
                    name: "Composite",
                    className: "SlowRequestsBasedTrigger",
                },
            },
            slowRequestsWithPath: {
                serializedName: "slowRequestsWithPath",
                xmlName: "slowRequestsWithPath",
                xmlElementName: "SlowRequestsBasedTrigger",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SlowRequestsBasedTrigger",
                        },
                    },
                },
            },
            statusCodesRange: {
                serializedName: "statusCodesRange",
                xmlName: "statusCodesRange",
                xmlElementName: "StatusCodesRangeBasedTrigger",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StatusCodesRangeBasedTrigger",
                        },
                    },
                },
            },
        },
    },
};
const RequestsBasedTrigger = {
    serializedName: "RequestsBasedTrigger",
    type: {
        name: "Composite",
        className: "RequestsBasedTrigger",
        modelProperties: {
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number",
                },
            },
            timeInterval: {
                serializedName: "timeInterval",
                xmlName: "timeInterval",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StatusCodesBasedTrigger = {
    serializedName: "StatusCodesBasedTrigger",
    type: {
        name: "Composite",
        className: "StatusCodesBasedTrigger",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "Number",
                },
            },
            subStatus: {
                serializedName: "subStatus",
                xmlName: "subStatus",
                type: {
                    name: "Number",
                },
            },
            win32Status: {
                serializedName: "win32Status",
                xmlName: "win32Status",
                type: {
                    name: "Number",
                },
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number",
                },
            },
            timeInterval: {
                serializedName: "timeInterval",
                xmlName: "timeInterval",
                type: {
                    name: "String",
                },
            },
            path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SlowRequestsBasedTrigger = {
    serializedName: "SlowRequestsBasedTrigger",
    type: {
        name: "Composite",
        className: "SlowRequestsBasedTrigger",
        modelProperties: {
            timeTaken: {
                serializedName: "timeTaken",
                xmlName: "timeTaken",
                type: {
                    name: "String",
                },
            },
            path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String",
                },
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number",
                },
            },
            timeInterval: {
                serializedName: "timeInterval",
                xmlName: "timeInterval",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StatusCodesRangeBasedTrigger = {
    serializedName: "StatusCodesRangeBasedTrigger",
    type: {
        name: "Composite",
        className: "StatusCodesRangeBasedTrigger",
        modelProperties: {
            statusCodes: {
                serializedName: "statusCodes",
                xmlName: "statusCodes",
                type: {
                    name: "String",
                },
            },
            path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String",
                },
            },
            count: {
                serializedName: "count",
                xmlName: "count",
                type: {
                    name: "Number",
                },
            },
            timeInterval: {
                serializedName: "timeInterval",
                xmlName: "timeInterval",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AutoHealActions = {
    serializedName: "AutoHealActions",
    type: {
        name: "Composite",
        className: "AutoHealActions",
        modelProperties: {
            actionType: {
                serializedName: "actionType",
                xmlName: "actionType",
                type: {
                    name: "Enum",
                    allowedValues: ["Recycle", "LogEvent", "CustomAction"],
                },
            },
            customAction: {
                serializedName: "customAction",
                xmlName: "customAction",
                type: {
                    name: "Composite",
                    className: "AutoHealCustomAction",
                },
            },
            minProcessExecutionTime: {
                serializedName: "minProcessExecutionTime",
                xmlName: "minProcessExecutionTime",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AutoHealCustomAction = {
    serializedName: "AutoHealCustomAction",
    type: {
        name: "Composite",
        className: "AutoHealCustomAction",
        modelProperties: {
            exe: {
                serializedName: "exe",
                xmlName: "exe",
                type: {
                    name: "String",
                },
            },
            parameters: {
                serializedName: "parameters",
                xmlName: "parameters",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CorsSettings = {
    serializedName: "CorsSettings",
    type: {
        name: "Composite",
        className: "CorsSettings",
        modelProperties: {
            allowedOrigins: {
                serializedName: "allowedOrigins",
                xmlName: "allowedOrigins",
                xmlElementName: "CorsSettingsAllowedOriginsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            supportCredentials: {
                serializedName: "supportCredentials",
                xmlName: "supportCredentials",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ApiDefinitionInfo = {
    serializedName: "ApiDefinitionInfo",
    type: {
        name: "Composite",
        className: "ApiDefinitionInfo",
        modelProperties: {
            url: {
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ApiManagementConfig = {
    serializedName: "ApiManagementConfig",
    type: {
        name: "Composite",
        className: "ApiManagementConfig",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const IpSecurityRestriction = {
    serializedName: "IpSecurityRestriction",
    type: {
        name: "Composite",
        className: "IpSecurityRestriction",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                xmlName: "ipAddress",
                type: {
                    name: "String",
                },
            },
            subnetMask: {
                serializedName: "subnetMask",
                xmlName: "subnetMask",
                type: {
                    name: "String",
                },
            },
            vnetSubnetResourceId: {
                serializedName: "vnetSubnetResourceId",
                xmlName: "vnetSubnetResourceId",
                type: {
                    name: "String",
                },
            },
            vnetTrafficTag: {
                serializedName: "vnetTrafficTag",
                xmlName: "vnetTrafficTag",
                type: {
                    name: "Number",
                },
            },
            subnetTrafficTag: {
                serializedName: "subnetTrafficTag",
                xmlName: "subnetTrafficTag",
                type: {
                    name: "Number",
                },
            },
            action: {
                serializedName: "action",
                xmlName: "action",
                type: {
                    name: "String",
                },
            },
            tag: {
                serializedName: "tag",
                xmlName: "tag",
                type: {
                    name: "String",
                },
            },
            priority: {
                serializedName: "priority",
                xmlName: "priority",
                type: {
                    name: "Number",
                },
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } },
                    },
                },
            },
        },
    },
};
const AzureStorageInfoValue = {
    serializedName: "AzureStorageInfoValue",
    type: {
        name: "Composite",
        className: "AzureStorageInfoValue",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureFiles", "AzureBlob"],
                },
            },
            accountName: {
                serializedName: "accountName",
                xmlName: "accountName",
                type: {
                    name: "String",
                },
            },
            shareName: {
                serializedName: "shareName",
                xmlName: "shareName",
                type: {
                    name: "String",
                },
            },
            accessKey: {
                serializedName: "accessKey",
                xmlName: "accessKey",
                type: {
                    name: "String",
                },
            },
            mountPath: {
                serializedName: "mountPath",
                xmlName: "mountPath",
                type: {
                    name: "String",
                },
            },
            state: {
                serializedName: "state",
                readOnly: true,
                xmlName: "state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Ok",
                        "InvalidCredentials",
                        "InvalidShare",
                        "NotValidated",
                    ],
                },
            },
            protocol: {
                serializedName: "protocol",
                xmlName: "protocol",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FunctionAppConfig = {
    serializedName: "FunctionAppConfig",
    type: {
        name: "Composite",
        className: "FunctionAppConfig",
        modelProperties: {
            deployment: {
                serializedName: "deployment",
                xmlName: "deployment",
                type: {
                    name: "Composite",
                    className: "FunctionsDeployment",
                },
            },
            runtime: {
                serializedName: "runtime",
                xmlName: "runtime",
                type: {
                    name: "Composite",
                    className: "FunctionsRuntime",
                },
            },
            scaleAndConcurrency: {
                serializedName: "scaleAndConcurrency",
                xmlName: "scaleAndConcurrency",
                type: {
                    name: "Composite",
                    className: "FunctionsScaleAndConcurrency",
                },
            },
        },
    },
};
const FunctionsDeployment = {
    serializedName: "FunctionsDeployment",
    type: {
        name: "Composite",
        className: "FunctionsDeployment",
        modelProperties: {
            storage: {
                serializedName: "storage",
                xmlName: "storage",
                type: {
                    name: "Composite",
                    className: "FunctionsDeploymentStorage",
                },
            },
        },
    },
};
const FunctionsDeploymentStorage = {
    serializedName: "FunctionsDeploymentStorage",
    type: {
        name: "Composite",
        className: "FunctionsDeploymentStorage",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            authentication: {
                serializedName: "authentication",
                xmlName: "authentication",
                type: {
                    name: "Composite",
                    className: "FunctionsDeploymentStorageAuthentication",
                },
            },
        },
    },
};
const FunctionsDeploymentStorageAuthentication = {
    serializedName: "FunctionsDeploymentStorageAuthentication",
    type: {
        name: "Composite",
        className: "FunctionsDeploymentStorageAuthentication",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            userAssignedIdentityResourceId: {
                serializedName: "userAssignedIdentityResourceId",
                xmlName: "userAssignedIdentityResourceId",
                type: {
                    name: "String",
                },
            },
            storageAccountConnectionStringName: {
                serializedName: "storageAccountConnectionStringName",
                xmlName: "storageAccountConnectionStringName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FunctionsRuntime = {
    serializedName: "FunctionsRuntime",
    type: {
        name: "Composite",
        className: "FunctionsRuntime",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            version: {
                serializedName: "version",
                nullable: true,
                xmlName: "version",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FunctionsScaleAndConcurrency = {
    serializedName: "FunctionsScaleAndConcurrency",
    type: {
        name: "Composite",
        className: "FunctionsScaleAndConcurrency",
        modelProperties: {
            alwaysReady: {
                serializedName: "alwaysReady",
                xmlName: "alwaysReady",
                xmlElementName: "FunctionsAlwaysReadyConfig",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionsAlwaysReadyConfig",
                        },
                    },
                },
            },
            maximumInstanceCount: {
                serializedName: "maximumInstanceCount",
                xmlName: "maximumInstanceCount",
                type: {
                    name: "Number",
                },
            },
            instanceMemoryMB: {
                serializedName: "instanceMemoryMB",
                xmlName: "instanceMemoryMB",
                type: {
                    name: "Number",
                },
            },
            triggers: {
                serializedName: "triggers",
                xmlName: "triggers",
                type: {
                    name: "Composite",
                    className: "FunctionsScaleAndConcurrencyTriggers",
                },
            },
        },
    },
};
const FunctionsAlwaysReadyConfig = {
    serializedName: "FunctionsAlwaysReadyConfig",
    type: {
        name: "Composite",
        className: "FunctionsAlwaysReadyConfig",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            instanceCount: {
                serializedName: "instanceCount",
                xmlName: "instanceCount",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const FunctionsScaleAndConcurrencyTriggers = {
    serializedName: "FunctionsScaleAndConcurrencyTriggers",
    type: {
        name: "Composite",
        className: "FunctionsScaleAndConcurrencyTriggers",
        modelProperties: {
            http: {
                serializedName: "http",
                xmlName: "http",
                type: {
                    name: "Composite",
                    className: "FunctionsScaleAndConcurrencyTriggersHttp",
                },
            },
        },
    },
};
const FunctionsScaleAndConcurrencyTriggersHttp = {
    serializedName: "FunctionsScaleAndConcurrencyTriggersHttp",
    type: {
        name: "Composite",
        className: "FunctionsScaleAndConcurrencyTriggersHttp",
        modelProperties: {
            perInstanceConcurrency: {
                serializedName: "perInstanceConcurrency",
                xmlName: "perInstanceConcurrency",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const DaprConfig = {
    serializedName: "DaprConfig",
    type: {
        name: "Composite",
        className: "DaprConfig",
        modelProperties: {
            enabled: {
                defaultValue: false,
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            appId: {
                serializedName: "appId",
                xmlName: "appId",
                type: {
                    name: "String",
                },
            },
            appPort: {
                serializedName: "appPort",
                xmlName: "appPort",
                type: {
                    name: "Number",
                },
            },
            httpReadBufferSize: {
                serializedName: "httpReadBufferSize",
                xmlName: "httpReadBufferSize",
                type: {
                    name: "Number",
                },
            },
            httpMaxRequestSize: {
                serializedName: "httpMaxRequestSize",
                xmlName: "httpMaxRequestSize",
                type: {
                    name: "Number",
                },
            },
            logLevel: {
                serializedName: "logLevel",
                xmlName: "logLevel",
                type: {
                    name: "String",
                },
            },
            enableApiLogging: {
                serializedName: "enableApiLogging",
                xmlName: "enableApiLogging",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ResourceConfig = {
    serializedName: "ResourceConfig",
    type: {
        name: "Composite",
        className: "ResourceConfig",
        modelProperties: {
            cpu: {
                serializedName: "cpu",
                xmlName: "cpu",
                type: {
                    name: "Number",
                },
            },
            memory: {
                serializedName: "memory",
                xmlName: "memory",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const HostingEnvironmentProfile = {
    serializedName: "HostingEnvironmentProfile",
    type: {
        name: "Composite",
        className: "HostingEnvironmentProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CloningInfo = {
    serializedName: "CloningInfo",
    type: {
        name: "Composite",
        className: "CloningInfo",
        modelProperties: {
            correlationId: {
                serializedName: "correlationId",
                xmlName: "correlationId",
                type: {
                    name: "Uuid",
                },
            },
            overwrite: {
                serializedName: "overwrite",
                xmlName: "overwrite",
                type: {
                    name: "Boolean",
                },
            },
            cloneCustomHostNames: {
                serializedName: "cloneCustomHostNames",
                xmlName: "cloneCustomHostNames",
                type: {
                    name: "Boolean",
                },
            },
            cloneSourceControl: {
                serializedName: "cloneSourceControl",
                xmlName: "cloneSourceControl",
                type: {
                    name: "Boolean",
                },
            },
            sourceWebAppId: {
                serializedName: "sourceWebAppId",
                required: true,
                xmlName: "sourceWebAppId",
                type: {
                    name: "String",
                },
            },
            sourceWebAppLocation: {
                serializedName: "sourceWebAppLocation",
                xmlName: "sourceWebAppLocation",
                type: {
                    name: "String",
                },
            },
            hostingEnvironment: {
                serializedName: "hostingEnvironment",
                xmlName: "hostingEnvironment",
                type: {
                    name: "String",
                },
            },
            appSettingsOverrides: {
                serializedName: "appSettingsOverrides",
                xmlName: "appSettingsOverrides",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            configureLoadBalancing: {
                serializedName: "configureLoadBalancing",
                xmlName: "configureLoadBalancing",
                type: {
                    name: "Boolean",
                },
            },
            trafficManagerProfileId: {
                serializedName: "trafficManagerProfileId",
                xmlName: "trafficManagerProfileId",
                type: {
                    name: "String",
                },
            },
            trafficManagerProfileName: {
                serializedName: "trafficManagerProfileName",
                xmlName: "trafficManagerProfileName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SlotSwapStatus = {
    serializedName: "SlotSwapStatus",
    type: {
        name: "Composite",
        className: "SlotSwapStatus",
        modelProperties: {
            timestampUtc: {
                serializedName: "timestampUtc",
                readOnly: true,
                xmlName: "timestampUtc",
                type: {
                    name: "DateTime",
                },
            },
            sourceSlotName: {
                serializedName: "sourceSlotName",
                readOnly: true,
                xmlName: "sourceSlotName",
                type: {
                    name: "String",
                },
            },
            destinationSlotName: {
                serializedName: "destinationSlotName",
                readOnly: true,
                xmlName: "destinationSlotName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedServiceIdentity = {
    serializedName: "ManagedServiceIdentity",
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None",
                    ],
                },
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                xmlName: "tenantId",
                type: {
                    name: "String",
                },
            },
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                xmlName: "principalId",
                type: {
                    name: "String",
                },
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                xmlName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" },
                    },
                },
            },
        },
    },
};
const UserAssignedIdentity = {
    serializedName: "UserAssignedIdentity",
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                xmlName: "principalId",
                type: {
                    name: "String",
                },
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                xmlName: "clientId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ExtendedLocation = {
    serializedName: "ExtendedLocation",
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const HostingEnvironmentDiagnostics = {
    serializedName: "HostingEnvironmentDiagnostics",
    type: {
        name: "Composite",
        className: "HostingEnvironmentDiagnostics",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            diagnosticsOutput: {
                serializedName: "diagnosticsOutput",
                xmlName: "diagnosticsOutput",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const InboundEnvironmentEndpointCollection = {
    serializedName: "InboundEnvironmentEndpointCollection",
    type: {
        name: "Composite",
        className: "InboundEnvironmentEndpointCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "InboundEnvironmentEndpoint",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundEnvironmentEndpoint",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const InboundEnvironmentEndpoint = {
    serializedName: "InboundEnvironmentEndpoint",
    type: {
        name: "Composite",
        className: "InboundEnvironmentEndpoint",
        modelProperties: {
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
            endpoints: {
                serializedName: "endpoints",
                xmlName: "endpoints",
                xmlElementName: "InboundEnvironmentEndpointEndpointsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            ports: {
                serializedName: "ports",
                xmlName: "ports",
                xmlElementName: "InboundEnvironmentEndpointPortsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const WorkerPoolCollection = {
    serializedName: "WorkerPoolCollection",
    type: {
        name: "Composite",
        className: "WorkerPoolCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "WorkerPoolResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkerPoolResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SkuDescription = {
    serializedName: "SkuDescription",
    type: {
        name: "Composite",
        className: "SkuDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            tier: {
                serializedName: "tier",
                xmlName: "tier",
                type: {
                    name: "String",
                },
            },
            size: {
                serializedName: "size",
                xmlName: "size",
                type: {
                    name: "String",
                },
            },
            family: {
                serializedName: "family",
                xmlName: "family",
                type: {
                    name: "String",
                },
            },
            capacity: {
                serializedName: "capacity",
                xmlName: "capacity",
                type: {
                    name: "Number",
                },
            },
            skuCapacity: {
                serializedName: "skuCapacity",
                xmlName: "skuCapacity",
                type: {
                    name: "Composite",
                    className: "SkuCapacity",
                },
            },
            locations: {
                serializedName: "locations",
                xmlName: "locations",
                xmlElementName: "SkuDescriptionLocationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            capabilities: {
                serializedName: "capabilities",
                xmlName: "capabilities",
                xmlElementName: "Capability",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Capability",
                        },
                    },
                },
            },
        },
    },
};
const SkuCapacity = {
    serializedName: "SkuCapacity",
    type: {
        name: "Composite",
        className: "SkuCapacity",
        modelProperties: {
            minimum: {
                serializedName: "minimum",
                xmlName: "minimum",
                type: {
                    name: "Number",
                },
            },
            maximum: {
                serializedName: "maximum",
                xmlName: "maximum",
                type: {
                    name: "Number",
                },
            },
            elasticMaximum: {
                serializedName: "elasticMaximum",
                xmlName: "elasticMaximum",
                type: {
                    name: "Number",
                },
            },
            default: {
                serializedName: "default",
                xmlName: "default",
                type: {
                    name: "Number",
                },
            },
            scaleType: {
                serializedName: "scaleType",
                xmlName: "scaleType",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Capability = {
    serializedName: "Capability",
    type: {
        name: "Composite",
        className: "Capability",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            reason: {
                serializedName: "reason",
                xmlName: "reason",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ResourceMetricDefinitionCollection = {
    serializedName: "ResourceMetricDefinitionCollection",
    type: {
        name: "Composite",
        className: "ResourceMetricDefinitionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ResourceMetricDefinition",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceMetricDefinition",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ResourceMetricAvailability = {
    serializedName: "ResourceMetricAvailability",
    type: {
        name: "Composite",
        className: "ResourceMetricAvailability",
        modelProperties: {
            timeGrain: {
                serializedName: "timeGrain",
                readOnly: true,
                xmlName: "timeGrain",
                type: {
                    name: "String",
                },
            },
            retention: {
                serializedName: "retention",
                readOnly: true,
                xmlName: "retention",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SkuInfoCollection = {
    serializedName: "SkuInfoCollection",
    type: {
        name: "Composite",
        className: "SkuInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SkuInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuInfo",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SkuInfo = {
    serializedName: "SkuInfo",
    type: {
        name: "Composite",
        className: "SkuInfo",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                xmlName: "resourceType",
                type: {
                    name: "String",
                },
            },
            sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription",
                },
            },
            capacity: {
                serializedName: "capacity",
                xmlName: "capacity",
                type: {
                    name: "Composite",
                    className: "SkuCapacity",
                },
            },
        },
    },
};
const UsageCollection = {
    serializedName: "UsageCollection",
    type: {
        name: "Composite",
        className: "UsageCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Usage",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Operation = {
    serializedName: "Operation",
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "InProgress",
                        "Failed",
                        "Succeeded",
                        "TimedOut",
                        "Created",
                    ],
                },
            },
            errors: {
                serializedName: "errors",
                xmlName: "errors",
                xmlElementName: "ErrorEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorEntity",
                        },
                    },
                },
            },
            createdTime: {
                serializedName: "createdTime",
                xmlName: "createdTime",
                type: {
                    name: "DateTime",
                },
            },
            modifiedTime: {
                serializedName: "modifiedTime",
                xmlName: "modifiedTime",
                type: {
                    name: "DateTime",
                },
            },
            expirationTime: {
                serializedName: "expirationTime",
                xmlName: "expirationTime",
                type: {
                    name: "DateTime",
                },
            },
            geoMasterOperationId: {
                serializedName: "geoMasterOperationId",
                xmlName: "geoMasterOperationId",
                type: {
                    name: "Uuid",
                },
            },
        },
    },
};
const ErrorEntity = {
    serializedName: "ErrorEntity",
    type: {
        name: "Composite",
        className: "ErrorEntity",
        modelProperties: {
            extendedCode: {
                serializedName: "extendedCode",
                xmlName: "extendedCode",
                type: {
                    name: "String",
                },
            },
            messageTemplate: {
                serializedName: "messageTemplate",
                xmlName: "messageTemplate",
                type: {
                    name: "String",
                },
            },
            parameters: {
                serializedName: "parameters",
                xmlName: "parameters",
                xmlElementName: "ErrorEntityParametersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            innerErrors: {
                serializedName: "innerErrors",
                xmlName: "innerErrors",
                xmlElementName: "ErrorEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorEntity",
                        },
                    },
                },
            },
            details: {
                serializedName: "details",
                xmlName: "details",
                xmlElementName: "ErrorEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorEntity",
                        },
                    },
                },
            },
            target: {
                serializedName: "target",
                xmlName: "target",
                type: {
                    name: "String",
                },
            },
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const OutboundEnvironmentEndpointCollection = {
    serializedName: "OutboundEnvironmentEndpointCollection",
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpointCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "OutboundEnvironmentEndpoint",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundEnvironmentEndpoint",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const OutboundEnvironmentEndpoint = {
    serializedName: "OutboundEnvironmentEndpoint",
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpoint",
        modelProperties: {
            category: {
                serializedName: "category",
                xmlName: "category",
                type: {
                    name: "String",
                },
            },
            endpoints: {
                serializedName: "endpoints",
                xmlName: "endpoints",
                xmlElementName: "EndpointDependency",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDependency",
                        },
                    },
                },
            },
        },
    },
};
const EndpointDependency = {
    serializedName: "EndpointDependency",
    type: {
        name: "Composite",
        className: "EndpointDependency",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                xmlName: "domainName",
                type: {
                    name: "String",
                },
            },
            endpointDetails: {
                serializedName: "endpointDetails",
                xmlName: "endpointDetails",
                xmlElementName: "EndpointDetail",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDetail",
                        },
                    },
                },
            },
        },
    },
};
const EndpointDetail = {
    serializedName: "EndpointDetail",
    type: {
        name: "Composite",
        className: "EndpointDetail",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                xmlName: "ipAddress",
                type: {
                    name: "String",
                },
            },
            port: {
                serializedName: "port",
                xmlName: "port",
                type: {
                    name: "Number",
                },
            },
            latency: {
                serializedName: "latency",
                xmlName: "latency",
                type: {
                    name: "Number",
                },
            },
            isAccessible: {
                serializedName: "isAccessible",
                xmlName: "isAccessible",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const PrivateEndpointConnectionCollection = {
    serializedName: "PrivateEndpointConnectionCollection",
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "RemotePrivateEndpointConnectionARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RemotePrivateEndpointConnectionARMResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ArmIdWrapper = {
    serializedName: "ArmIdWrapper",
    type: {
        name: "Composite",
        className: "ArmIdWrapper",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PrivateLinkConnectionState = {
    serializedName: "PrivateLinkConnectionState",
    type: {
        name: "Composite",
        className: "PrivateLinkConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                xmlName: "actionsRequired",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PrivateLinkResourcesWrapper = {
    serializedName: "PrivateLinkResourcesWrapper",
    type: {
        name: "Composite",
        className: "PrivateLinkResourcesWrapper",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "PrivateLinkResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource",
                        },
                    },
                },
            },
        },
    },
};
const PrivateLinkResource = {
    serializedName: "PrivateLinkResource",
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateLinkResourceProperties",
                },
            },
        },
    },
};
const PrivateLinkResourceProperties = {
    serializedName: "PrivateLinkResourceProperties",
    type: {
        name: "Composite",
        className: "PrivateLinkResourceProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                xmlName: "groupId",
                type: {
                    name: "String",
                },
            },
            requiredMembers: {
                serializedName: "requiredMembers",
                readOnly: true,
                xmlName: "requiredMembers",
                xmlElementName: "PrivateLinkResourcePropertiesRequiredMembersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            requiredZoneNames: {
                serializedName: "requiredZoneNames",
                readOnly: true,
                xmlName: "requiredZoneNames",
                xmlElementName: "PrivateLinkResourcePropertiesRequiredZoneNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const AppServicePlanCollection = {
    serializedName: "AppServicePlanCollection",
    type: {
        name: "Composite",
        className: "AppServicePlanCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AppServicePlan",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServicePlan",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const KubeEnvironmentProfile = {
    serializedName: "KubeEnvironmentProfile",
    type: {
        name: "Composite",
        className: "KubeEnvironmentProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CsmUsageQuotaCollection = {
    serializedName: "CsmUsageQuotaCollection",
    type: {
        name: "Composite",
        className: "CsmUsageQuotaCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CsmUsageQuota",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CsmUsageQuota",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CsmUsageQuota = {
    serializedName: "CsmUsageQuota",
    type: {
        name: "Composite",
        className: "CsmUsageQuota",
        modelProperties: {
            unit: {
                serializedName: "unit",
                xmlName: "unit",
                type: {
                    name: "String",
                },
            },
            nextResetTime: {
                serializedName: "nextResetTime",
                xmlName: "nextResetTime",
                type: {
                    name: "DateTime",
                },
            },
            currentValue: {
                serializedName: "currentValue",
                xmlName: "currentValue",
                type: {
                    name: "Number",
                },
            },
            limit: {
                serializedName: "limit",
                xmlName: "limit",
                type: {
                    name: "Number",
                },
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "Composite",
                    className: "LocalizableString",
                },
            },
        },
    },
};
const LocalizableString = {
    serializedName: "LocalizableString",
    type: {
        name: "Composite",
        className: "LocalizableString",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            localizedValue: {
                serializedName: "localizedValue",
                xmlName: "localizedValue",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ResourceCollection = {
    serializedName: "ResourceCollection",
    type: {
        name: "Composite",
        className: "ResourceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ResourceCollectionValueItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const HybridConnectionCollection = {
    serializedName: "HybridConnectionCollection",
    type: {
        name: "Composite",
        className: "HybridConnectionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "HybridConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HybridConnection",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const VnetInfo = {
    serializedName: "VnetInfo",
    type: {
        name: "Composite",
        className: "VnetInfo",
        modelProperties: {
            vnetResourceId: {
                serializedName: "vnetResourceId",
                xmlName: "vnetResourceId",
                type: {
                    name: "String",
                },
            },
            certThumbprint: {
                serializedName: "certThumbprint",
                readOnly: true,
                xmlName: "certThumbprint",
                type: {
                    name: "String",
                },
            },
            certBlob: {
                serializedName: "certBlob",
                xmlName: "certBlob",
                type: {
                    name: "String",
                },
            },
            routes: {
                serializedName: "routes",
                readOnly: true,
                xmlName: "routes",
                xmlElementName: "VnetRoute",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VnetRoute",
                        },
                    },
                },
            },
            resyncRequired: {
                serializedName: "resyncRequired",
                readOnly: true,
                xmlName: "resyncRequired",
                type: {
                    name: "Boolean",
                },
            },
            dnsServers: {
                serializedName: "dnsServers",
                xmlName: "dnsServers",
                type: {
                    name: "String",
                },
            },
            isSwift: {
                serializedName: "isSwift",
                xmlName: "isSwift",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const CertificateCollection = {
    serializedName: "CertificateCollection",
    type: {
        name: "Composite",
        className: "CertificateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Certificate",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Certificate",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ContainerAppCollection = {
    serializedName: "ContainerAppCollection",
    type: {
        name: "Composite",
        className: "ContainerAppCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ContainerApp",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerApp",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Configuration = {
    serializedName: "Configuration",
    type: {
        name: "Composite",
        className: "Configuration",
        modelProperties: {
            secrets: {
                serializedName: "secrets",
                xmlName: "secrets",
                xmlElementName: "Secret",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret",
                        },
                    },
                },
            },
            activeRevisionsMode: {
                serializedName: "activeRevisionsMode",
                xmlName: "activeRevisionsMode",
                type: {
                    name: "String",
                },
            },
            ingress: {
                serializedName: "ingress",
                xmlName: "ingress",
                type: {
                    name: "Composite",
                    className: "Ingress",
                },
            },
            registries: {
                serializedName: "registries",
                xmlName: "registries",
                xmlElementName: "RegistryCredentials",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegistryCredentials",
                        },
                    },
                },
            },
        },
    },
};
const Secret = {
    serializedName: "Secret",
    type: {
        name: "Composite",
        className: "Secret",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Ingress = {
    serializedName: "Ingress",
    type: {
        name: "Composite",
        className: "Ingress",
        modelProperties: {
            fqdn: {
                serializedName: "fqdn",
                readOnly: true,
                xmlName: "fqdn",
                type: {
                    name: "String",
                },
            },
            external: {
                defaultValue: false,
                serializedName: "external",
                xmlName: "external",
                type: {
                    name: "Boolean",
                },
            },
            targetPort: {
                serializedName: "targetPort",
                xmlName: "targetPort",
                type: {
                    name: "Number",
                },
            },
            transport: {
                serializedName: "transport",
                xmlName: "transport",
                type: {
                    name: "String",
                },
            },
            traffic: {
                serializedName: "traffic",
                xmlName: "traffic",
                xmlElementName: "TrafficWeight",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrafficWeight",
                        },
                    },
                },
            },
            allowInsecure: {
                serializedName: "allowInsecure",
                xmlName: "allowInsecure",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const TrafficWeight = {
    serializedName: "TrafficWeight",
    type: {
        name: "Composite",
        className: "TrafficWeight",
        modelProperties: {
            revisionName: {
                serializedName: "revisionName",
                xmlName: "revisionName",
                type: {
                    name: "String",
                },
            },
            weight: {
                serializedName: "weight",
                xmlName: "weight",
                type: {
                    name: "Number",
                },
            },
            latestRevision: {
                defaultValue: false,
                serializedName: "latestRevision",
                xmlName: "latestRevision",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const RegistryCredentials = {
    serializedName: "RegistryCredentials",
    type: {
        name: "Composite",
        className: "RegistryCredentials",
        modelProperties: {
            server: {
                serializedName: "server",
                xmlName: "server",
                type: {
                    name: "String",
                },
            },
            username: {
                serializedName: "username",
                xmlName: "username",
                type: {
                    name: "String",
                },
            },
            passwordSecretRef: {
                serializedName: "passwordSecretRef",
                xmlName: "passwordSecretRef",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Template = {
    serializedName: "Template",
    type: {
        name: "Composite",
        className: "Template",
        modelProperties: {
            revisionSuffix: {
                serializedName: "revisionSuffix",
                xmlName: "revisionSuffix",
                type: {
                    name: "String",
                },
            },
            containers: {
                serializedName: "containers",
                xmlName: "containers",
                xmlElementName: "Container",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Container",
                        },
                    },
                },
            },
            scale: {
                serializedName: "scale",
                xmlName: "scale",
                type: {
                    name: "Composite",
                    className: "Scale",
                },
            },
            dapr: {
                serializedName: "dapr",
                xmlName: "dapr",
                type: {
                    name: "Composite",
                    className: "Dapr",
                },
            },
        },
    },
};
const Container = {
    serializedName: "Container",
    type: {
        name: "Composite",
        className: "Container",
        modelProperties: {
            image: {
                serializedName: "image",
                xmlName: "image",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            command: {
                serializedName: "command",
                xmlName: "command",
                xmlElementName: "ContainerCommandItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            args: {
                serializedName: "args",
                xmlName: "args",
                xmlElementName: "ContainerArgsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            env: {
                serializedName: "env",
                xmlName: "env",
                xmlElementName: "EnvironmentVar",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentVar",
                        },
                    },
                },
            },
            resources: {
                serializedName: "resources",
                xmlName: "resources",
                type: {
                    name: "Composite",
                    className: "ContainerResources",
                },
            },
        },
    },
};
const EnvironmentVar = {
    serializedName: "EnvironmentVar",
    type: {
        name: "Composite",
        className: "EnvironmentVar",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            secretRef: {
                serializedName: "secretRef",
                xmlName: "secretRef",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ContainerResources = {
    serializedName: "ContainerResources",
    type: {
        name: "Composite",
        className: "ContainerResources",
        modelProperties: {
            cpu: {
                serializedName: "cpu",
                xmlName: "cpu",
                type: {
                    name: "Number",
                },
            },
            memory: {
                serializedName: "memory",
                xmlName: "memory",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Scale = {
    serializedName: "Scale",
    type: {
        name: "Composite",
        className: "Scale",
        modelProperties: {
            minReplicas: {
                serializedName: "minReplicas",
                xmlName: "minReplicas",
                type: {
                    name: "Number",
                },
            },
            maxReplicas: {
                serializedName: "maxReplicas",
                xmlName: "maxReplicas",
                type: {
                    name: "Number",
                },
            },
            rules: {
                serializedName: "rules",
                xmlName: "rules",
                xmlElementName: "ScaleRule",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRule",
                        },
                    },
                },
            },
        },
    },
};
const ScaleRule = {
    serializedName: "ScaleRule",
    type: {
        name: "Composite",
        className: "ScaleRule",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            azureQueue: {
                serializedName: "azureQueue",
                xmlName: "azureQueue",
                type: {
                    name: "Composite",
                    className: "QueueScaleRule",
                },
            },
            custom: {
                serializedName: "custom",
                xmlName: "custom",
                type: {
                    name: "Composite",
                    className: "CustomScaleRule",
                },
            },
            http: {
                serializedName: "http",
                xmlName: "http",
                type: {
                    name: "Composite",
                    className: "HttpScaleRule",
                },
            },
        },
    },
};
const QueueScaleRule = {
    serializedName: "QueueScaleRule",
    type: {
        name: "Composite",
        className: "QueueScaleRule",
        modelProperties: {
            queueName: {
                serializedName: "queueName",
                xmlName: "queueName",
                type: {
                    name: "String",
                },
            },
            queueLength: {
                serializedName: "queueLength",
                xmlName: "queueLength",
                type: {
                    name: "Number",
                },
            },
            auth: {
                serializedName: "auth",
                xmlName: "auth",
                xmlElementName: "ScaleRuleAuth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth",
                        },
                    },
                },
            },
        },
    },
};
const ScaleRuleAuth = {
    serializedName: "ScaleRuleAuth",
    type: {
        name: "Composite",
        className: "ScaleRuleAuth",
        modelProperties: {
            secretRef: {
                serializedName: "secretRef",
                xmlName: "secretRef",
                type: {
                    name: "String",
                },
            },
            triggerParameter: {
                serializedName: "triggerParameter",
                xmlName: "triggerParameter",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CustomScaleRule = {
    serializedName: "CustomScaleRule",
    type: {
        name: "Composite",
        className: "CustomScaleRule",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            auth: {
                serializedName: "auth",
                xmlName: "auth",
                xmlElementName: "ScaleRuleAuth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth",
                        },
                    },
                },
            },
        },
    },
};
const HttpScaleRule = {
    serializedName: "HttpScaleRule",
    type: {
        name: "Composite",
        className: "HttpScaleRule",
        modelProperties: {
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            auth: {
                serializedName: "auth",
                xmlName: "auth",
                xmlElementName: "ScaleRuleAuth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth",
                        },
                    },
                },
            },
        },
    },
};
const Dapr = {
    serializedName: "Dapr",
    type: {
        name: "Composite",
        className: "Dapr",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            appId: {
                serializedName: "appId",
                xmlName: "appId",
                type: {
                    name: "String",
                },
            },
            appPort: {
                serializedName: "appPort",
                xmlName: "appPort",
                type: {
                    name: "Number",
                },
            },
            components: {
                serializedName: "components",
                xmlName: "components",
                xmlElementName: "DaprComponent",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DaprComponent",
                        },
                    },
                },
            },
        },
    },
};
const DaprComponent = {
    serializedName: "DaprComponent",
    type: {
        name: "Composite",
        className: "DaprComponent",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            version: {
                serializedName: "version",
                xmlName: "version",
                type: {
                    name: "String",
                },
            },
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                xmlElementName: "DaprMetadata",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DaprMetadata",
                        },
                    },
                },
            },
        },
    },
};
const DaprMetadata = {
    serializedName: "DaprMetadata",
    type: {
        name: "Composite",
        className: "DaprMetadata",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            secretRef: {
                serializedName: "secretRef",
                xmlName: "secretRef",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SecretsCollection = {
    serializedName: "SecretsCollection",
    type: {
        name: "Composite",
        className: "SecretsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ContainerAppSecret",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerAppSecret",
                        },
                    },
                },
            },
        },
    },
};
const ContainerAppSecret = {
    serializedName: "ContainerAppSecret",
    type: {
        name: "Composite",
        className: "ContainerAppSecret",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RevisionCollection = {
    serializedName: "RevisionCollection",
    type: {
        name: "Composite",
        className: "RevisionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Revision",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Revision",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DeletedWebAppCollection = {
    serializedName: "DeletedWebAppCollection",
    type: {
        name: "Composite",
        className: "DeletedWebAppCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DeletedSite",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedSite",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DiagnosticCategoryCollection = {
    serializedName: "DiagnosticCategoryCollection",
    type: {
        name: "Composite",
        className: "DiagnosticCategoryCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DiagnosticCategory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticCategory",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DiagnosticAnalysisCollection = {
    serializedName: "DiagnosticAnalysisCollection",
    type: {
        name: "Composite",
        className: "DiagnosticAnalysisCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AnalysisDefinition",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnalysisDefinition",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AbnormalTimePeriod = {
    serializedName: "AbnormalTimePeriod",
    type: {
        name: "Composite",
        className: "AbnormalTimePeriod",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime",
                },
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime",
                },
            },
            events: {
                serializedName: "events",
                xmlName: "events",
                xmlElementName: "DetectorAbnormalTimePeriod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorAbnormalTimePeriod",
                        },
                    },
                },
            },
            solutions: {
                serializedName: "solutions",
                xmlName: "solutions",
                xmlElementName: "Solution",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Solution",
                        },
                    },
                },
            },
        },
    },
};
const DetectorAbnormalTimePeriod = {
    serializedName: "DetectorAbnormalTimePeriod",
    type: {
        name: "Composite",
        className: "DetectorAbnormalTimePeriod",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime",
                },
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime",
                },
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
            source: {
                serializedName: "source",
                xmlName: "source",
                type: {
                    name: "String",
                },
            },
            priority: {
                serializedName: "priority",
                xmlName: "priority",
                type: {
                    name: "Number",
                },
            },
            metaData: {
                serializedName: "metaData",
                xmlName: "metaData",
                xmlElementName: "DetectorAbnormalTimePeriodMetaDataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair",
                                },
                            },
                        },
                    },
                },
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "ServiceIncident",
                        "AppDeployment",
                        "AppCrash",
                        "RuntimeIssueDetected",
                        "AseDeployment",
                        "UserIssue",
                        "PlatformIssue",
                        "Other",
                    ],
                },
            },
            solutions: {
                serializedName: "solutions",
                xmlName: "solutions",
                xmlElementName: "Solution",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Solution",
                        },
                    },
                },
            },
        },
    },
};
const Solution = {
    serializedName: "Solution",
    type: {
        name: "Composite",
        className: "Solution",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "Number",
                },
            },
            displayName: {
                serializedName: "displayName",
                xmlName: "displayName",
                type: {
                    name: "String",
                },
            },
            order: {
                serializedName: "order",
                xmlName: "order",
                type: {
                    name: "Number",
                },
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "QuickSolution",
                        "DeepInvestigation",
                        "BestPractices",
                    ],
                },
            },
            data: {
                serializedName: "data",
                xmlName: "data",
                xmlElementName: "SolutionDataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair",
                                },
                            },
                        },
                    },
                },
            },
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                xmlElementName: "SolutionMetadataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair",
                                },
                            },
                        },
                    },
                },
            },
        },
    },
};
const AnalysisData = {
    serializedName: "AnalysisData",
    type: {
        name: "Composite",
        className: "AnalysisData",
        modelProperties: {
            source: {
                serializedName: "source",
                xmlName: "source",
                type: {
                    name: "String",
                },
            },
            detectorDefinition: {
                serializedName: "detectorDefinition",
                xmlName: "detectorDefinition",
                type: {
                    name: "Composite",
                    className: "DetectorDefinition",
                },
            },
            metrics: {
                serializedName: "metrics",
                xmlName: "metrics",
                xmlElementName: "DiagnosticMetricSet",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticMetricSet",
                        },
                    },
                },
            },
            data: {
                serializedName: "data",
                xmlName: "data",
                xmlElementName: "AnalysisDataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair",
                                },
                            },
                        },
                    },
                },
            },
            detectorMetaData: {
                serializedName: "detectorMetaData",
                xmlName: "detectorMetaData",
                type: {
                    name: "Composite",
                    className: "ResponseMetaData",
                },
            },
        },
    },
};
const DetectorDefinition = {
    serializedName: "DetectorDefinition",
    type: {
        name: "Composite",
        className: "DetectorDefinition",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                xmlName: "displayName",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                readOnly: true,
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
            rank: {
                serializedName: "rank",
                readOnly: true,
                xmlName: "rank",
                type: {
                    name: "Number",
                },
            },
            isEnabled: {
                serializedName: "isEnabled",
                readOnly: true,
                xmlName: "isEnabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const DiagnosticMetricSet = {
    serializedName: "DiagnosticMetricSet",
    type: {
        name: "Composite",
        className: "DiagnosticMetricSet",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            unit: {
                serializedName: "unit",
                xmlName: "unit",
                type: {
                    name: "String",
                },
            },
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime",
                },
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime",
                },
            },
            timeGrain: {
                serializedName: "timeGrain",
                xmlName: "timeGrain",
                type: {
                    name: "String",
                },
            },
            values: {
                serializedName: "values",
                xmlName: "values",
                xmlElementName: "DiagnosticMetricSample",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticMetricSample",
                        },
                    },
                },
            },
        },
    },
};
const DiagnosticMetricSample = {
    serializedName: "DiagnosticMetricSample",
    type: {
        name: "Composite",
        className: "DiagnosticMetricSample",
        modelProperties: {
            timestamp: {
                serializedName: "timestamp",
                xmlName: "timestamp",
                type: {
                    name: "DateTime",
                },
            },
            roleInstance: {
                serializedName: "roleInstance",
                xmlName: "roleInstance",
                type: {
                    name: "String",
                },
            },
            total: {
                serializedName: "total",
                xmlName: "total",
                type: {
                    name: "Number",
                },
            },
            maximum: {
                serializedName: "maximum",
                xmlName: "maximum",
                type: {
                    name: "Number",
                },
            },
            minimum: {
                serializedName: "minimum",
                xmlName: "minimum",
                type: {
                    name: "Number",
                },
            },
            isAggregated: {
                serializedName: "isAggregated",
                xmlName: "isAggregated",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ResponseMetaData = {
    serializedName: "ResponseMetaData",
    type: {
        name: "Composite",
        className: "ResponseMetaData",
        modelProperties: {
            dataSource: {
                serializedName: "dataSource",
                xmlName: "dataSource",
                type: {
                    name: "Composite",
                    className: "DataSource",
                },
            },
        },
    },
};
const DataSource = {
    serializedName: "DataSource",
    type: {
        name: "Composite",
        className: "DataSource",
        modelProperties: {
            instructions: {
                serializedName: "instructions",
                xmlName: "instructions",
                xmlElementName: "DataSourceInstructionsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            dataSourceUri: {
                serializedName: "dataSourceUri",
                xmlName: "dataSourceUri",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair",
                        },
                    },
                },
            },
        },
    },
};
const DiagnosticDetectorCollection = {
    serializedName: "DiagnosticDetectorCollection",
    type: {
        name: "Composite",
        className: "DiagnosticDetectorCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DetectorDefinitionResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorDefinitionResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const KubeEnvironmentCollection = {
    serializedName: "KubeEnvironmentCollection",
    type: {
        name: "Composite",
        className: "KubeEnvironmentCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "KubeEnvironment",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KubeEnvironment",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ArcConfiguration = {
    serializedName: "ArcConfiguration",
    type: {
        name: "Composite",
        className: "ArcConfiguration",
        modelProperties: {
            artifactsStorageType: {
                serializedName: "artifactsStorageType",
                xmlName: "artifactsStorageType",
                type: {
                    name: "Enum",
                    allowedValues: ["LocalNode", "NetworkFileSystem"],
                },
            },
            artifactStorageClassName: {
                serializedName: "artifactStorageClassName",
                xmlName: "artifactStorageClassName",
                type: {
                    name: "String",
                },
            },
            artifactStorageMountPath: {
                serializedName: "artifactStorageMountPath",
                xmlName: "artifactStorageMountPath",
                type: {
                    name: "String",
                },
            },
            artifactStorageNodeName: {
                serializedName: "artifactStorageNodeName",
                xmlName: "artifactStorageNodeName",
                type: {
                    name: "String",
                },
            },
            artifactStorageAccessMode: {
                serializedName: "artifactStorageAccessMode",
                xmlName: "artifactStorageAccessMode",
                type: {
                    name: "String",
                },
            },
            frontEndServiceConfiguration: {
                serializedName: "frontEndServiceConfiguration",
                xmlName: "frontEndServiceConfiguration",
                type: {
                    name: "Composite",
                    className: "FrontEndConfiguration",
                },
            },
            kubeConfig: {
                serializedName: "kubeConfig",
                xmlName: "kubeConfig",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FrontEndConfiguration = {
    serializedName: "FrontEndConfiguration",
    type: {
        name: "Composite",
        className: "FrontEndConfiguration",
        modelProperties: {
            kind: {
                serializedName: "kind",
                xmlName: "kind",
                type: {
                    name: "Enum",
                    allowedValues: ["NodePort", "LoadBalancer"],
                },
            },
        },
    },
};
const AppLogsConfiguration = {
    serializedName: "AppLogsConfiguration",
    type: {
        name: "Composite",
        className: "AppLogsConfiguration",
        modelProperties: {
            destination: {
                serializedName: "destination",
                xmlName: "destination",
                type: {
                    name: "String",
                },
            },
            logAnalyticsConfiguration: {
                serializedName: "logAnalyticsConfiguration",
                xmlName: "logAnalyticsConfiguration",
                type: {
                    name: "Composite",
                    className: "LogAnalyticsConfiguration",
                },
            },
        },
    },
};
const LogAnalyticsConfiguration = {
    serializedName: "LogAnalyticsConfiguration",
    type: {
        name: "Composite",
        className: "LogAnalyticsConfiguration",
        modelProperties: {
            customerId: {
                serializedName: "customerId",
                xmlName: "customerId",
                type: {
                    name: "String",
                },
            },
            sharedKey: {
                serializedName: "sharedKey",
                xmlName: "sharedKey",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ContainerAppsConfiguration = {
    serializedName: "ContainerAppsConfiguration",
    type: {
        name: "Composite",
        className: "ContainerAppsConfiguration",
        modelProperties: {
            daprAIInstrumentationKey: {
                serializedName: "daprAIInstrumentationKey",
                xmlName: "daprAIInstrumentationKey",
                type: {
                    name: "String",
                },
            },
            platformReservedCidr: {
                serializedName: "platformReservedCidr",
                xmlName: "platformReservedCidr",
                type: {
                    name: "String",
                },
            },
            platformReservedDnsIP: {
                serializedName: "platformReservedDnsIP",
                xmlName: "platformReservedDnsIP",
                type: {
                    name: "String",
                },
            },
            controlPlaneSubnetResourceId: {
                serializedName: "controlPlaneSubnetResourceId",
                xmlName: "controlPlaneSubnetResourceId",
                type: {
                    name: "String",
                },
            },
            appSubnetResourceId: {
                serializedName: "appSubnetResourceId",
                xmlName: "appSubnetResourceId",
                type: {
                    name: "String",
                },
            },
            dockerBridgeCidr: {
                serializedName: "dockerBridgeCidr",
                xmlName: "dockerBridgeCidr",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ApplicationStackCollection = {
    serializedName: "ApplicationStackCollection",
    type: {
        name: "Composite",
        className: "ApplicationStackCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ApplicationStackResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStackResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ApplicationStack = {
    serializedName: "ApplicationStack",
    type: {
        name: "Composite",
        className: "ApplicationStack",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            display: {
                serializedName: "display",
                xmlName: "display",
                type: {
                    name: "String",
                },
            },
            dependency: {
                serializedName: "dependency",
                xmlName: "dependency",
                type: {
                    name: "String",
                },
            },
            majorVersions: {
                serializedName: "majorVersions",
                xmlName: "majorVersions",
                xmlElementName: "StackMajorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StackMajorVersion",
                        },
                    },
                },
            },
            frameworks: {
                serializedName: "frameworks",
                xmlName: "frameworks",
                xmlElementName: "ApplicationStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStack",
                        },
                    },
                },
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                xmlName: "isDeprecated",
                xmlElementName: "ApplicationStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStack",
                        },
                    },
                },
            },
        },
    },
};
const StackMajorVersion = {
    serializedName: "StackMajorVersion",
    type: {
        name: "Composite",
        className: "StackMajorVersion",
        modelProperties: {
            displayVersion: {
                serializedName: "displayVersion",
                xmlName: "displayVersion",
                type: {
                    name: "String",
                },
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                xmlName: "runtimeVersion",
                type: {
                    name: "String",
                },
            },
            isDefault: {
                serializedName: "isDefault",
                xmlName: "isDefault",
                type: {
                    name: "Boolean",
                },
            },
            minorVersions: {
                serializedName: "minorVersions",
                xmlName: "minorVersions",
                xmlElementName: "StackMinorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StackMinorVersion",
                        },
                    },
                },
            },
            applicationInsights: {
                serializedName: "applicationInsights",
                xmlName: "applicationInsights",
                type: {
                    name: "Boolean",
                },
            },
            isPreview: {
                serializedName: "isPreview",
                xmlName: "isPreview",
                type: {
                    name: "Boolean",
                },
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean",
                },
            },
            isHidden: {
                serializedName: "isHidden",
                xmlName: "isHidden",
                type: {
                    name: "Boolean",
                },
            },
            appSettingsDictionary: {
                serializedName: "appSettingsDictionary",
                xmlName: "appSettingsDictionary",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } },
                    },
                },
            },
            siteConfigPropertiesDictionary: {
                serializedName: "siteConfigPropertiesDictionary",
                xmlName: "siteConfigPropertiesDictionary",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } },
                    },
                },
            },
        },
    },
};
const StackMinorVersion = {
    serializedName: "StackMinorVersion",
    type: {
        name: "Composite",
        className: "StackMinorVersion",
        modelProperties: {
            displayVersion: {
                serializedName: "displayVersion",
                xmlName: "displayVersion",
                type: {
                    name: "String",
                },
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                xmlName: "runtimeVersion",
                type: {
                    name: "String",
                },
            },
            isDefault: {
                serializedName: "isDefault",
                xmlName: "isDefault",
                type: {
                    name: "Boolean",
                },
            },
            isRemoteDebuggingEnabled: {
                serializedName: "isRemoteDebuggingEnabled",
                xmlName: "isRemoteDebuggingEnabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const FunctionAppStackCollection = {
    serializedName: "FunctionAppStackCollection",
    type: {
        name: "Composite",
        className: "FunctionAppStackCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "FunctionAppStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionAppStack",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FunctionAppMajorVersion = {
    serializedName: "FunctionAppMajorVersion",
    type: {
        name: "Composite",
        className: "FunctionAppMajorVersion",
        modelProperties: {
            displayText: {
                serializedName: "displayText",
                readOnly: true,
                xmlName: "displayText",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            minorVersions: {
                serializedName: "minorVersions",
                readOnly: true,
                xmlName: "minorVersions",
                xmlElementName: "FunctionAppMinorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionAppMinorVersion",
                        },
                    },
                },
            },
        },
    },
};
const FunctionAppMinorVersion = {
    serializedName: "FunctionAppMinorVersion",
    type: {
        name: "Composite",
        className: "FunctionAppMinorVersion",
        modelProperties: {
            displayText: {
                serializedName: "displayText",
                readOnly: true,
                xmlName: "displayText",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            stackSettings: {
                serializedName: "stackSettings",
                xmlName: "stackSettings",
                type: {
                    name: "Composite",
                    className: "FunctionAppRuntimes",
                },
            },
        },
    },
};
const FunctionAppRuntimes = {
    serializedName: "FunctionAppRuntimes",
    type: {
        name: "Composite",
        className: "FunctionAppRuntimes",
        modelProperties: {
            linuxRuntimeSettings: {
                serializedName: "linuxRuntimeSettings",
                xmlName: "linuxRuntimeSettings",
                type: {
                    name: "Composite",
                    className: "FunctionAppRuntimeSettings",
                },
            },
            windowsRuntimeSettings: {
                serializedName: "windowsRuntimeSettings",
                xmlName: "windowsRuntimeSettings",
                type: {
                    name: "Composite",
                    className: "FunctionAppRuntimeSettings",
                },
            },
        },
    },
};
const FunctionAppRuntimeSettings = {
    serializedName: "FunctionAppRuntimeSettings",
    type: {
        name: "Composite",
        className: "FunctionAppRuntimeSettings",
        modelProperties: {
            runtimeVersion: {
                serializedName: "runtimeVersion",
                readOnly: true,
                xmlName: "runtimeVersion",
                type: {
                    name: "String",
                },
            },
            remoteDebuggingSupported: {
                serializedName: "remoteDebuggingSupported",
                readOnly: true,
                xmlName: "remoteDebuggingSupported",
                type: {
                    name: "Boolean",
                },
            },
            appInsightsSettings: {
                serializedName: "appInsightsSettings",
                xmlName: "appInsightsSettings",
                type: {
                    name: "Composite",
                    className: "AppInsightsWebAppStackSettings",
                },
            },
            gitHubActionSettings: {
                serializedName: "gitHubActionSettings",
                xmlName: "gitHubActionSettings",
                type: {
                    name: "Composite",
                    className: "GitHubActionWebAppStackSettings",
                },
            },
            appSettingsDictionary: {
                serializedName: "appSettingsDictionary",
                readOnly: true,
                xmlName: "appSettingsDictionary",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            siteConfigPropertiesDictionary: {
                serializedName: "siteConfigPropertiesDictionary",
                xmlName: "siteConfigPropertiesDictionary",
                type: {
                    name: "Composite",
                    className: "SiteConfigPropertiesDictionary",
                },
            },
            supportedFunctionsExtensionVersions: {
                serializedName: "supportedFunctionsExtensionVersions",
                readOnly: true,
                xmlName: "supportedFunctionsExtensionVersions",
                xmlElementName: "FunctionAppRuntimeSettingsSupportedFunctionsExtensionVersionsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            isPreview: {
                serializedName: "isPreview",
                readOnly: true,
                xmlName: "isPreview",
                type: {
                    name: "Boolean",
                },
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                readOnly: true,
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean",
                },
            },
            isHidden: {
                serializedName: "isHidden",
                readOnly: true,
                xmlName: "isHidden",
                type: {
                    name: "Boolean",
                },
            },
            endOfLifeDate: {
                serializedName: "endOfLifeDate",
                readOnly: true,
                xmlName: "endOfLifeDate",
                type: {
                    name: "DateTime",
                },
            },
            isAutoUpdate: {
                serializedName: "isAutoUpdate",
                readOnly: true,
                xmlName: "isAutoUpdate",
                type: {
                    name: "Boolean",
                },
            },
            isEarlyAccess: {
                serializedName: "isEarlyAccess",
                readOnly: true,
                xmlName: "isEarlyAccess",
                type: {
                    name: "Boolean",
                },
            },
            isDefault: {
                serializedName: "isDefault",
                readOnly: true,
                xmlName: "isDefault",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const AppInsightsWebAppStackSettings = {
    serializedName: "AppInsightsWebAppStackSettings",
    type: {
        name: "Composite",
        className: "AppInsightsWebAppStackSettings",
        modelProperties: {
            isSupported: {
                serializedName: "isSupported",
                readOnly: true,
                xmlName: "isSupported",
                type: {
                    name: "Boolean",
                },
            },
            isDefaultOff: {
                serializedName: "isDefaultOff",
                readOnly: true,
                xmlName: "isDefaultOff",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const GitHubActionWebAppStackSettings = {
    serializedName: "GitHubActionWebAppStackSettings",
    type: {
        name: "Composite",
        className: "GitHubActionWebAppStackSettings",
        modelProperties: {
            isSupported: {
                serializedName: "isSupported",
                readOnly: true,
                xmlName: "isSupported",
                type: {
                    name: "Boolean",
                },
            },
            supportedVersion: {
                serializedName: "supportedVersion",
                readOnly: true,
                xmlName: "supportedVersion",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SiteConfigPropertiesDictionary = {
    serializedName: "SiteConfigPropertiesDictionary",
    type: {
        name: "Composite",
        className: "SiteConfigPropertiesDictionary",
        modelProperties: {
            use32BitWorkerProcess: {
                serializedName: "use32BitWorkerProcess",
                readOnly: true,
                xmlName: "use32BitWorkerProcess",
                type: {
                    name: "Boolean",
                },
            },
            linuxFxVersion: {
                serializedName: "linuxFxVersion",
                readOnly: true,
                xmlName: "linuxFxVersion",
                type: {
                    name: "String",
                },
            },
            javaVersion: {
                serializedName: "javaVersion",
                readOnly: true,
                xmlName: "javaVersion",
                type: {
                    name: "String",
                },
            },
            powerShellVersion: {
                serializedName: "powerShellVersion",
                readOnly: true,
                xmlName: "powerShellVersion",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WebAppStackCollection = {
    serializedName: "WebAppStackCollection",
    type: {
        name: "Composite",
        className: "WebAppStackCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "WebAppStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebAppStack",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WebAppMajorVersion = {
    serializedName: "WebAppMajorVersion",
    type: {
        name: "Composite",
        className: "WebAppMajorVersion",
        modelProperties: {
            displayText: {
                serializedName: "displayText",
                readOnly: true,
                xmlName: "displayText",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            minorVersions: {
                serializedName: "minorVersions",
                readOnly: true,
                xmlName: "minorVersions",
                xmlElementName: "WebAppMinorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebAppMinorVersion",
                        },
                    },
                },
            },
        },
    },
};
const WebAppMinorVersion = {
    serializedName: "WebAppMinorVersion",
    type: {
        name: "Composite",
        className: "WebAppMinorVersion",
        modelProperties: {
            displayText: {
                serializedName: "displayText",
                readOnly: true,
                xmlName: "displayText",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            stackSettings: {
                serializedName: "stackSettings",
                xmlName: "stackSettings",
                type: {
                    name: "Composite",
                    className: "WebAppRuntimes",
                },
            },
        },
    },
};
const WebAppRuntimes = {
    serializedName: "WebAppRuntimes",
    type: {
        name: "Composite",
        className: "WebAppRuntimes",
        modelProperties: {
            linuxRuntimeSettings: {
                serializedName: "linuxRuntimeSettings",
                xmlName: "linuxRuntimeSettings",
                type: {
                    name: "Composite",
                    className: "WebAppRuntimeSettings",
                },
            },
            windowsRuntimeSettings: {
                serializedName: "windowsRuntimeSettings",
                xmlName: "windowsRuntimeSettings",
                type: {
                    name: "Composite",
                    className: "WebAppRuntimeSettings",
                },
            },
            linuxContainerSettings: {
                serializedName: "linuxContainerSettings",
                xmlName: "linuxContainerSettings",
                type: {
                    name: "Composite",
                    className: "LinuxJavaContainerSettings",
                },
            },
            windowsContainerSettings: {
                serializedName: "windowsContainerSettings",
                xmlName: "windowsContainerSettings",
                type: {
                    name: "Composite",
                    className: "WindowsJavaContainerSettings",
                },
            },
        },
    },
};
const WebAppRuntimeSettings = {
    serializedName: "WebAppRuntimeSettings",
    type: {
        name: "Composite",
        className: "WebAppRuntimeSettings",
        modelProperties: {
            runtimeVersion: {
                serializedName: "runtimeVersion",
                readOnly: true,
                xmlName: "runtimeVersion",
                type: {
                    name: "String",
                },
            },
            remoteDebuggingSupported: {
                serializedName: "remoteDebuggingSupported",
                readOnly: true,
                xmlName: "remoteDebuggingSupported",
                type: {
                    name: "Boolean",
                },
            },
            appInsightsSettings: {
                serializedName: "appInsightsSettings",
                xmlName: "appInsightsSettings",
                type: {
                    name: "Composite",
                    className: "AppInsightsWebAppStackSettings",
                },
            },
            gitHubActionSettings: {
                serializedName: "gitHubActionSettings",
                xmlName: "gitHubActionSettings",
                type: {
                    name: "Composite",
                    className: "GitHubActionWebAppStackSettings",
                },
            },
            isPreview: {
                serializedName: "isPreview",
                readOnly: true,
                xmlName: "isPreview",
                type: {
                    name: "Boolean",
                },
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                readOnly: true,
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean",
                },
            },
            isHidden: {
                serializedName: "isHidden",
                readOnly: true,
                xmlName: "isHidden",
                type: {
                    name: "Boolean",
                },
            },
            endOfLifeDate: {
                serializedName: "endOfLifeDate",
                readOnly: true,
                xmlName: "endOfLifeDate",
                type: {
                    name: "DateTime",
                },
            },
            isAutoUpdate: {
                serializedName: "isAutoUpdate",
                readOnly: true,
                xmlName: "isAutoUpdate",
                type: {
                    name: "Boolean",
                },
            },
            isEarlyAccess: {
                serializedName: "isEarlyAccess",
                readOnly: true,
                xmlName: "isEarlyAccess",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const LinuxJavaContainerSettings = {
    serializedName: "LinuxJavaContainerSettings",
    type: {
        name: "Composite",
        className: "LinuxJavaContainerSettings",
        modelProperties: {
            java11Runtime: {
                serializedName: "java11Runtime",
                readOnly: true,
                xmlName: "java11Runtime",
                type: {
                    name: "String",
                },
            },
            java8Runtime: {
                serializedName: "java8Runtime",
                readOnly: true,
                xmlName: "java8Runtime",
                type: {
                    name: "String",
                },
            },
            isPreview: {
                serializedName: "isPreview",
                readOnly: true,
                xmlName: "isPreview",
                type: {
                    name: "Boolean",
                },
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                readOnly: true,
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean",
                },
            },
            isHidden: {
                serializedName: "isHidden",
                readOnly: true,
                xmlName: "isHidden",
                type: {
                    name: "Boolean",
                },
            },
            endOfLifeDate: {
                serializedName: "endOfLifeDate",
                readOnly: true,
                xmlName: "endOfLifeDate",
                type: {
                    name: "DateTime",
                },
            },
            isAutoUpdate: {
                serializedName: "isAutoUpdate",
                readOnly: true,
                xmlName: "isAutoUpdate",
                type: {
                    name: "Boolean",
                },
            },
            isEarlyAccess: {
                serializedName: "isEarlyAccess",
                readOnly: true,
                xmlName: "isEarlyAccess",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const WindowsJavaContainerSettings = {
    serializedName: "WindowsJavaContainerSettings",
    type: {
        name: "Composite",
        className: "WindowsJavaContainerSettings",
        modelProperties: {
            javaContainer: {
                serializedName: "javaContainer",
                readOnly: true,
                xmlName: "javaContainer",
                type: {
                    name: "String",
                },
            },
            javaContainerVersion: {
                serializedName: "javaContainerVersion",
                readOnly: true,
                xmlName: "javaContainerVersion",
                type: {
                    name: "String",
                },
            },
            isPreview: {
                serializedName: "isPreview",
                readOnly: true,
                xmlName: "isPreview",
                type: {
                    name: "Boolean",
                },
            },
            isDeprecated: {
                serializedName: "isDeprecated",
                readOnly: true,
                xmlName: "isDeprecated",
                type: {
                    name: "Boolean",
                },
            },
            isHidden: {
                serializedName: "isHidden",
                readOnly: true,
                xmlName: "isHidden",
                type: {
                    name: "Boolean",
                },
            },
            endOfLifeDate: {
                serializedName: "endOfLifeDate",
                readOnly: true,
                xmlName: "endOfLifeDate",
                type: {
                    name: "DateTime",
                },
            },
            isAutoUpdate: {
                serializedName: "isAutoUpdate",
                readOnly: true,
                xmlName: "isAutoUpdate",
                type: {
                    name: "Boolean",
                },
            },
            isEarlyAccess: {
                serializedName: "isEarlyAccess",
                readOnly: true,
                xmlName: "isEarlyAccess",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const RecommendationCollection = {
    serializedName: "RecommendationCollection",
    type: {
        name: "Composite",
        className: "RecommendationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Recommendation",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Recommendation",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ResourceHealthMetadataCollection = {
    serializedName: "ResourceHealthMetadataCollection",
    type: {
        name: "Composite",
        className: "ResourceHealthMetadataCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ResourceHealthMetadata",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceHealthMetadata",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SourceControlCollection = {
    serializedName: "SourceControlCollection",
    type: {
        name: "Composite",
        className: "SourceControlCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SourceControl",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SourceControl",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const BillingMeterCollection = {
    serializedName: "BillingMeterCollection",
    type: {
        name: "Composite",
        className: "BillingMeterCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "BillingMeter",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BillingMeter",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ResourceNameAvailabilityRequest = {
    serializedName: "ResourceNameAvailabilityRequest",
    type: {
        name: "Composite",
        className: "ResourceNameAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            typeParam: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            isFqdn: {
                serializedName: "isFqdn",
                xmlName: "isFqdn",
                type: {
                    name: "Boolean",
                },
            },
            environmentId: {
                serializedName: "environmentId",
                xmlName: "environmentId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ResourceNameAvailability = {
    serializedName: "ResourceNameAvailability",
    type: {
        name: "Composite",
        className: "ResourceNameAvailability",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                xmlName: "nameAvailable",
                type: {
                    name: "Boolean",
                },
            },
            reason: {
                serializedName: "reason",
                xmlName: "reason",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CustomHostnameSitesCollection = {
    serializedName: "CustomHostnameSitesCollection",
    type: {
        name: "Composite",
        className: "CustomHostnameSitesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CustomHostnameSites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomHostnameSites",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DeploymentLocations = {
    serializedName: "DeploymentLocations",
    type: {
        name: "Composite",
        className: "DeploymentLocations",
        modelProperties: {
            locations: {
                serializedName: "locations",
                xmlName: "locations",
                xmlElementName: "GeoRegion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GeoRegion",
                        },
                    },
                },
            },
            hostingEnvironments: {
                serializedName: "hostingEnvironments",
                xmlName: "hostingEnvironments",
                xmlElementName: "AppServiceEnvironment",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AppServiceEnvironment",
                        },
                    },
                },
            },
            hostingEnvironmentDeploymentInfos: {
                serializedName: "hostingEnvironmentDeploymentInfos",
                xmlName: "hostingEnvironmentDeploymentInfos",
                xmlElementName: "HostingEnvironmentDeploymentInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostingEnvironmentDeploymentInfo",
                        },
                    },
                },
            },
        },
    },
};
const HostingEnvironmentDeploymentInfo = {
    serializedName: "HostingEnvironmentDeploymentInfo",
    type: {
        name: "Composite",
        className: "HostingEnvironmentDeploymentInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AseRegionCollection = {
    serializedName: "AseRegionCollection",
    type: {
        name: "Composite",
        className: "AseRegionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "AseRegion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AseRegion",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const GeoRegionCollection = {
    serializedName: "GeoRegionCollection",
    type: {
        name: "Composite",
        className: "GeoRegionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "GeoRegion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GeoRegion",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const IdentifierCollection = {
    serializedName: "IdentifierCollection",
    type: {
        name: "Composite",
        className: "IdentifierCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Identifier",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Identifier",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PremierAddOnOfferCollection = {
    serializedName: "PremierAddOnOfferCollection",
    type: {
        name: "Composite",
        className: "PremierAddOnOfferCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "PremierAddOnOffer",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PremierAddOnOffer",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SkuInfos = {
    serializedName: "SkuInfos",
    type: {
        name: "Composite",
        className: "SkuInfos",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                xmlName: "resourceType",
                type: {
                    name: "String",
                },
            },
            skus: {
                serializedName: "skus",
                xmlName: "skus",
                xmlElementName: "GlobalCsmSkuDescription",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GlobalCsmSkuDescription",
                        },
                    },
                },
            },
        },
    },
};
const GlobalCsmSkuDescription = {
    serializedName: "GlobalCsmSkuDescription",
    type: {
        name: "Composite",
        className: "GlobalCsmSkuDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            tier: {
                serializedName: "tier",
                xmlName: "tier",
                type: {
                    name: "String",
                },
            },
            size: {
                serializedName: "size",
                xmlName: "size",
                type: {
                    name: "String",
                },
            },
            family: {
                serializedName: "family",
                xmlName: "family",
                type: {
                    name: "String",
                },
            },
            capacity: {
                serializedName: "capacity",
                xmlName: "capacity",
                type: {
                    name: "Composite",
                    className: "SkuCapacity",
                },
            },
            locations: {
                serializedName: "locations",
                xmlName: "locations",
                xmlElementName: "GlobalCsmSkuDescriptionLocationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            capabilities: {
                serializedName: "capabilities",
                xmlName: "capabilities",
                xmlElementName: "Capability",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Capability",
                        },
                    },
                },
            },
        },
    },
};
const CsmMoveResourceEnvelope = {
    serializedName: "CsmMoveResourceEnvelope",
    type: {
        name: "Composite",
        className: "CsmMoveResourceEnvelope",
        modelProperties: {
            targetResourceGroup: {
                constraints: {
                    Pattern: new RegExp(" ^[-\\w\\._\\(\\)]+[^\\.]$"),
                    MaxLength: 90,
                    MinLength: 1,
                },
                serializedName: "targetResourceGroup",
                xmlName: "targetResourceGroup",
                type: {
                    name: "String",
                },
            },
            resources: {
                serializedName: "resources",
                xmlName: "resources",
                xmlElementName: "CsmMoveResourceEnvelopeResourcesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const ValidateRequest = {
    serializedName: "ValidateRequest",
    type: {
        name: "Composite",
        className: "ValidateRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            location: {
                serializedName: "location",
                required: true,
                xmlName: "location",
                type: {
                    name: "String",
                },
            },
            serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String",
                },
            },
            skuName: {
                serializedName: "properties.skuName",
                xmlName: "properties.skuName",
                type: {
                    name: "String",
                },
            },
            needLinuxWorkers: {
                serializedName: "properties.needLinuxWorkers",
                xmlName: "properties.needLinuxWorkers",
                type: {
                    name: "Boolean",
                },
            },
            isSpot: {
                serializedName: "properties.isSpot",
                xmlName: "properties.isSpot",
                type: {
                    name: "Boolean",
                },
            },
            capacity: {
                constraints: {
                    InclusiveMinimum: 1,
                },
                serializedName: "properties.capacity",
                xmlName: "properties.capacity",
                type: {
                    name: "Number",
                },
            },
            hostingEnvironment: {
                serializedName: "properties.hostingEnvironment",
                xmlName: "properties.hostingEnvironment",
                type: {
                    name: "String",
                },
            },
            isXenon: {
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean",
                },
            },
            containerRegistryBaseUrl: {
                serializedName: "properties.containerRegistryBaseUrl",
                xmlName: "properties.containerRegistryBaseUrl",
                type: {
                    name: "String",
                },
            },
            containerRegistryUsername: {
                serializedName: "properties.containerRegistryUsername",
                xmlName: "properties.containerRegistryUsername",
                type: {
                    name: "String",
                },
            },
            containerRegistryPassword: {
                serializedName: "properties.containerRegistryPassword",
                xmlName: "properties.containerRegistryPassword",
                type: {
                    name: "String",
                },
            },
            containerImageRepository: {
                serializedName: "properties.containerImageRepository",
                xmlName: "properties.containerImageRepository",
                type: {
                    name: "String",
                },
            },
            containerImageTag: {
                serializedName: "properties.containerImageTag",
                xmlName: "properties.containerImageTag",
                type: {
                    name: "String",
                },
            },
            containerImagePlatform: {
                serializedName: "properties.containerImagePlatform",
                xmlName: "properties.containerImagePlatform",
                type: {
                    name: "String",
                },
            },
            appServiceEnvironment: {
                serializedName: "properties.appServiceEnvironment",
                xmlName: "properties.appServiceEnvironment",
                type: {
                    name: "Composite",
                    className: "AppServiceEnvironment",
                },
            },
        },
    },
};
const ValidateResponse = {
    serializedName: "ValidateResponse",
    type: {
        name: "Composite",
        className: "ValidateResponse",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String",
                },
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "ValidateResponseError",
                },
            },
        },
    },
};
const ValidateResponseError = {
    serializedName: "ValidateResponseError",
    type: {
        name: "Composite",
        className: "ValidateResponseError",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteBuildProperties = {
    serializedName: "StaticSiteBuildProperties",
    type: {
        name: "Composite",
        className: "StaticSiteBuildProperties",
        modelProperties: {
            appLocation: {
                serializedName: "appLocation",
                xmlName: "appLocation",
                type: {
                    name: "String",
                },
            },
            apiLocation: {
                serializedName: "apiLocation",
                xmlName: "apiLocation",
                type: {
                    name: "String",
                },
            },
            appArtifactLocation: {
                serializedName: "appArtifactLocation",
                xmlName: "appArtifactLocation",
                type: {
                    name: "String",
                },
            },
            outputLocation: {
                serializedName: "outputLocation",
                xmlName: "outputLocation",
                type: {
                    name: "String",
                },
            },
            appBuildCommand: {
                serializedName: "appBuildCommand",
                xmlName: "appBuildCommand",
                type: {
                    name: "String",
                },
            },
            apiBuildCommand: {
                serializedName: "apiBuildCommand",
                xmlName: "apiBuildCommand",
                type: {
                    name: "String",
                },
            },
            skipGithubActionWorkflowGeneration: {
                serializedName: "skipGithubActionWorkflowGeneration",
                xmlName: "skipGithubActionWorkflowGeneration",
                type: {
                    name: "Boolean",
                },
            },
            githubActionSecretNameOverride: {
                serializedName: "githubActionSecretNameOverride",
                xmlName: "githubActionSecretNameOverride",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteCollection = {
    serializedName: "StaticSiteCollection",
    type: {
        name: "Composite",
        className: "StaticSiteCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteARMResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ResponseMessageEnvelopeRemotePrivateEndpointConnection = {
    serializedName: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
    type: {
        name: "Composite",
        className: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String",
                },
            },
            tags: {
                serializedName: "tags",
                xmlName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            plan: {
                serializedName: "plan",
                xmlName: "plan",
                type: {
                    name: "Composite",
                    className: "ArmPlan",
                },
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "RemotePrivateEndpointConnection",
                },
            },
            sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription",
                },
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String",
                },
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorEntity",
                },
            },
            identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity",
                },
            },
            zones: {
                serializedName: "zones",
                xmlName: "zones",
                xmlElementName: "ResponseMessageEnvelopeRemotePrivateEndpointConnectionZonesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const ArmPlan = {
    serializedName: "ArmPlan",
    type: {
        name: "Composite",
        className: "ArmPlan",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            publisher: {
                serializedName: "publisher",
                xmlName: "publisher",
                type: {
                    name: "String",
                },
            },
            product: {
                serializedName: "product",
                xmlName: "product",
                type: {
                    name: "String",
                },
            },
            promotionCode: {
                serializedName: "promotionCode",
                xmlName: "promotionCode",
                type: {
                    name: "String",
                },
            },
            version: {
                serializedName: "version",
                xmlName: "version",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteTemplateOptions = {
    serializedName: "StaticSiteTemplateOptions",
    type: {
        name: "Composite",
        className: "StaticSiteTemplateOptions",
        modelProperties: {
            templateRepositoryUrl: {
                serializedName: "templateRepositoryUrl",
                xmlName: "templateRepositoryUrl",
                type: {
                    name: "String",
                },
            },
            owner: {
                serializedName: "owner",
                xmlName: "owner",
                type: {
                    name: "String",
                },
            },
            repositoryName: {
                serializedName: "repositoryName",
                xmlName: "repositoryName",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
            isPrivate: {
                serializedName: "isPrivate",
                xmlName: "isPrivate",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const StaticSiteLinkedBackend = {
    serializedName: "StaticSiteLinkedBackend",
    type: {
        name: "Composite",
        className: "StaticSiteLinkedBackend",
        modelProperties: {
            backendResourceId: {
                serializedName: "backendResourceId",
                xmlName: "backendResourceId",
                type: {
                    name: "String",
                },
            },
            region: {
                serializedName: "region",
                xmlName: "region",
                type: {
                    name: "String",
                },
            },
            createdOn: {
                serializedName: "createdOn",
                readOnly: true,
                xmlName: "createdOn",
                type: {
                    name: "DateTime",
                },
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                xmlName: "provisioningState",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DatabaseConnectionOverview = {
    serializedName: "DatabaseConnectionOverview",
    type: {
        name: "Composite",
        className: "DatabaseConnectionOverview",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                xmlName: "resourceId",
                type: {
                    name: "String",
                },
            },
            connectionIdentity: {
                serializedName: "connectionIdentity",
                readOnly: true,
                xmlName: "connectionIdentity",
                type: {
                    name: "String",
                },
            },
            region: {
                serializedName: "region",
                readOnly: true,
                xmlName: "region",
                type: {
                    name: "String",
                },
            },
            configurationFiles: {
                serializedName: "configurationFiles",
                readOnly: true,
                xmlName: "configurationFiles",
                xmlElementName: "StaticSiteDatabaseConnectionConfigurationFileOverview",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteDatabaseConnectionConfigurationFileOverview",
                        },
                    },
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteDatabaseConnectionConfigurationFileOverview = {
    serializedName: "StaticSiteDatabaseConnectionConfigurationFileOverview",
    type: {
        name: "Composite",
        className: "StaticSiteDatabaseConnectionConfigurationFileOverview",
        modelProperties: {
            fileName: {
                serializedName: "fileName",
                readOnly: true,
                xmlName: "fileName",
                type: {
                    name: "String",
                },
            },
            contents: {
                serializedName: "contents",
                readOnly: true,
                xmlName: "contents",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteUserCollection = {
    serializedName: "StaticSiteUserCollection",
    type: {
        name: "Composite",
        className: "StaticSiteUserCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteUserARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserARMResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteBuildCollection = {
    serializedName: "StaticSiteBuildCollection",
    type: {
        name: "Composite",
        className: "StaticSiteBuildCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteBuildARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteBuildARMResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DatabaseConnectionCollection = {
    serializedName: "DatabaseConnectionCollection",
    type: {
        name: "Composite",
        className: "DatabaseConnectionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "DatabaseConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseConnection",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DatabaseConnectionPatchRequest = {
    serializedName: "DatabaseConnectionPatchRequest",
    type: {
        name: "Composite",
        className: "DatabaseConnectionPatchRequest",
        modelProperties: {
            resourceId: {
                serializedName: "properties.resourceId",
                xmlName: "properties.resourceId",
                type: {
                    name: "String",
                },
            },
            connectionIdentity: {
                serializedName: "properties.connectionIdentity",
                xmlName: "properties.connectionIdentity",
                type: {
                    name: "String",
                },
            },
            connectionString: {
                serializedName: "properties.connectionString",
                xmlName: "properties.connectionString",
                type: {
                    name: "String",
                },
            },
            region: {
                serializedName: "properties.region",
                xmlName: "properties.region",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteFunctionOverviewCollection = {
    serializedName: "StaticSiteFunctionOverviewCollection",
    type: {
        name: "Composite",
        className: "StaticSiteFunctionOverviewCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteFunctionOverviewARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteFunctionOverviewARMResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteUserProvidedFunctionAppsCollection = {
    serializedName: "StaticSiteUserProvidedFunctionAppsCollection",
    type: {
        name: "Composite",
        className: "StaticSiteUserProvidedFunctionAppsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteUserProvidedFunctionAppARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserProvidedFunctionAppARMResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteBasicAuthPropertiesCollection = {
    serializedName: "StaticSiteBasicAuthPropertiesCollection",
    type: {
        name: "Composite",
        className: "StaticSiteBasicAuthPropertiesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteBasicAuthPropertiesARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteBasicAuthPropertiesARMResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteCustomDomainOverviewCollection = {
    serializedName: "StaticSiteCustomDomainOverviewCollection",
    type: {
        name: "Composite",
        className: "StaticSiteCustomDomainOverviewCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteCustomDomainOverviewARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteCustomDomainOverviewARMResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const StaticSiteLinkedBackendsCollection = {
    serializedName: "StaticSiteLinkedBackendsCollection",
    type: {
        name: "Composite",
        className: "StaticSiteLinkedBackendsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "StaticSiteLinkedBackendARMResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteLinkedBackendARMResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CsmSlotEntity = {
    serializedName: "CsmSlotEntity",
    type: {
        name: "Composite",
        className: "CsmSlotEntity",
        modelProperties: {
            targetSlot: {
                serializedName: "targetSlot",
                required: true,
                xmlName: "targetSlot",
                type: {
                    name: "String",
                },
            },
            preserveVnet: {
                serializedName: "preserveVnet",
                required: true,
                xmlName: "preserveVnet",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const BackupSchedule = {
    serializedName: "BackupSchedule",
    type: {
        name: "Composite",
        className: "BackupSchedule",
        modelProperties: {
            frequencyInterval: {
                defaultValue: 7,
                serializedName: "frequencyInterval",
                required: true,
                xmlName: "frequencyInterval",
                type: {
                    name: "Number",
                },
            },
            frequencyUnit: {
                defaultValue: "Day",
                serializedName: "frequencyUnit",
                required: true,
                xmlName: "frequencyUnit",
                type: {
                    name: "Enum",
                    allowedValues: ["Day", "Hour"],
                },
            },
            keepAtLeastOneBackup: {
                defaultValue: true,
                serializedName: "keepAtLeastOneBackup",
                required: true,
                xmlName: "keepAtLeastOneBackup",
                type: {
                    name: "Boolean",
                },
            },
            retentionPeriodInDays: {
                defaultValue: 30,
                serializedName: "retentionPeriodInDays",
                required: true,
                xmlName: "retentionPeriodInDays",
                type: {
                    name: "Number",
                },
            },
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime",
                },
            },
            lastExecutionTime: {
                serializedName: "lastExecutionTime",
                readOnly: true,
                xmlName: "lastExecutionTime",
                type: {
                    name: "DateTime",
                },
            },
        },
    },
};
const DatabaseBackupSetting = {
    serializedName: "DatabaseBackupSetting",
    type: {
        name: "Composite",
        className: "DatabaseBackupSetting",
        modelProperties: {
            databaseType: {
                serializedName: "databaseType",
                required: true,
                xmlName: "databaseType",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            connectionStringName: {
                serializedName: "connectionStringName",
                xmlName: "connectionStringName",
                type: {
                    name: "String",
                },
            },
            connectionString: {
                serializedName: "connectionString",
                xmlName: "connectionString",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const BackupItemCollection = {
    serializedName: "BackupItemCollection",
    type: {
        name: "Composite",
        className: "BackupItemCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "BackupItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackupItem",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PublishingCredentialsPoliciesCollection = {
    serializedName: "PublishingCredentialsPoliciesCollection",
    type: {
        name: "Composite",
        className: "PublishingCredentialsPoliciesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CsmPublishingCredentialsPoliciesEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CsmPublishingCredentialsPoliciesEntity",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SiteConfigResourceCollection = {
    serializedName: "SiteConfigResourceCollection",
    type: {
        name: "Composite",
        className: "SiteConfigResourceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SiteConfigResource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteConfigResource",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AuthPlatform = {
    serializedName: "AuthPlatform",
    type: {
        name: "Composite",
        className: "AuthPlatform",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                xmlName: "runtimeVersion",
                type: {
                    name: "String",
                },
            },
            configFilePath: {
                serializedName: "configFilePath",
                xmlName: "configFilePath",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const GlobalValidation = {
    serializedName: "GlobalValidation",
    type: {
        name: "Composite",
        className: "GlobalValidation",
        modelProperties: {
            requireAuthentication: {
                serializedName: "requireAuthentication",
                xmlName: "requireAuthentication",
                type: {
                    name: "Boolean",
                },
            },
            unauthenticatedClientAction: {
                serializedName: "unauthenticatedClientAction",
                xmlName: "unauthenticatedClientAction",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "RedirectToLoginPage",
                        "AllowAnonymous",
                        "Return401",
                        "Return403",
                    ],
                },
            },
            redirectToProvider: {
                serializedName: "redirectToProvider",
                xmlName: "redirectToProvider",
                type: {
                    name: "String",
                },
            },
            excludedPaths: {
                serializedName: "excludedPaths",
                xmlName: "excludedPaths",
                xmlElementName: "GlobalValidationExcludedPathsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const IdentityProviders = {
    serializedName: "IdentityProviders",
    type: {
        name: "Composite",
        className: "IdentityProviders",
        modelProperties: {
            azureActiveDirectory: {
                serializedName: "azureActiveDirectory",
                xmlName: "azureActiveDirectory",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectory",
                },
            },
            facebook: {
                serializedName: "facebook",
                xmlName: "facebook",
                type: {
                    name: "Composite",
                    className: "Facebook",
                },
            },
            gitHub: {
                serializedName: "gitHub",
                xmlName: "gitHub",
                type: {
                    name: "Composite",
                    className: "GitHub",
                },
            },
            google: {
                serializedName: "google",
                xmlName: "google",
                type: {
                    name: "Composite",
                    className: "Google",
                },
            },
            legacyMicrosoftAccount: {
                serializedName: "legacyMicrosoftAccount",
                xmlName: "legacyMicrosoftAccount",
                type: {
                    name: "Composite",
                    className: "LegacyMicrosoftAccount",
                },
            },
            twitter: {
                serializedName: "twitter",
                xmlName: "twitter",
                type: {
                    name: "Composite",
                    className: "Twitter",
                },
            },
            apple: {
                serializedName: "apple",
                xmlName: "apple",
                type: {
                    name: "Composite",
                    className: "Apple",
                },
            },
            azureStaticWebApps: {
                serializedName: "azureStaticWebApps",
                xmlName: "azureStaticWebApps",
                type: {
                    name: "Composite",
                    className: "AzureStaticWebApps",
                },
            },
            customOpenIdConnectProviders: {
                serializedName: "customOpenIdConnectProviders",
                xmlName: "customOpenIdConnectProviders",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "CustomOpenIdConnectProvider",
                        },
                    },
                },
            },
        },
    },
};
const AzureActiveDirectory = {
    serializedName: "AzureActiveDirectory",
    type: {
        name: "Composite",
        className: "AzureActiveDirectory",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryRegistration",
                },
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryLogin",
                },
            },
            validation: {
                serializedName: "validation",
                xmlName: "validation",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryValidation",
                },
            },
            isAutoProvisioned: {
                serializedName: "isAutoProvisioned",
                xmlName: "isAutoProvisioned",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const AzureActiveDirectoryRegistration = {
    serializedName: "AzureActiveDirectoryRegistration",
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryRegistration",
        modelProperties: {
            openIdIssuer: {
                serializedName: "openIdIssuer",
                xmlName: "openIdIssuer",
                type: {
                    name: "String",
                },
            },
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String",
                },
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                xmlName: "clientSecretSettingName",
                type: {
                    name: "String",
                },
            },
            clientSecretCertificateThumbprint: {
                serializedName: "clientSecretCertificateThumbprint",
                xmlName: "clientSecretCertificateThumbprint",
                type: {
                    name: "String",
                },
            },
            clientSecretCertificateSubjectAlternativeName: {
                serializedName: "clientSecretCertificateSubjectAlternativeName",
                xmlName: "clientSecretCertificateSubjectAlternativeName",
                type: {
                    name: "String",
                },
            },
            clientSecretCertificateIssuer: {
                serializedName: "clientSecretCertificateIssuer",
                xmlName: "clientSecretCertificateIssuer",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AzureActiveDirectoryLogin = {
    serializedName: "AzureActiveDirectoryLogin",
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryLogin",
        modelProperties: {
            loginParameters: {
                serializedName: "loginParameters",
                xmlName: "loginParameters",
                xmlElementName: "AzureActiveDirectoryLoginParametersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            disableWWWAuthenticate: {
                serializedName: "disableWWWAuthenticate",
                xmlName: "disableWWWAuthenticate",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const AzureActiveDirectoryValidation = {
    serializedName: "AzureActiveDirectoryValidation",
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryValidation",
        modelProperties: {
            jwtClaimChecks: {
                serializedName: "jwtClaimChecks",
                xmlName: "jwtClaimChecks",
                type: {
                    name: "Composite",
                    className: "JwtClaimChecks",
                },
            },
            allowedAudiences: {
                serializedName: "allowedAudiences",
                xmlName: "allowedAudiences",
                xmlElementName: "AzureActiveDirectoryValidationAllowedAudiencesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            defaultAuthorizationPolicy: {
                serializedName: "defaultAuthorizationPolicy",
                xmlName: "defaultAuthorizationPolicy",
                type: {
                    name: "Composite",
                    className: "DefaultAuthorizationPolicy",
                },
            },
        },
    },
};
const JwtClaimChecks = {
    serializedName: "JwtClaimChecks",
    type: {
        name: "Composite",
        className: "JwtClaimChecks",
        modelProperties: {
            allowedGroups: {
                serializedName: "allowedGroups",
                xmlName: "allowedGroups",
                xmlElementName: "JwtClaimChecksAllowedGroupsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            allowedClientApplications: {
                serializedName: "allowedClientApplications",
                xmlName: "allowedClientApplications",
                xmlElementName: "JwtClaimChecksAllowedClientApplicationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const DefaultAuthorizationPolicy = {
    serializedName: "DefaultAuthorizationPolicy",
    type: {
        name: "Composite",
        className: "DefaultAuthorizationPolicy",
        modelProperties: {
            allowedPrincipals: {
                serializedName: "allowedPrincipals",
                xmlName: "allowedPrincipals",
                type: {
                    name: "Composite",
                    className: "AllowedPrincipals",
                },
            },
            allowedApplications: {
                serializedName: "allowedApplications",
                xmlName: "allowedApplications",
                xmlElementName: "DefaultAuthorizationPolicyAllowedApplicationsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const AllowedPrincipals = {
    serializedName: "AllowedPrincipals",
    type: {
        name: "Composite",
        className: "AllowedPrincipals",
        modelProperties: {
            groups: {
                serializedName: "groups",
                xmlName: "groups",
                xmlElementName: "AllowedPrincipalsGroupsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            identities: {
                serializedName: "identities",
                xmlName: "identities",
                xmlElementName: "AllowedPrincipalsIdentitiesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const Facebook = {
    serializedName: "Facebook",
    type: {
        name: "Composite",
        className: "Facebook",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "AppRegistration",
                },
            },
            graphApiVersion: {
                serializedName: "graphApiVersion",
                xmlName: "graphApiVersion",
                type: {
                    name: "String",
                },
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes",
                },
            },
        },
    },
};
const AppRegistration = {
    serializedName: "AppRegistration",
    type: {
        name: "Composite",
        className: "AppRegistration",
        modelProperties: {
            appId: {
                serializedName: "appId",
                xmlName: "appId",
                type: {
                    name: "String",
                },
            },
            appSecretSettingName: {
                serializedName: "appSecretSettingName",
                xmlName: "appSecretSettingName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const LoginScopes = {
    serializedName: "LoginScopes",
    type: {
        name: "Composite",
        className: "LoginScopes",
        modelProperties: {
            scopes: {
                serializedName: "scopes",
                xmlName: "scopes",
                xmlElementName: "LoginScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const GitHub = {
    serializedName: "GitHub",
    type: {
        name: "Composite",
        className: "GitHub",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "ClientRegistration",
                },
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes",
                },
            },
        },
    },
};
const ClientRegistration = {
    serializedName: "ClientRegistration",
    type: {
        name: "Composite",
        className: "ClientRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String",
                },
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                xmlName: "clientSecretSettingName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Google = {
    serializedName: "Google",
    type: {
        name: "Composite",
        className: "Google",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "ClientRegistration",
                },
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes",
                },
            },
            validation: {
                serializedName: "validation",
                xmlName: "validation",
                type: {
                    name: "Composite",
                    className: "AllowedAudiencesValidation",
                },
            },
        },
    },
};
const AllowedAudiencesValidation = {
    serializedName: "AllowedAudiencesValidation",
    type: {
        name: "Composite",
        className: "AllowedAudiencesValidation",
        modelProperties: {
            allowedAudiences: {
                serializedName: "allowedAudiences",
                xmlName: "allowedAudiences",
                xmlElementName: "AllowedAudiencesValidationAllowedAudiencesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const LegacyMicrosoftAccount = {
    serializedName: "LegacyMicrosoftAccount",
    type: {
        name: "Composite",
        className: "LegacyMicrosoftAccount",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "ClientRegistration",
                },
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes",
                },
            },
            validation: {
                serializedName: "validation",
                xmlName: "validation",
                type: {
                    name: "Composite",
                    className: "AllowedAudiencesValidation",
                },
            },
        },
    },
};
const Twitter = {
    serializedName: "Twitter",
    type: {
        name: "Composite",
        className: "Twitter",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "TwitterRegistration",
                },
            },
        },
    },
};
const TwitterRegistration = {
    serializedName: "TwitterRegistration",
    type: {
        name: "Composite",
        className: "TwitterRegistration",
        modelProperties: {
            consumerKey: {
                serializedName: "consumerKey",
                xmlName: "consumerKey",
                type: {
                    name: "String",
                },
            },
            consumerSecretSettingName: {
                serializedName: "consumerSecretSettingName",
                xmlName: "consumerSecretSettingName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Apple = {
    serializedName: "Apple",
    type: {
        name: "Composite",
        className: "Apple",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "AppleRegistration",
                },
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes",
                },
            },
        },
    },
};
const AppleRegistration = {
    serializedName: "AppleRegistration",
    type: {
        name: "Composite",
        className: "AppleRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String",
                },
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                xmlName: "clientSecretSettingName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AzureStaticWebApps = {
    serializedName: "AzureStaticWebApps",
    type: {
        name: "Composite",
        className: "AzureStaticWebApps",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "AzureStaticWebAppsRegistration",
                },
            },
        },
    },
};
const AzureStaticWebAppsRegistration = {
    serializedName: "AzureStaticWebAppsRegistration",
    type: {
        name: "Composite",
        className: "AzureStaticWebAppsRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CustomOpenIdConnectProvider = {
    serializedName: "CustomOpenIdConnectProvider",
    type: {
        name: "Composite",
        className: "CustomOpenIdConnectProvider",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            registration: {
                serializedName: "registration",
                xmlName: "registration",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectRegistration",
                },
            },
            login: {
                serializedName: "login",
                xmlName: "login",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectLogin",
                },
            },
        },
    },
};
const OpenIdConnectRegistration = {
    serializedName: "OpenIdConnectRegistration",
    type: {
        name: "Composite",
        className: "OpenIdConnectRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                xmlName: "clientId",
                type: {
                    name: "String",
                },
            },
            clientCredential: {
                serializedName: "clientCredential",
                xmlName: "clientCredential",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectClientCredential",
                },
            },
            openIdConnectConfiguration: {
                serializedName: "openIdConnectConfiguration",
                xmlName: "openIdConnectConfiguration",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectConfig",
                },
            },
        },
    },
};
const OpenIdConnectClientCredential = {
    serializedName: "OpenIdConnectClientCredential",
    type: {
        name: "Composite",
        className: "OpenIdConnectClientCredential",
        modelProperties: {
            method: {
                defaultValue: "ClientSecretPost",
                isConstant: true,
                serializedName: "method",
                type: {
                    name: "String",
                },
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                xmlName: "clientSecretSettingName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const OpenIdConnectConfig = {
    serializedName: "OpenIdConnectConfig",
    type: {
        name: "Composite",
        className: "OpenIdConnectConfig",
        modelProperties: {
            authorizationEndpoint: {
                serializedName: "authorizationEndpoint",
                xmlName: "authorizationEndpoint",
                type: {
                    name: "String",
                },
            },
            tokenEndpoint: {
                serializedName: "tokenEndpoint",
                xmlName: "tokenEndpoint",
                type: {
                    name: "String",
                },
            },
            issuer: {
                serializedName: "issuer",
                xmlName: "issuer",
                type: {
                    name: "String",
                },
            },
            certificationUri: {
                serializedName: "certificationUri",
                xmlName: "certificationUri",
                type: {
                    name: "String",
                },
            },
            wellKnownOpenIdConfiguration: {
                serializedName: "wellKnownOpenIdConfiguration",
                xmlName: "wellKnownOpenIdConfiguration",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const OpenIdConnectLogin = {
    serializedName: "OpenIdConnectLogin",
    type: {
        name: "Composite",
        className: "OpenIdConnectLogin",
        modelProperties: {
            nameClaimType: {
                serializedName: "nameClaimType",
                xmlName: "nameClaimType",
                type: {
                    name: "String",
                },
            },
            scopes: {
                serializedName: "scopes",
                xmlName: "scopes",
                xmlElementName: "OpenIdConnectLoginScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const Login = {
    serializedName: "Login",
    type: {
        name: "Composite",
        className: "Login",
        modelProperties: {
            routes: {
                serializedName: "routes",
                xmlName: "routes",
                type: {
                    name: "Composite",
                    className: "LoginRoutes",
                },
            },
            tokenStore: {
                serializedName: "tokenStore",
                xmlName: "tokenStore",
                type: {
                    name: "Composite",
                    className: "TokenStore",
                },
            },
            preserveUrlFragmentsForLogins: {
                serializedName: "preserveUrlFragmentsForLogins",
                xmlName: "preserveUrlFragmentsForLogins",
                type: {
                    name: "Boolean",
                },
            },
            allowedExternalRedirectUrls: {
                serializedName: "allowedExternalRedirectUrls",
                xmlName: "allowedExternalRedirectUrls",
                xmlElementName: "LoginAllowedExternalRedirectUrlsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            cookieExpiration: {
                serializedName: "cookieExpiration",
                xmlName: "cookieExpiration",
                type: {
                    name: "Composite",
                    className: "CookieExpiration",
                },
            },
            nonce: {
                serializedName: "nonce",
                xmlName: "nonce",
                type: {
                    name: "Composite",
                    className: "Nonce",
                },
            },
        },
    },
};
const LoginRoutes = {
    serializedName: "LoginRoutes",
    type: {
        name: "Composite",
        className: "LoginRoutes",
        modelProperties: {
            logoutEndpoint: {
                serializedName: "logoutEndpoint",
                xmlName: "logoutEndpoint",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TokenStore = {
    serializedName: "TokenStore",
    type: {
        name: "Composite",
        className: "TokenStore",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            tokenRefreshExtensionHours: {
                serializedName: "tokenRefreshExtensionHours",
                xmlName: "tokenRefreshExtensionHours",
                type: {
                    name: "Number",
                },
            },
            fileSystem: {
                serializedName: "fileSystem",
                xmlName: "fileSystem",
                type: {
                    name: "Composite",
                    className: "FileSystemTokenStore",
                },
            },
            azureBlobStorage: {
                serializedName: "azureBlobStorage",
                xmlName: "azureBlobStorage",
                type: {
                    name: "Composite",
                    className: "BlobStorageTokenStore",
                },
            },
        },
    },
};
const FileSystemTokenStore = {
    serializedName: "FileSystemTokenStore",
    type: {
        name: "Composite",
        className: "FileSystemTokenStore",
        modelProperties: {
            directory: {
                serializedName: "directory",
                xmlName: "directory",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const BlobStorageTokenStore = {
    serializedName: "BlobStorageTokenStore",
    type: {
        name: "Composite",
        className: "BlobStorageTokenStore",
        modelProperties: {
            sasUrlSettingName: {
                serializedName: "sasUrlSettingName",
                xmlName: "sasUrlSettingName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CookieExpiration = {
    serializedName: "CookieExpiration",
    type: {
        name: "Composite",
        className: "CookieExpiration",
        modelProperties: {
            convention: {
                serializedName: "convention",
                xmlName: "convention",
                type: {
                    name: "Enum",
                    allowedValues: ["FixedTime", "IdentityProviderDerived"],
                },
            },
            timeToExpiration: {
                serializedName: "timeToExpiration",
                xmlName: "timeToExpiration",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Nonce = {
    serializedName: "Nonce",
    type: {
        name: "Composite",
        className: "Nonce",
        modelProperties: {
            validateNonce: {
                serializedName: "validateNonce",
                xmlName: "validateNonce",
                type: {
                    name: "Boolean",
                },
            },
            nonceExpirationInterval: {
                serializedName: "nonceExpirationInterval",
                xmlName: "nonceExpirationInterval",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const HttpSettings = {
    serializedName: "HttpSettings",
    type: {
        name: "Composite",
        className: "HttpSettings",
        modelProperties: {
            requireHttps: {
                serializedName: "requireHttps",
                xmlName: "requireHttps",
                type: {
                    name: "Boolean",
                },
            },
            routes: {
                serializedName: "routes",
                xmlName: "routes",
                type: {
                    name: "Composite",
                    className: "HttpSettingsRoutes",
                },
            },
            forwardProxy: {
                serializedName: "forwardProxy",
                xmlName: "forwardProxy",
                type: {
                    name: "Composite",
                    className: "ForwardProxy",
                },
            },
        },
    },
};
const HttpSettingsRoutes = {
    serializedName: "HttpSettingsRoutes",
    type: {
        name: "Composite",
        className: "HttpSettingsRoutes",
        modelProperties: {
            apiPrefix: {
                serializedName: "apiPrefix",
                xmlName: "apiPrefix",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ForwardProxy = {
    serializedName: "ForwardProxy",
    type: {
        name: "Composite",
        className: "ForwardProxy",
        modelProperties: {
            convention: {
                serializedName: "convention",
                xmlName: "convention",
                type: {
                    name: "Enum",
                    allowedValues: ["NoProxy", "Standard", "Custom"],
                },
            },
            customHostHeaderName: {
                serializedName: "customHostHeaderName",
                xmlName: "customHostHeaderName",
                type: {
                    name: "String",
                },
            },
            customProtoHeaderName: {
                serializedName: "customProtoHeaderName",
                xmlName: "customProtoHeaderName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ApiKVReferenceCollection = {
    serializedName: "ApiKVReferenceCollection",
    type: {
        name: "Composite",
        className: "ApiKVReferenceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ApiKVReference",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiKVReference",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ConnStringValueTypePair = {
    serializedName: "ConnStringValueTypePair",
    type: {
        name: "Composite",
        className: "ConnStringValueTypePair",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                required: true,
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "MySql",
                        "SQLServer",
                        "SQLAzure",
                        "Custom",
                        "NotificationHub",
                        "ServiceBus",
                        "EventHub",
                        "ApiHub",
                        "DocDb",
                        "RedisCache",
                        "PostgreSQL",
                    ],
                },
            },
        },
    },
};
const ApplicationLogsConfig = {
    serializedName: "ApplicationLogsConfig",
    type: {
        name: "Composite",
        className: "ApplicationLogsConfig",
        modelProperties: {
            fileSystem: {
                serializedName: "fileSystem",
                xmlName: "fileSystem",
                type: {
                    name: "Composite",
                    className: "FileSystemApplicationLogsConfig",
                },
            },
            azureTableStorage: {
                serializedName: "azureTableStorage",
                xmlName: "azureTableStorage",
                type: {
                    name: "Composite",
                    className: "AzureTableStorageApplicationLogsConfig",
                },
            },
            azureBlobStorage: {
                serializedName: "azureBlobStorage",
                xmlName: "azureBlobStorage",
                type: {
                    name: "Composite",
                    className: "AzureBlobStorageApplicationLogsConfig",
                },
            },
        },
    },
};
const FileSystemApplicationLogsConfig = {
    serializedName: "FileSystemApplicationLogsConfig",
    type: {
        name: "Composite",
        className: "FileSystemApplicationLogsConfig",
        modelProperties: {
            level: {
                serializedName: "level",
                xmlName: "level",
                type: {
                    name: "Enum",
                    allowedValues: ["Off", "Verbose", "Information", "Warning", "Error"],
                },
            },
        },
    },
};
const AzureTableStorageApplicationLogsConfig = {
    serializedName: "AzureTableStorageApplicationLogsConfig",
    type: {
        name: "Composite",
        className: "AzureTableStorageApplicationLogsConfig",
        modelProperties: {
            level: {
                serializedName: "level",
                xmlName: "level",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Off",
                        "Verbose",
                        "Information",
                        "Warning",
                        "Error",
                    ],
                },
            },
            sasUrl: {
                serializedName: "sasUrl",
                required: true,
                xmlName: "sasUrl",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AzureBlobStorageApplicationLogsConfig = {
    serializedName: "AzureBlobStorageApplicationLogsConfig",
    type: {
        name: "Composite",
        className: "AzureBlobStorageApplicationLogsConfig",
        modelProperties: {
            level: {
                serializedName: "level",
                xmlName: "level",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Off",
                        "Verbose",
                        "Information",
                        "Warning",
                        "Error",
                    ],
                },
            },
            sasUrl: {
                serializedName: "sasUrl",
                xmlName: "sasUrl",
                type: {
                    name: "String",
                },
            },
            retentionInDays: {
                serializedName: "retentionInDays",
                xmlName: "retentionInDays",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const HttpLogsConfig = {
    serializedName: "HttpLogsConfig",
    type: {
        name: "Composite",
        className: "HttpLogsConfig",
        modelProperties: {
            fileSystem: {
                serializedName: "fileSystem",
                xmlName: "fileSystem",
                type: {
                    name: "Composite",
                    className: "FileSystemHttpLogsConfig",
                },
            },
            azureBlobStorage: {
                serializedName: "azureBlobStorage",
                xmlName: "azureBlobStorage",
                type: {
                    name: "Composite",
                    className: "AzureBlobStorageHttpLogsConfig",
                },
            },
        },
    },
};
const FileSystemHttpLogsConfig = {
    serializedName: "FileSystemHttpLogsConfig",
    type: {
        name: "Composite",
        className: "FileSystemHttpLogsConfig",
        modelProperties: {
            retentionInMb: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 25,
                },
                serializedName: "retentionInMb",
                xmlName: "retentionInMb",
                type: {
                    name: "Number",
                },
            },
            retentionInDays: {
                serializedName: "retentionInDays",
                xmlName: "retentionInDays",
                type: {
                    name: "Number",
                },
            },
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const AzureBlobStorageHttpLogsConfig = {
    serializedName: "AzureBlobStorageHttpLogsConfig",
    type: {
        name: "Composite",
        className: "AzureBlobStorageHttpLogsConfig",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                xmlName: "sasUrl",
                type: {
                    name: "String",
                },
            },
            retentionInDays: {
                serializedName: "retentionInDays",
                xmlName: "retentionInDays",
                type: {
                    name: "Number",
                },
            },
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const EnabledConfig = {
    serializedName: "EnabledConfig",
    type: {
        name: "Composite",
        className: "EnabledConfig",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                xmlName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const SiteConfigurationSnapshotInfoCollection = {
    serializedName: "SiteConfigurationSnapshotInfoCollection",
    type: {
        name: "Composite",
        className: "SiteConfigurationSnapshotInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SiteConfigurationSnapshotInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteConfigurationSnapshotInfo",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ContinuousWebJobCollection = {
    serializedName: "ContinuousWebJobCollection",
    type: {
        name: "Composite",
        className: "ContinuousWebJobCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ContinuousWebJob",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContinuousWebJob",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CsmDeploymentStatusCollection = {
    serializedName: "CsmDeploymentStatusCollection",
    type: {
        name: "Composite",
        className: "CsmDeploymentStatusCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "CsmDeploymentStatus",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CsmDeploymentStatus",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DeploymentCollection = {
    serializedName: "DeploymentCollection",
    type: {
        name: "Composite",
        className: "DeploymentCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Deployment",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Deployment",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MSDeployLogEntry = {
    serializedName: "MSDeployLogEntry",
    type: {
        name: "Composite",
        className: "MSDeployLogEntry",
        modelProperties: {
            time: {
                serializedName: "time",
                readOnly: true,
                xmlName: "time",
                type: {
                    name: "DateTime",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["Message", "Warning", "Error"],
                },
            },
            message: {
                serializedName: "message",
                readOnly: true,
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FunctionEnvelopeCollection = {
    serializedName: "FunctionEnvelopeCollection",
    type: {
        name: "Composite",
        className: "FunctionEnvelopeCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "FunctionEnvelope",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionEnvelope",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const KeyInfo = {
    serializedName: "KeyInfo",
    type: {
        name: "Composite",
        className: "KeyInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FunctionSecrets = {
    serializedName: "FunctionSecrets",
    type: {
        name: "Composite",
        className: "FunctionSecrets",
        modelProperties: {
            key: {
                serializedName: "key",
                xmlName: "key",
                type: {
                    name: "String",
                },
            },
            triggerUrl: {
                serializedName: "trigger_url",
                xmlName: "trigger_url",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const HostKeys = {
    serializedName: "HostKeys",
    type: {
        name: "Composite",
        className: "HostKeys",
        modelProperties: {
            masterKey: {
                serializedName: "masterKey",
                xmlName: "masterKey",
                type: {
                    name: "String",
                },
            },
            functionKeys: {
                serializedName: "functionKeys",
                xmlName: "functionKeys",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            systemKeys: {
                serializedName: "systemKeys",
                xmlName: "systemKeys",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const HostNameBindingCollection = {
    serializedName: "HostNameBindingCollection",
    type: {
        name: "Composite",
        className: "HostNameBindingCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "HostNameBinding",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostNameBinding",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WebAppInstanceStatusCollection = {
    serializedName: "WebAppInstanceStatusCollection",
    type: {
        name: "Composite",
        className: "WebAppInstanceStatusCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "WebSiteInstanceStatus",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebSiteInstanceStatus",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ContainerInfo = {
    serializedName: "ContainerInfo",
    type: {
        name: "Composite",
        className: "ContainerInfo",
        modelProperties: {
            currentTimeStamp: {
                serializedName: "currentTimeStamp",
                xmlName: "currentTimeStamp",
                type: {
                    name: "DateTime",
                },
            },
            previousTimeStamp: {
                serializedName: "previousTimeStamp",
                xmlName: "previousTimeStamp",
                type: {
                    name: "DateTime",
                },
            },
            currentCpuStats: {
                serializedName: "currentCpuStats",
                xmlName: "currentCpuStats",
                type: {
                    name: "Composite",
                    className: "ContainerCpuStatistics",
                },
            },
            previousCpuStats: {
                serializedName: "previousCpuStats",
                xmlName: "previousCpuStats",
                type: {
                    name: "Composite",
                    className: "ContainerCpuStatistics",
                },
            },
            memoryStats: {
                serializedName: "memoryStats",
                xmlName: "memoryStats",
                type: {
                    name: "Composite",
                    className: "ContainerMemoryStatistics",
                },
            },
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            eth0: {
                serializedName: "eth0",
                xmlName: "eth0",
                type: {
                    name: "Composite",
                    className: "ContainerNetworkInterfaceStatistics",
                },
            },
        },
    },
};
const ContainerCpuStatistics = {
    serializedName: "ContainerCpuStatistics",
    type: {
        name: "Composite",
        className: "ContainerCpuStatistics",
        modelProperties: {
            cpuUsage: {
                serializedName: "cpuUsage",
                xmlName: "cpuUsage",
                type: {
                    name: "Composite",
                    className: "ContainerCpuUsage",
                },
            },
            systemCpuUsage: {
                serializedName: "systemCpuUsage",
                xmlName: "systemCpuUsage",
                type: {
                    name: "Number",
                },
            },
            onlineCpuCount: {
                serializedName: "onlineCpuCount",
                xmlName: "onlineCpuCount",
                type: {
                    name: "Number",
                },
            },
            throttlingData: {
                serializedName: "throttlingData",
                xmlName: "throttlingData",
                type: {
                    name: "Composite",
                    className: "ContainerThrottlingData",
                },
            },
        },
    },
};
const ContainerCpuUsage = {
    serializedName: "ContainerCpuUsage",
    type: {
        name: "Composite",
        className: "ContainerCpuUsage",
        modelProperties: {
            totalUsage: {
                serializedName: "totalUsage",
                xmlName: "totalUsage",
                type: {
                    name: "Number",
                },
            },
            perCpuUsage: {
                serializedName: "perCpuUsage",
                xmlName: "perCpuUsage",
                xmlElementName: "ArrayItemschema",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number",
                        },
                    },
                },
            },
            kernelModeUsage: {
                serializedName: "kernelModeUsage",
                xmlName: "kernelModeUsage",
                type: {
                    name: "Number",
                },
            },
            userModeUsage: {
                serializedName: "userModeUsage",
                xmlName: "userModeUsage",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ContainerThrottlingData = {
    serializedName: "ContainerThrottlingData",
    type: {
        name: "Composite",
        className: "ContainerThrottlingData",
        modelProperties: {
            periods: {
                serializedName: "periods",
                xmlName: "periods",
                type: {
                    name: "Number",
                },
            },
            throttledPeriods: {
                serializedName: "throttledPeriods",
                xmlName: "throttledPeriods",
                type: {
                    name: "Number",
                },
            },
            throttledTime: {
                serializedName: "throttledTime",
                xmlName: "throttledTime",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ContainerMemoryStatistics = {
    serializedName: "ContainerMemoryStatistics",
    type: {
        name: "Composite",
        className: "ContainerMemoryStatistics",
        modelProperties: {
            usage: {
                serializedName: "usage",
                xmlName: "usage",
                type: {
                    name: "Number",
                },
            },
            maxUsage: {
                serializedName: "maxUsage",
                xmlName: "maxUsage",
                type: {
                    name: "Number",
                },
            },
            limit: {
                serializedName: "limit",
                xmlName: "limit",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ContainerNetworkInterfaceStatistics = {
    serializedName: "ContainerNetworkInterfaceStatistics",
    type: {
        name: "Composite",
        className: "ContainerNetworkInterfaceStatistics",
        modelProperties: {
            rxBytes: {
                serializedName: "rxBytes",
                xmlName: "rxBytes",
                type: {
                    name: "Number",
                },
            },
            rxPackets: {
                serializedName: "rxPackets",
                xmlName: "rxPackets",
                type: {
                    name: "Number",
                },
            },
            rxErrors: {
                serializedName: "rxErrors",
                xmlName: "rxErrors",
                type: {
                    name: "Number",
                },
            },
            rxDropped: {
                serializedName: "rxDropped",
                xmlName: "rxDropped",
                type: {
                    name: "Number",
                },
            },
            txBytes: {
                serializedName: "txBytes",
                xmlName: "txBytes",
                type: {
                    name: "Number",
                },
            },
            txPackets: {
                serializedName: "txPackets",
                xmlName: "txPackets",
                type: {
                    name: "Number",
                },
            },
            txErrors: {
                serializedName: "txErrors",
                xmlName: "txErrors",
                type: {
                    name: "Number",
                },
            },
            txDropped: {
                serializedName: "txDropped",
                xmlName: "txDropped",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ProcessInfoCollection = {
    serializedName: "ProcessInfoCollection",
    type: {
        name: "Composite",
        className: "ProcessInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ProcessInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessInfo",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ProcessModuleInfoCollection = {
    serializedName: "ProcessModuleInfoCollection",
    type: {
        name: "Composite",
        className: "ProcessModuleInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ProcessModuleInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessModuleInfo",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ProcessThreadInfoCollection = {
    serializedName: "ProcessThreadInfoCollection",
    type: {
        name: "Composite",
        className: "ProcessThreadInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "ProcessThreadInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessThreadInfo",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SiteCloneability = {
    serializedName: "SiteCloneability",
    type: {
        name: "Composite",
        className: "SiteCloneability",
        modelProperties: {
            result: {
                serializedName: "result",
                xmlName: "result",
                type: {
                    name: "Enum",
                    allowedValues: ["Cloneable", "PartiallyCloneable", "NotCloneable"],
                },
            },
            blockingFeatures: {
                serializedName: "blockingFeatures",
                xmlName: "blockingFeatures",
                xmlElementName: "SiteCloneabilityCriterion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteCloneabilityCriterion",
                        },
                    },
                },
            },
            unsupportedFeatures: {
                serializedName: "unsupportedFeatures",
                xmlName: "unsupportedFeatures",
                xmlElementName: "SiteCloneabilityCriterion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteCloneabilityCriterion",
                        },
                    },
                },
            },
            blockingCharacteristics: {
                serializedName: "blockingCharacteristics",
                xmlName: "blockingCharacteristics",
                xmlElementName: "SiteCloneabilityCriterion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteCloneabilityCriterion",
                        },
                    },
                },
            },
        },
    },
};
const SiteCloneabilityCriterion = {
    serializedName: "SiteCloneabilityCriterion",
    type: {
        name: "Composite",
        className: "SiteCloneabilityCriterion",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const NetworkTrace = {
    serializedName: "NetworkTrace",
    type: {
        name: "Composite",
        className: "NetworkTrace",
        modelProperties: {
            path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String",
                },
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PerfMonCounterCollection = {
    serializedName: "PerfMonCounterCollection",
    type: {
        name: "Composite",
        className: "PerfMonCounterCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "PerfMonResponse",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PerfMonResponse",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PerfMonResponse = {
    serializedName: "PerfMonResponse",
    type: {
        name: "Composite",
        className: "PerfMonResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
            data: {
                serializedName: "data",
                xmlName: "data",
                type: {
                    name: "Composite",
                    className: "PerfMonSet",
                },
            },
        },
    },
};
const PerfMonSet = {
    serializedName: "PerfMonSet",
    type: {
        name: "Composite",
        className: "PerfMonSet",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime",
                },
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime",
                },
            },
            timeGrain: {
                serializedName: "timeGrain",
                xmlName: "timeGrain",
                type: {
                    name: "String",
                },
            },
            values: {
                serializedName: "values",
                xmlName: "values",
                xmlElementName: "PerfMonSample",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PerfMonSample",
                        },
                    },
                },
            },
        },
    },
};
const PerfMonSample = {
    serializedName: "PerfMonSample",
    type: {
        name: "Composite",
        className: "PerfMonSample",
        modelProperties: {
            time: {
                serializedName: "time",
                xmlName: "time",
                type: {
                    name: "DateTime",
                },
            },
            instanceName: {
                serializedName: "instanceName",
                xmlName: "instanceName",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const PrivateAccessVirtualNetwork = {
    serializedName: "PrivateAccessVirtualNetwork",
    type: {
        name: "Composite",
        className: "PrivateAccessVirtualNetwork",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            key: {
                serializedName: "key",
                xmlName: "key",
                type: {
                    name: "Number",
                },
            },
            resourceId: {
                serializedName: "resourceId",
                xmlName: "resourceId",
                type: {
                    name: "String",
                },
            },
            subnets: {
                serializedName: "subnets",
                xmlName: "subnets",
                xmlElementName: "PrivateAccessSubnet",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateAccessSubnet",
                        },
                    },
                },
            },
        },
    },
};
const PrivateAccessSubnet = {
    serializedName: "PrivateAccessSubnet",
    type: {
        name: "Composite",
        className: "PrivateAccessSubnet",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            key: {
                serializedName: "key",
                xmlName: "key",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const PublicCertificateCollection = {
    serializedName: "PublicCertificateCollection",
    type: {
        name: "Composite",
        className: "PublicCertificateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "PublicCertificate",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PublicCertificate",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CsmPublishingProfileOptions = {
    serializedName: "CsmPublishingProfileOptions",
    type: {
        name: "Composite",
        className: "CsmPublishingProfileOptions",
        modelProperties: {
            format: {
                serializedName: "format",
                xmlName: "format",
                type: {
                    name: "String",
                },
            },
            includeDisasterRecoveryEndpoints: {
                serializedName: "includeDisasterRecoveryEndpoints",
                xmlName: "includeDisasterRecoveryEndpoints",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const SnapshotRecoverySource = {
    serializedName: "SnapshotRecoverySource",
    type: {
        name: "Composite",
        className: "SnapshotRecoverySource",
        modelProperties: {
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String",
                },
            },
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SiteContainerCollection = {
    serializedName: "SiteContainerCollection",
    type: {
        name: "Composite",
        className: "SiteContainerCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SiteContainer",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteContainer",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const VolumeMount = {
    serializedName: "VolumeMount",
    type: {
        name: "Composite",
        className: "VolumeMount",
        modelProperties: {
            volumeSubPath: {
                serializedName: "volumeSubPath",
                required: true,
                xmlName: "volumeSubPath",
                type: {
                    name: "String",
                },
            },
            containerMountPath: {
                serializedName: "containerMountPath",
                required: true,
                xmlName: "containerMountPath",
                type: {
                    name: "String",
                },
            },
            data: {
                serializedName: "data",
                xmlName: "data",
                type: {
                    name: "String",
                },
            },
            readOnly: {
                serializedName: "readOnly",
                xmlName: "readOnly",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const EnvironmentVariable = {
    serializedName: "EnvironmentVariable",
    type: {
        name: "Composite",
        className: "EnvironmentVariable",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SiteExtensionInfoCollection = {
    serializedName: "SiteExtensionInfoCollection",
    type: {
        name: "Composite",
        className: "SiteExtensionInfoCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SiteExtensionInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteExtensionInfo",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SlotDifferenceCollection = {
    serializedName: "SlotDifferenceCollection",
    type: {
        name: "Composite",
        className: "SlotDifferenceCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "SlotDifference",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SlotDifference",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SnapshotCollection = {
    serializedName: "SnapshotCollection",
    type: {
        name: "Composite",
        className: "SnapshotCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "Snapshot",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Snapshot",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const GitHubActionConfiguration = {
    serializedName: "GitHubActionConfiguration",
    type: {
        name: "Composite",
        className: "GitHubActionConfiguration",
        modelProperties: {
            codeConfiguration: {
                serializedName: "codeConfiguration",
                xmlName: "codeConfiguration",
                type: {
                    name: "Composite",
                    className: "GitHubActionCodeConfiguration",
                },
            },
            containerConfiguration: {
                serializedName: "containerConfiguration",
                xmlName: "containerConfiguration",
                type: {
                    name: "Composite",
                    className: "GitHubActionContainerConfiguration",
                },
            },
            isLinux: {
                serializedName: "isLinux",
                xmlName: "isLinux",
                type: {
                    name: "Boolean",
                },
            },
            generateWorkflowFile: {
                serializedName: "generateWorkflowFile",
                xmlName: "generateWorkflowFile",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const GitHubActionCodeConfiguration = {
    serializedName: "GitHubActionCodeConfiguration",
    type: {
        name: "Composite",
        className: "GitHubActionCodeConfiguration",
        modelProperties: {
            runtimeStack: {
                serializedName: "runtimeStack",
                xmlName: "runtimeStack",
                type: {
                    name: "String",
                },
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                xmlName: "runtimeVersion",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const GitHubActionContainerConfiguration = {
    serializedName: "GitHubActionContainerConfiguration",
    type: {
        name: "Composite",
        className: "GitHubActionContainerConfiguration",
        modelProperties: {
            serverUrl: {
                serializedName: "serverUrl",
                xmlName: "serverUrl",
                type: {
                    name: "String",
                },
            },
            imageName: {
                serializedName: "imageName",
                xmlName: "imageName",
                type: {
                    name: "String",
                },
            },
            username: {
                serializedName: "username",
                xmlName: "username",
                type: {
                    name: "String",
                },
            },
            password: {
                serializedName: "password",
                xmlName: "password",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TriggeredWebJobCollection = {
    serializedName: "TriggeredWebJobCollection",
    type: {
        name: "Composite",
        className: "TriggeredWebJobCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "TriggeredWebJob",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TriggeredWebJob",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TriggeredJobRun = {
    serializedName: "TriggeredJobRun",
    type: {
        name: "Composite",
        className: "TriggeredJobRun",
        modelProperties: {
            webJobId: {
                serializedName: "web_job_id",
                xmlName: "web_job_id",
                type: {
                    name: "String",
                },
            },
            webJobName: {
                serializedName: "web_job_name",
                xmlName: "web_job_name",
                type: {
                    name: "String",
                },
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "Enum",
                    allowedValues: ["Success", "Failed", "Error"],
                },
            },
            startTime: {
                serializedName: "start_time",
                xmlName: "start_time",
                type: {
                    name: "DateTime",
                },
            },
            endTime: {
                serializedName: "end_time",
                xmlName: "end_time",
                type: {
                    name: "DateTime",
                },
            },
            duration: {
                serializedName: "duration",
                xmlName: "duration",
                type: {
                    name: "String",
                },
            },
            outputUrl: {
                serializedName: "output_url",
                xmlName: "output_url",
                type: {
                    name: "String",
                },
            },
            errorUrl: {
                serializedName: "error_url",
                xmlName: "error_url",
                type: {
                    name: "String",
                },
            },
            url: {
                serializedName: "url",
                xmlName: "url",
                type: {
                    name: "String",
                },
            },
            jobName: {
                serializedName: "job_name",
                xmlName: "job_name",
                type: {
                    name: "String",
                },
            },
            trigger: {
                serializedName: "trigger",
                xmlName: "trigger",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TriggeredJobHistoryCollection = {
    serializedName: "TriggeredJobHistoryCollection",
    type: {
        name: "Composite",
        className: "TriggeredJobHistoryCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "TriggeredJobHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TriggeredJobHistory",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WebJobCollection = {
    serializedName: "WebJobCollection",
    type: {
        name: "Composite",
        className: "WebJobCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "WebJob",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebJob",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowArtifacts = {
    serializedName: "WorkflowArtifacts",
    type: {
        name: "Composite",
        className: "WorkflowArtifacts",
        modelProperties: {
            appSettings: {
                serializedName: "appSettings",
                xmlName: "appSettings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
            files: {
                serializedName: "files",
                xmlName: "files",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } },
                    },
                },
            },
            filesToDelete: {
                serializedName: "filesToDelete",
                xmlName: "filesToDelete",
                xmlElementName: "WorkflowArtifactsFilesToDeleteItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const WorkflowEnvelopeCollection = {
    serializedName: "WorkflowEnvelopeCollection",
    type: {
        name: "Composite",
        className: "WorkflowEnvelopeCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                xmlName: "value",
                xmlElementName: "WorkflowEnvelope",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowEnvelope",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowEnvelope = {
    serializedName: "WorkflowEnvelope",
    type: {
        name: "Composite",
        className: "WorkflowEnvelope",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            kind: {
                serializedName: "kind",
                xmlName: "kind",
                type: {
                    name: "String",
                },
            },
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String",
                },
            },
            properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "WorkflowEnvelopeProperties",
                },
            },
        },
    },
};
const WorkflowEnvelopeProperties = {
    serializedName: "WorkflowEnvelopeProperties",
    type: {
        name: "Composite",
        className: "WorkflowEnvelopeProperties",
        modelProperties: {
            files: {
                serializedName: "files",
                xmlName: "files",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } },
                    },
                },
            },
            flowState: {
                serializedName: "flowState",
                xmlName: "flowState",
                type: {
                    name: "String",
                },
            },
            health: {
                serializedName: "health",
                xmlName: "health",
                type: {
                    name: "Composite",
                    className: "WorkflowHealth",
                },
            },
        },
    },
};
const WorkflowHealth = {
    serializedName: "WorkflowHealth",
    type: {
        name: "Composite",
        className: "WorkflowHealth",
        modelProperties: {
            state: {
                serializedName: "state",
                required: true,
                xmlName: "state",
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "Healthy", "Unhealthy", "Unknown"],
                },
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorEntity",
                },
            },
        },
    },
};
const RegenerateActionParameter = {
    serializedName: "RegenerateActionParameter",
    type: {
        name: "Composite",
        className: "RegenerateActionParameter",
        modelProperties: {
            keyType: {
                serializedName: "keyType",
                xmlName: "keyType",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ErrorResponse = {
    serializedName: "ErrorResponse",
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorProperties",
                },
            },
        },
    },
};
const ErrorProperties = {
    serializedName: "ErrorProperties",
    type: {
        name: "Composite",
        className: "ErrorProperties",
        modelProperties: {
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                xmlName: "message",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowRunListResult = {
    serializedName: "WorkflowRunListResult",
    type: {
        name: "Composite",
        className: "WorkflowRunListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowRun",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowRun",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Correlation = {
    serializedName: "Correlation",
    type: {
        name: "Composite",
        className: "Correlation",
        modelProperties: {
            clientTrackingId: {
                serializedName: "clientTrackingId",
                xmlName: "clientTrackingId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ResourceReference = {
    serializedName: "ResourceReference",
    type: {
        name: "Composite",
        className: "ResourceReference",
        modelProperties: {
            id: {
                serializedName: "id",
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowRunTrigger = {
    serializedName: "WorkflowRunTrigger",
    type: {
        name: "Composite",
        className: "WorkflowRunTrigger",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            inputs: {
                serializedName: "inputs",
                readOnly: true,
                xmlName: "inputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
            inputsLink: {
                serializedName: "inputsLink",
                xmlName: "inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            },
            outputs: {
                serializedName: "outputs",
                readOnly: true,
                xmlName: "outputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
            outputsLink: {
                serializedName: "outputsLink",
                xmlName: "outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            },
            scheduledTime: {
                serializedName: "scheduledTime",
                readOnly: true,
                xmlName: "scheduledTime",
                type: {
                    name: "DateTime",
                },
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                xmlName: "startTime",
                type: {
                    name: "DateTime",
                },
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                xmlName: "endTime",
                type: {
                    name: "DateTime",
                },
            },
            trackingId: {
                serializedName: "trackingId",
                readOnly: true,
                xmlName: "trackingId",
                type: {
                    name: "String",
                },
            },
            correlation: {
                serializedName: "correlation",
                xmlName: "correlation",
                type: {
                    name: "Composite",
                    className: "Correlation",
                },
            },
            code: {
                serializedName: "code",
                readOnly: true,
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            status: {
                serializedName: "status",
                readOnly: true,
                xmlName: "status",
                type: {
                    name: "String",
                },
            },
            error: {
                serializedName: "error",
                readOnly: true,
                xmlName: "error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
            trackedProperties: {
                serializedName: "trackedProperties",
                readOnly: true,
                xmlName: "trackedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
        },
    },
};
const ContentLink = {
    serializedName: "ContentLink",
    type: {
        name: "Composite",
        className: "ContentLink",
        modelProperties: {
            uri: {
                serializedName: "uri",
                xmlName: "uri",
                type: {
                    name: "String",
                },
            },
            contentVersion: {
                serializedName: "contentVersion",
                readOnly: true,
                xmlName: "contentVersion",
                type: {
                    name: "String",
                },
            },
            contentSize: {
                serializedName: "contentSize",
                readOnly: true,
                xmlName: "contentSize",
                type: {
                    name: "Number",
                },
            },
            contentHash: {
                serializedName: "contentHash",
                xmlName: "contentHash",
                type: {
                    name: "Composite",
                    className: "ContentHash",
                },
            },
            metadata: {
                serializedName: "metadata",
                readOnly: true,
                xmlName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
        },
    },
};
const ContentHash = {
    serializedName: "ContentHash",
    type: {
        name: "Composite",
        className: "ContentHash",
        modelProperties: {
            algorithm: {
                serializedName: "algorithm",
                xmlName: "algorithm",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowParameter = {
    serializedName: "WorkflowParameter",
    type: {
        name: "Composite",
        className: "WorkflowParameter",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
            metadata: {
                serializedName: "metadata",
                xmlName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
            description: {
                serializedName: "description",
                xmlName: "description",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SubResource = {
    serializedName: "SubResource",
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowRunActionListResult = {
    serializedName: "WorkflowRunActionListResult",
    type: {
        name: "Composite",
        className: "WorkflowRunActionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowRunAction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowRunAction",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RunCorrelation = {
    serializedName: "RunCorrelation",
    type: {
        name: "Composite",
        className: "RunCorrelation",
        modelProperties: {
            clientTrackingId: {
                serializedName: "clientTrackingId",
                xmlName: "clientTrackingId",
                type: {
                    name: "String",
                },
            },
            clientKeywords: {
                serializedName: "clientKeywords",
                xmlName: "clientKeywords",
                xmlElementName: "RunCorrelationClientKeywordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const RetryHistory = {
    serializedName: "RetryHistory",
    type: {
        name: "Composite",
        className: "RetryHistory",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime",
                },
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime",
                },
            },
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            clientRequestId: {
                serializedName: "clientRequestId",
                xmlName: "clientRequestId",
                type: {
                    name: "String",
                },
            },
            serviceRequestId: {
                serializedName: "serviceRequestId",
                xmlName: "serviceRequestId",
                type: {
                    name: "String",
                },
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse",
                },
            },
        },
    },
};
const ExpressionTraces = {
    serializedName: "ExpressionTraces",
    type: {
        name: "Composite",
        className: "ExpressionTraces",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "any",
                },
            },
            inputs: {
                serializedName: "inputs",
                xmlName: "inputs",
                xmlElementName: "ExpressionRoot",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressionRoot",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Expression = {
    serializedName: "Expression",
    type: {
        name: "Composite",
        className: "Expression",
        modelProperties: {
            text: {
                serializedName: "text",
                xmlName: "text",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "any",
                },
            },
            subexpressions: {
                serializedName: "subexpressions",
                xmlName: "subexpressions",
                xmlElementName: "Expression",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Expression",
                        },
                    },
                },
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "Composite",
                    className: "AzureResourceErrorInfo",
                },
            },
        },
    },
};
const ErrorInfo = {
    serializedName: "ErrorInfo",
    type: {
        name: "Composite",
        className: "ErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowRunActionRepetitionDefinitionCollection = {
    serializedName: "WorkflowRunActionRepetitionDefinitionCollection",
    type: {
        name: "Composite",
        className: "WorkflowRunActionRepetitionDefinitionCollection",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowRunActionRepetitionDefinition",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowRunActionRepetitionDefinition",
                        },
                    },
                },
            },
        },
    },
};
const RepetitionIndex = {
    serializedName: "RepetitionIndex",
    type: {
        name: "Composite",
        className: "RepetitionIndex",
        modelProperties: {
            scopeName: {
                serializedName: "scopeName",
                xmlName: "scopeName",
                type: {
                    name: "String",
                },
            },
            itemIndex: {
                serializedName: "itemIndex",
                required: true,
                xmlName: "itemIndex",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const OperationResultProperties = {
    serializedName: "OperationResultProperties",
    type: {
        name: "Composite",
        className: "OperationResultProperties",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime",
                },
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime",
                },
            },
            correlation: {
                serializedName: "correlation",
                xmlName: "correlation",
                type: {
                    name: "Composite",
                    className: "RunActionCorrelation",
                },
            },
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String",
                },
            },
            code: {
                serializedName: "code",
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            error: {
                serializedName: "error",
                xmlName: "error",
                type: {
                    name: "any",
                },
            },
        },
    },
};
const WorkflowResource = {
    serializedName: "WorkflowResource",
    type: {
        name: "Composite",
        className: "WorkflowResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                xmlName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String",
                },
            },
            tags: {
                serializedName: "tags",
                xmlName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const RequestHistoryListResult = {
    serializedName: "RequestHistoryListResult",
    type: {
        name: "Composite",
        className: "RequestHistoryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "RequestHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RequestHistory",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RequestHistoryProperties = {
    serializedName: "RequestHistoryProperties",
    type: {
        name: "Composite",
        className: "RequestHistoryProperties",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "DateTime",
                },
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "DateTime",
                },
            },
            request: {
                serializedName: "request",
                xmlName: "request",
                type: {
                    name: "Composite",
                    className: "Request",
                },
            },
            response: {
                serializedName: "response",
                xmlName: "response",
                type: {
                    name: "Composite",
                    className: "Response",
                },
            },
        },
    },
};
const Request = {
    serializedName: "Request",
    type: {
        name: "Composite",
        className: "Request",
        modelProperties: {
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
            uri: {
                serializedName: "uri",
                xmlName: "uri",
                type: {
                    name: "String",
                },
            },
            method: {
                serializedName: "method",
                xmlName: "method",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Response = {
    serializedName: "Response",
    type: {
        name: "Composite",
        className: "Response",
        modelProperties: {
            headers: {
                serializedName: "headers",
                xmlName: "headers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
            statusCode: {
                serializedName: "statusCode",
                xmlName: "statusCode",
                type: {
                    name: "Number",
                },
            },
            bodyLink: {
                serializedName: "bodyLink",
                xmlName: "bodyLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            },
        },
    },
};
const WorkflowTriggerListResult = {
    serializedName: "WorkflowTriggerListResult",
    type: {
        name: "Composite",
        className: "WorkflowTriggerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowTrigger",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowTrigger",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowTriggerRecurrence = {
    serializedName: "WorkflowTriggerRecurrence",
    type: {
        name: "Composite",
        className: "WorkflowTriggerRecurrence",
        modelProperties: {
            frequency: {
                serializedName: "frequency",
                xmlName: "frequency",
                type: {
                    name: "String",
                },
            },
            interval: {
                serializedName: "interval",
                xmlName: "interval",
                type: {
                    name: "Number",
                },
            },
            startTime: {
                serializedName: "startTime",
                xmlName: "startTime",
                type: {
                    name: "String",
                },
            },
            endTime: {
                serializedName: "endTime",
                xmlName: "endTime",
                type: {
                    name: "String",
                },
            },
            timeZone: {
                serializedName: "timeZone",
                xmlName: "timeZone",
                type: {
                    name: "String",
                },
            },
            schedule: {
                serializedName: "schedule",
                xmlName: "schedule",
                type: {
                    name: "Composite",
                    className: "RecurrenceSchedule",
                },
            },
        },
    },
};
const RecurrenceSchedule = {
    serializedName: "RecurrenceSchedule",
    type: {
        name: "Composite",
        className: "RecurrenceSchedule",
        modelProperties: {
            minutes: {
                serializedName: "minutes",
                xmlName: "minutes",
                xmlElementName: "ArrayItemschema",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number",
                        },
                    },
                },
            },
            hours: {
                serializedName: "hours",
                xmlName: "hours",
                xmlElementName: "ArrayItemschema",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number",
                        },
                    },
                },
            },
            weekDays: {
                serializedName: "weekDays",
                xmlName: "weekDays",
                xmlElementName: "DaysOfWeek",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Sunday",
                                "Monday",
                                "Tuesday",
                                "Wednesday",
                                "Thursday",
                                "Friday",
                                "Saturday",
                            ],
                        },
                    },
                },
            },
            monthDays: {
                serializedName: "monthDays",
                xmlName: "monthDays",
                xmlElementName: "ArrayItemschema",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number",
                        },
                    },
                },
            },
            monthlyOccurrences: {
                serializedName: "monthlyOccurrences",
                xmlName: "monthlyOccurrences",
                xmlElementName: "RecurrenceScheduleOccurrence",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecurrenceScheduleOccurrence",
                        },
                    },
                },
            },
        },
    },
};
const RecurrenceScheduleOccurrence = {
    serializedName: "RecurrenceScheduleOccurrence",
    type: {
        name: "Composite",
        className: "RecurrenceScheduleOccurrence",
        modelProperties: {
            day: {
                serializedName: "day",
                xmlName: "day",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Sunday",
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday",
                    ],
                },
            },
            occurrence: {
                serializedName: "occurrence",
                xmlName: "occurrence",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const WorkflowTriggerHistoryListResult = {
    serializedName: "WorkflowTriggerHistoryListResult",
    type: {
        name: "Composite",
        className: "WorkflowTriggerHistoryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowTriggerHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowTriggerHistory",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowTriggerCallbackUrl = {
    serializedName: "WorkflowTriggerCallbackUrl",
    type: {
        name: "Composite",
        className: "WorkflowTriggerCallbackUrl",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
            method: {
                serializedName: "method",
                readOnly: true,
                xmlName: "method",
                type: {
                    name: "String",
                },
            },
            basePath: {
                serializedName: "basePath",
                readOnly: true,
                xmlName: "basePath",
                type: {
                    name: "String",
                },
            },
            relativePath: {
                serializedName: "relativePath",
                readOnly: true,
                xmlName: "relativePath",
                type: {
                    name: "String",
                },
            },
            relativePathParameters: {
                serializedName: "relativePathParameters",
                xmlName: "relativePathParameters",
                xmlElementName: "WorkflowTriggerCallbackUrlRelativePathParametersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            queries: {
                serializedName: "queries",
                xmlName: "queries",
                type: {
                    name: "Composite",
                    className: "WorkflowTriggerListCallbackUrlQueries",
                },
            },
        },
    },
};
const WorkflowTriggerListCallbackUrlQueries = {
    serializedName: "WorkflowTriggerListCallbackUrlQueries",
    type: {
        name: "Composite",
        className: "WorkflowTriggerListCallbackUrlQueries",
        modelProperties: {
            apiVersion: {
                serializedName: "api-version",
                xmlName: "api-version",
                type: {
                    name: "String",
                },
            },
            sp: {
                serializedName: "sp",
                xmlName: "sp",
                type: {
                    name: "String",
                },
            },
            sv: {
                serializedName: "sv",
                xmlName: "sv",
                type: {
                    name: "String",
                },
            },
            sig: {
                serializedName: "sig",
                xmlName: "sig",
                type: {
                    name: "String",
                },
            },
            se: {
                serializedName: "se",
                xmlName: "se",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const JsonSchema = {
    serializedName: "JsonSchema",
    type: {
        name: "Composite",
        className: "JsonSchema",
        modelProperties: {
            title: {
                serializedName: "title",
                xmlName: "title",
                type: {
                    name: "String",
                },
            },
            content: {
                serializedName: "content",
                xmlName: "content",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FlowEndpointsConfiguration = {
    serializedName: "FlowEndpointsConfiguration",
    type: {
        name: "Composite",
        className: "FlowEndpointsConfiguration",
        modelProperties: {
            workflow: {
                serializedName: "workflow",
                xmlName: "workflow",
                type: {
                    name: "Composite",
                    className: "FlowEndpoints",
                },
            },
            connector: {
                serializedName: "connector",
                xmlName: "connector",
                type: {
                    name: "Composite",
                    className: "FlowEndpoints",
                },
            },
        },
    },
};
const FlowEndpoints = {
    serializedName: "FlowEndpoints",
    type: {
        name: "Composite",
        className: "FlowEndpoints",
        modelProperties: {
            outgoingIpAddresses: {
                serializedName: "outgoingIpAddresses",
                xmlName: "outgoingIpAddresses",
                xmlElementName: "IpAddress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddress",
                        },
                    },
                },
            },
            accessEndpointIpAddresses: {
                serializedName: "accessEndpointIpAddresses",
                xmlName: "accessEndpointIpAddresses",
                xmlElementName: "IpAddress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddress",
                        },
                    },
                },
            },
        },
    },
};
const IpAddress = {
    serializedName: "IpAddress",
    type: {
        name: "Composite",
        className: "IpAddress",
        modelProperties: {
            address: {
                serializedName: "address",
                xmlName: "address",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const FlowAccessControlConfiguration = {
    serializedName: "FlowAccessControlConfiguration",
    type: {
        name: "Composite",
        className: "FlowAccessControlConfiguration",
        modelProperties: {
            triggers: {
                serializedName: "triggers",
                xmlName: "triggers",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy",
                },
            },
            contents: {
                serializedName: "contents",
                xmlName: "contents",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy",
                },
            },
            actions: {
                serializedName: "actions",
                xmlName: "actions",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy",
                },
            },
            workflowManagement: {
                serializedName: "workflowManagement",
                xmlName: "workflowManagement",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy",
                },
            },
        },
    },
};
const FlowAccessControlConfigurationPolicy = {
    serializedName: "FlowAccessControlConfigurationPolicy",
    type: {
        name: "Composite",
        className: "FlowAccessControlConfigurationPolicy",
        modelProperties: {
            allowedCallerIpAddresses: {
                serializedName: "allowedCallerIpAddresses",
                xmlName: "allowedCallerIpAddresses",
                xmlElementName: "IpAddressRange",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddressRange",
                        },
                    },
                },
            },
            openAuthenticationPolicies: {
                serializedName: "openAuthenticationPolicies",
                xmlName: "openAuthenticationPolicies",
                type: {
                    name: "Composite",
                    className: "OpenAuthenticationAccessPolicies",
                },
            },
        },
    },
};
const IpAddressRange = {
    serializedName: "IpAddressRange",
    type: {
        name: "Composite",
        className: "IpAddressRange",
        modelProperties: {
            addressRange: {
                serializedName: "addressRange",
                xmlName: "addressRange",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const OpenAuthenticationAccessPolicies = {
    serializedName: "OpenAuthenticationAccessPolicies",
    type: {
        name: "Composite",
        className: "OpenAuthenticationAccessPolicies",
        modelProperties: {
            policies: {
                serializedName: "policies",
                xmlName: "policies",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "OpenAuthenticationAccessPolicy",
                        },
                    },
                },
            },
        },
    },
};
const OpenAuthenticationAccessPolicy = {
    serializedName: "OpenAuthenticationAccessPolicy",
    type: {
        name: "Composite",
        className: "OpenAuthenticationAccessPolicy",
        modelProperties: {
            type: {
                serializedName: "type",
                xmlName: "type",
                type: {
                    name: "String",
                },
            },
            claims: {
                serializedName: "claims",
                xmlName: "claims",
                xmlElementName: "OpenAuthenticationPolicyClaim",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OpenAuthenticationPolicyClaim",
                        },
                    },
                },
            },
        },
    },
};
const OpenAuthenticationPolicyClaim = {
    serializedName: "OpenAuthenticationPolicyClaim",
    type: {
        name: "Composite",
        className: "OpenAuthenticationPolicyClaim",
        modelProperties: {
            name: {
                serializedName: "name",
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                xmlName: "value",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowSku = {
    serializedName: "WorkflowSku",
    type: {
        name: "Composite",
        className: "WorkflowSku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            },
            plan: {
                serializedName: "plan",
                xmlName: "plan",
                type: {
                    name: "Composite",
                    className: "ResourceReference",
                },
            },
        },
    },
};
const WorkflowVersionListResult = {
    serializedName: "WorkflowVersionListResult",
    type: {
        name: "Composite",
        className: "WorkflowVersionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "WorkflowVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowVersion",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AppserviceGithubToken = {
    serializedName: "AppserviceGithubToken",
    type: {
        name: "Composite",
        className: "AppserviceGithubToken",
        modelProperties: {
            accessToken: {
                serializedName: "accessToken",
                xmlName: "accessToken",
                type: {
                    name: "String",
                },
            },
            scope: {
                serializedName: "scope",
                xmlName: "scope",
                type: {
                    name: "String",
                },
            },
            tokenType: {
                serializedName: "tokenType",
                xmlName: "tokenType",
                type: {
                    name: "String",
                },
            },
            gotToken: {
                serializedName: "gotToken",
                xmlName: "gotToken",
                type: {
                    name: "Boolean",
                },
            },
            errorMessage: {
                serializedName: "errorMessage",
                xmlName: "errorMessage",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AppserviceGithubTokenRequest = {
    serializedName: "AppserviceGithubTokenRequest",
    type: {
        name: "Composite",
        className: "AppserviceGithubTokenRequest",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                xmlName: "code",
                type: {
                    name: "String",
                },
            },
            state: {
                serializedName: "state",
                required: true,
                xmlName: "state",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowFilter = {
    serializedName: "WorkflowFilter",
    type: {
        name: "Composite",
        className: "WorkflowFilter",
        modelProperties: {
            state: {
                serializedName: "state",
                xmlName: "state",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowListResult = {
    serializedName: "WorkflowListResult",
    type: {
        name: "Composite",
        className: "WorkflowListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                xmlName: "value",
                xmlElementName: "Workflow",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Workflow",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                xmlName: "nextLink",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowRunActionFilter = {
    serializedName: "WorkflowRunActionFilter",
    type: {
        name: "Composite",
        className: "WorkflowRunActionFilter",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowRunFilter = {
    serializedName: "WorkflowRunFilter",
    type: {
        name: "Composite",
        className: "WorkflowRunFilter",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowTriggerFilter = {
    serializedName: "WorkflowTriggerFilter",
    type: {
        name: "Composite",
        className: "WorkflowTriggerFilter",
        modelProperties: {
            state: {
                serializedName: "state",
                xmlName: "state",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const WorkflowTriggerHistoryFilter = {
    serializedName: "WorkflowTriggerHistoryFilter",
    type: {
        name: "Composite",
        className: "WorkflowTriggerHistoryFilter",
        modelProperties: {
            status: {
                serializedName: "status",
                xmlName: "status",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AppServiceCertificateOrder = {
    serializedName: "AppServiceCertificateOrder",
    type: {
        name: "Composite",
        className: "AppServiceCertificateOrder",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { certificates: {
                serializedName: "properties.certificates",
                xmlName: "properties.certificates",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AppServiceCertificate" },
                    },
                },
            }, distinguishedName: {
                serializedName: "properties.distinguishedName",
                xmlName: "properties.distinguishedName",
                type: {
                    name: "String",
                },
            }, domainVerificationToken: {
                serializedName: "properties.domainVerificationToken",
                readOnly: true,
                xmlName: "properties.domainVerificationToken",
                type: {
                    name: "String",
                },
            }, validityInYears: {
                defaultValue: 1,
                serializedName: "properties.validityInYears",
                xmlName: "properties.validityInYears",
                type: {
                    name: "Number",
                },
            }, keySize: {
                defaultValue: 2048,
                serializedName: "properties.keySize",
                xmlName: "properties.keySize",
                type: {
                    name: "Number",
                },
            }, productType: {
                serializedName: "properties.productType",
                xmlName: "properties.productType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "StandardDomainValidatedSsl",
                        "StandardDomainValidatedWildCardSsl",
                    ],
                },
            }, autoRenew: {
                defaultValue: true,
                serializedName: "properties.autoRenew",
                xmlName: "properties.autoRenew",
                type: {
                    name: "Boolean",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting",
                    ],
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Pendingissuance",
                        "Issued",
                        "Revoked",
                        "Canceled",
                        "Denied",
                        "Pendingrevocation",
                        "PendingRekey",
                        "Unused",
                        "Expired",
                        "NotSubmitted",
                    ],
                },
            }, signedCertificate: {
                serializedName: "properties.signedCertificate",
                xmlName: "properties.signedCertificate",
                type: {
                    name: "Composite",
                    className: "CertificateDetails",
                },
            }, csr: {
                serializedName: "properties.csr",
                xmlName: "properties.csr",
                type: {
                    name: "String",
                },
            }, intermediate: {
                serializedName: "properties.intermediate",
                xmlName: "properties.intermediate",
                type: {
                    name: "Composite",
                    className: "CertificateDetails",
                },
            }, root: {
                serializedName: "properties.root",
                xmlName: "properties.root",
                type: {
                    name: "Composite",
                    className: "CertificateDetails",
                },
            }, serialNumber: {
                serializedName: "properties.serialNumber",
                readOnly: true,
                xmlName: "properties.serialNumber",
                type: {
                    name: "String",
                },
            }, lastCertificateIssuanceTime: {
                serializedName: "properties.lastCertificateIssuanceTime",
                readOnly: true,
                xmlName: "properties.lastCertificateIssuanceTime",
                type: {
                    name: "DateTime",
                },
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                readOnly: true,
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime",
                },
            }, isPrivateKeyExternal: {
                serializedName: "properties.isPrivateKeyExternal",
                readOnly: true,
                xmlName: "properties.isPrivateKeyExternal",
                type: {
                    name: "Boolean",
                },
            }, appServiceCertificateNotRenewableReasons: {
                serializedName: "properties.appServiceCertificateNotRenewableReasons",
                readOnly: true,
                xmlName: "properties.appServiceCertificateNotRenewableReasons",
                xmlElementName: "ResourceNotRenewableReason",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, nextAutoRenewalTimeStamp: {
                serializedName: "properties.nextAutoRenewalTimeStamp",
                readOnly: true,
                xmlName: "properties.nextAutoRenewalTimeStamp",
                type: {
                    name: "DateTime",
                },
            }, contact: {
                serializedName: "properties.contact",
                xmlName: "properties.contact",
                type: {
                    name: "Composite",
                    className: "CertificateOrderContact",
                },
            } }),
    },
};
const AppServiceCertificateResource = {
    serializedName: "AppServiceCertificateResource",
    type: {
        name: "Composite",
        className: "AppServiceCertificateResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { keyVaultId: {
                serializedName: "properties.keyVaultId",
                xmlName: "properties.keyVaultId",
                type: {
                    name: "String",
                },
            }, keyVaultSecretName: {
                serializedName: "properties.keyVaultSecretName",
                xmlName: "properties.keyVaultSecretName",
                type: {
                    name: "String",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown",
                    ],
                },
            } }),
    },
};
const Domain = {
    serializedName: "Domain",
    type: {
        name: "Composite",
        className: "Domain",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { contactAdmin: {
                serializedName: "properties.contactAdmin",
                xmlName: "properties.contactAdmin",
                type: {
                    name: "Composite",
                    className: "Contact",
                },
            }, contactBilling: {
                serializedName: "properties.contactBilling",
                xmlName: "properties.contactBilling",
                type: {
                    name: "Composite",
                    className: "Contact",
                },
            }, contactRegistrant: {
                serializedName: "properties.contactRegistrant",
                xmlName: "properties.contactRegistrant",
                type: {
                    name: "Composite",
                    className: "Contact",
                },
            }, contactTech: {
                serializedName: "properties.contactTech",
                xmlName: "properties.contactTech",
                type: {
                    name: "Composite",
                    className: "Contact",
                },
            }, registrationStatus: {
                serializedName: "properties.registrationStatus",
                readOnly: true,
                xmlName: "properties.registrationStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Active",
                        "Awaiting",
                        "Cancelled",
                        "Confiscated",
                        "Disabled",
                        "Excluded",
                        "Expired",
                        "Failed",
                        "Held",
                        "Locked",
                        "Parked",
                        "Pending",
                        "Reserved",
                        "Reverted",
                        "Suspended",
                        "Transferred",
                        "Unknown",
                        "Unlocked",
                        "Unparked",
                        "Updated",
                        "JsonConverterFailed",
                    ],
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting",
                    ],
                },
            }, nameServers: {
                serializedName: "properties.nameServers",
                readOnly: true,
                xmlName: "properties.nameServers",
                xmlElementName: "DomainPropertiesNameServersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, privacy: {
                serializedName: "properties.privacy",
                xmlName: "properties.privacy",
                type: {
                    name: "Boolean",
                },
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime",
                },
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                readOnly: true,
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime",
                },
            }, lastRenewedTime: {
                serializedName: "properties.lastRenewedTime",
                readOnly: true,
                xmlName: "properties.lastRenewedTime",
                type: {
                    name: "DateTime",
                },
            }, autoRenew: {
                defaultValue: true,
                serializedName: "properties.autoRenew",
                xmlName: "properties.autoRenew",
                type: {
                    name: "Boolean",
                },
            }, readyForDnsRecordManagement: {
                serializedName: "properties.readyForDnsRecordManagement",
                readOnly: true,
                xmlName: "properties.readyForDnsRecordManagement",
                type: {
                    name: "Boolean",
                },
            }, managedHostNames: {
                serializedName: "properties.managedHostNames",
                readOnly: true,
                xmlName: "properties.managedHostNames",
                xmlElementName: "HostName",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostName",
                        },
                    },
                },
            }, consent: {
                serializedName: "properties.consent",
                xmlName: "properties.consent",
                type: {
                    name: "Composite",
                    className: "DomainPurchaseConsent",
                },
            }, domainNotRenewableReasons: {
                serializedName: "properties.domainNotRenewableReasons",
                readOnly: true,
                xmlName: "properties.domainNotRenewableReasons",
                xmlElementName: "ResourceNotRenewableReason",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, dnsType: {
                serializedName: "properties.dnsType",
                xmlName: "properties.dnsType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureDns", "DefaultDomainRegistrarDns"],
                },
            }, dnsZoneId: {
                serializedName: "properties.dnsZoneId",
                xmlName: "properties.dnsZoneId",
                type: {
                    name: "String",
                },
            }, targetDnsType: {
                serializedName: "properties.targetDnsType",
                xmlName: "properties.targetDnsType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureDns", "DefaultDomainRegistrarDns"],
                },
            }, authCode: {
                serializedName: "properties.authCode",
                xmlName: "properties.authCode",
                type: {
                    name: "String",
                },
            } }),
    },
};
const AppServiceEnvironmentResource = {
    serializedName: "AppServiceEnvironmentResource",
    type: {
        name: "Composite",
        className: "AppServiceEnvironmentResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting",
                    ],
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Preparing", "Ready", "Scaling", "Deleting"],
                },
            }, virtualNetwork: {
                serializedName: "properties.virtualNetwork",
                xmlName: "properties.virtualNetwork",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkProfile",
                },
            }, internalLoadBalancingMode: {
                serializedName: "properties.internalLoadBalancingMode",
                xmlName: "properties.internalLoadBalancingMode",
                type: {
                    name: "String",
                },
            }, multiSize: {
                serializedName: "properties.multiSize",
                xmlName: "properties.multiSize",
                type: {
                    name: "String",
                },
            }, multiRoleCount: {
                serializedName: "properties.multiRoleCount",
                readOnly: true,
                xmlName: "properties.multiRoleCount",
                type: {
                    name: "Number",
                },
            }, ipsslAddressCount: {
                serializedName: "properties.ipsslAddressCount",
                xmlName: "properties.ipsslAddressCount",
                type: {
                    name: "Number",
                },
            }, dnsSuffix: {
                serializedName: "properties.dnsSuffix",
                xmlName: "properties.dnsSuffix",
                type: {
                    name: "String",
                },
            }, maximumNumberOfMachines: {
                serializedName: "properties.maximumNumberOfMachines",
                readOnly: true,
                xmlName: "properties.maximumNumberOfMachines",
                type: {
                    name: "Number",
                },
            }, frontEndScaleFactor: {
                serializedName: "properties.frontEndScaleFactor",
                xmlName: "properties.frontEndScaleFactor",
                type: {
                    name: "Number",
                },
            }, suspended: {
                serializedName: "properties.suspended",
                readOnly: true,
                xmlName: "properties.suspended",
                type: {
                    name: "Boolean",
                },
            }, clusterSettings: {
                serializedName: "properties.clusterSettings",
                xmlName: "properties.clusterSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair",
                        },
                    },
                },
            }, userWhitelistedIpRanges: {
                serializedName: "properties.userWhitelistedIpRanges",
                xmlName: "properties.userWhitelistedIpRanges",
                xmlElementName: "AppServiceEnvironmentUserWhitelistedIpRangesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, hasLinuxWorkers: {
                serializedName: "properties.hasLinuxWorkers",
                readOnly: true,
                xmlName: "properties.hasLinuxWorkers",
                type: {
                    name: "Boolean",
                },
            }, upgradePreference: {
                defaultValue: "None",
                serializedName: "properties.upgradePreference",
                xmlName: "properties.upgradePreference",
                type: {
                    name: "String",
                },
            }, dedicatedHostCount: {
                serializedName: "properties.dedicatedHostCount",
                xmlName: "properties.dedicatedHostCount",
                type: {
                    name: "Number",
                },
            }, zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                xmlName: "properties.zoneRedundant",
                type: {
                    name: "Boolean",
                },
            }, customDnsSuffixConfiguration: {
                serializedName: "properties.customDnsSuffixConfiguration",
                xmlName: "properties.customDnsSuffixConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomDnsSuffixConfiguration",
                },
            }, networkingConfiguration: {
                serializedName: "properties.networkingConfiguration",
                xmlName: "properties.networkingConfiguration",
                type: {
                    name: "Composite",
                    className: "AseV3NetworkingConfiguration",
                },
            }, upgradeAvailability: {
                serializedName: "properties.upgradeAvailability",
                readOnly: true,
                xmlName: "properties.upgradeAvailability",
                type: {
                    name: "String",
                },
            } }),
    },
};
const Site = {
    serializedName: "Site",
    type: {
        name: "Composite",
        className: "Site",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity",
                },
            }, extendedLocation: {
                serializedName: "extendedLocation",
                xmlName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation",
                },
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                xmlName: "properties.state",
                type: {
                    name: "String",
                },
            }, hostNames: {
                serializedName: "properties.hostNames",
                readOnly: true,
                xmlName: "properties.hostNames",
                xmlElementName: "SitePropertiesHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, repositorySiteName: {
                serializedName: "properties.repositorySiteName",
                readOnly: true,
                xmlName: "properties.repositorySiteName",
                type: {
                    name: "String",
                },
            }, usageState: {
                serializedName: "properties.usageState",
                readOnly: true,
                xmlName: "properties.usageState",
                type: {
                    name: "Enum",
                    allowedValues: ["Normal", "Exceeded"],
                },
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean",
                },
            }, enabledHostNames: {
                serializedName: "properties.enabledHostNames",
                readOnly: true,
                xmlName: "properties.enabledHostNames",
                xmlElementName: "SitePropertiesEnabledHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, availabilityState: {
                serializedName: "properties.availabilityState",
                readOnly: true,
                xmlName: "properties.availabilityState",
                type: {
                    name: "Enum",
                    allowedValues: ["Normal", "Limited", "DisasterRecoveryMode"],
                },
            }, hostNameSslStates: {
                serializedName: "properties.hostNameSslStates",
                xmlName: "properties.hostNameSslStates",
                xmlElementName: "HostNameSslState",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostNameSslState",
                        },
                    },
                },
            }, serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String",
                },
            }, reserved: {
                defaultValue: false,
                serializedName: "properties.reserved",
                xmlName: "properties.reserved",
                type: {
                    name: "Boolean",
                },
            }, isXenon: {
                defaultValue: false,
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean",
                },
            }, hyperV: {
                defaultValue: false,
                serializedName: "properties.hyperV",
                xmlName: "properties.hyperV",
                type: {
                    name: "Boolean",
                },
            }, lastModifiedTimeUtc: {
                serializedName: "properties.lastModifiedTimeUtc",
                readOnly: true,
                xmlName: "properties.lastModifiedTimeUtc",
                type: {
                    name: "DateTime",
                },
            }, dnsConfiguration: {
                serializedName: "properties.dnsConfiguration",
                xmlName: "properties.dnsConfiguration",
                type: {
                    name: "Composite",
                    className: "SiteDnsConfig",
                },
            }, vnetRouteAllEnabled: {
                serializedName: "properties.vnetRouteAllEnabled",
                xmlName: "properties.vnetRouteAllEnabled",
                type: {
                    name: "Boolean",
                },
            }, vnetImagePullEnabled: {
                serializedName: "properties.vnetImagePullEnabled",
                xmlName: "properties.vnetImagePullEnabled",
                type: {
                    name: "Boolean",
                },
            }, vnetContentShareEnabled: {
                serializedName: "properties.vnetContentShareEnabled",
                xmlName: "properties.vnetContentShareEnabled",
                type: {
                    name: "Boolean",
                },
            }, vnetBackupRestoreEnabled: {
                serializedName: "properties.vnetBackupRestoreEnabled",
                xmlName: "properties.vnetBackupRestoreEnabled",
                type: {
                    name: "Boolean",
                },
            }, siteConfig: {
                serializedName: "properties.siteConfig",
                xmlName: "properties.siteConfig",
                type: {
                    name: "Composite",
                    className: "SiteConfig",
                },
            }, functionAppConfig: {
                serializedName: "properties.functionAppConfig",
                xmlName: "properties.functionAppConfig",
                type: {
                    name: "Composite",
                    className: "FunctionAppConfig",
                },
            }, daprConfig: {
                serializedName: "properties.daprConfig",
                xmlName: "properties.daprConfig",
                type: {
                    name: "Composite",
                    className: "DaprConfig",
                },
            }, workloadProfileName: {
                serializedName: "properties.workloadProfileName",
                xmlName: "properties.workloadProfileName",
                type: {
                    name: "String",
                },
            }, resourceConfig: {
                serializedName: "properties.resourceConfig",
                xmlName: "properties.resourceConfig",
                type: {
                    name: "Composite",
                    className: "ResourceConfig",
                },
            }, trafficManagerHostNames: {
                serializedName: "properties.trafficManagerHostNames",
                readOnly: true,
                xmlName: "properties.trafficManagerHostNames",
                xmlElementName: "SitePropertiesTrafficManagerHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, scmSiteAlsoStopped: {
                defaultValue: false,
                serializedName: "properties.scmSiteAlsoStopped",
                xmlName: "properties.scmSiteAlsoStopped",
                type: {
                    name: "Boolean",
                },
            }, targetSwapSlot: {
                serializedName: "properties.targetSwapSlot",
                readOnly: true,
                xmlName: "properties.targetSwapSlot",
                type: {
                    name: "String",
                },
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile",
                },
            }, clientAffinityEnabled: {
                serializedName: "properties.clientAffinityEnabled",
                xmlName: "properties.clientAffinityEnabled",
                type: {
                    name: "Boolean",
                },
            }, clientCertEnabled: {
                serializedName: "properties.clientCertEnabled",
                xmlName: "properties.clientCertEnabled",
                type: {
                    name: "Boolean",
                },
            }, clientCertMode: {
                serializedName: "properties.clientCertMode",
                xmlName: "properties.clientCertMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Required", "Optional", "OptionalInteractiveUser"],
                },
            }, clientCertExclusionPaths: {
                serializedName: "properties.clientCertExclusionPaths",
                xmlName: "properties.clientCertExclusionPaths",
                type: {
                    name: "String",
                },
            }, hostNamesDisabled: {
                serializedName: "properties.hostNamesDisabled",
                xmlName: "properties.hostNamesDisabled",
                type: {
                    name: "Boolean",
                },
            }, customDomainVerificationId: {
                serializedName: "properties.customDomainVerificationId",
                xmlName: "properties.customDomainVerificationId",
                type: {
                    name: "String",
                },
            }, outboundIpAddresses: {
                serializedName: "properties.outboundIpAddresses",
                readOnly: true,
                xmlName: "properties.outboundIpAddresses",
                type: {
                    name: "String",
                },
            }, possibleOutboundIpAddresses: {
                serializedName: "properties.possibleOutboundIpAddresses",
                readOnly: true,
                xmlName: "properties.possibleOutboundIpAddresses",
                type: {
                    name: "String",
                },
            }, containerSize: {
                serializedName: "properties.containerSize",
                xmlName: "properties.containerSize",
                type: {
                    name: "Number",
                },
            }, dailyMemoryTimeQuota: {
                serializedName: "properties.dailyMemoryTimeQuota",
                xmlName: "properties.dailyMemoryTimeQuota",
                type: {
                    name: "Number",
                },
            }, suspendedTill: {
                serializedName: "properties.suspendedTill",
                readOnly: true,
                xmlName: "properties.suspendedTill",
                type: {
                    name: "DateTime",
                },
            }, maxNumberOfWorkers: {
                serializedName: "properties.maxNumberOfWorkers",
                readOnly: true,
                xmlName: "properties.maxNumberOfWorkers",
                type: {
                    name: "Number",
                },
            }, cloningInfo: {
                serializedName: "properties.cloningInfo",
                xmlName: "properties.cloningInfo",
                type: {
                    name: "Composite",
                    className: "CloningInfo",
                },
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String",
                },
            }, isDefaultContainer: {
                serializedName: "properties.isDefaultContainer",
                readOnly: true,
                xmlName: "properties.isDefaultContainer",
                type: {
                    name: "Boolean",
                },
            }, defaultHostName: {
                serializedName: "properties.defaultHostName",
                readOnly: true,
                xmlName: "properties.defaultHostName",
                type: {
                    name: "String",
                },
            }, slotSwapStatus: {
                serializedName: "properties.slotSwapStatus",
                xmlName: "properties.slotSwapStatus",
                type: {
                    name: "Composite",
                    className: "SlotSwapStatus",
                },
            }, httpsOnly: {
                serializedName: "properties.httpsOnly",
                xmlName: "properties.httpsOnly",
                type: {
                    name: "Boolean",
                },
            }, redundancyMode: {
                serializedName: "properties.redundancyMode",
                xmlName: "properties.redundancyMode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "Manual",
                        "Failover",
                        "ActiveActive",
                        "GeoRedundant",
                    ],
                },
            }, inProgressOperationId: {
                serializedName: "properties.inProgressOperationId",
                readOnly: true,
                xmlName: "properties.inProgressOperationId",
                type: {
                    name: "Uuid",
                },
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String",
                },
            }, storageAccountRequired: {
                serializedName: "properties.storageAccountRequired",
                xmlName: "properties.storageAccountRequired",
                type: {
                    name: "Boolean",
                },
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String",
                },
            }, virtualNetworkSubnetId: {
                serializedName: "properties.virtualNetworkSubnetId",
                xmlName: "properties.virtualNetworkSubnetId",
                type: {
                    name: "String",
                },
            }, managedEnvironmentId: {
                serializedName: "properties.managedEnvironmentId",
                xmlName: "properties.managedEnvironmentId",
                type: {
                    name: "String",
                },
            } }),
    },
};
const AppServicePlan = {
    serializedName: "AppServicePlan",
    type: {
        name: "Composite",
        className: "AppServicePlan",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription",
                },
            }, extendedLocation: {
                serializedName: "extendedLocation",
                xmlName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation",
                },
            }, workerTierName: {
                serializedName: "properties.workerTierName",
                xmlName: "properties.workerTierName",
                type: {
                    name: "String",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Ready", "Pending", "Creating"],
                },
            }, subscription: {
                serializedName: "properties.subscription",
                readOnly: true,
                xmlName: "properties.subscription",
                type: {
                    name: "String",
                },
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile",
                },
            }, maximumNumberOfWorkers: {
                serializedName: "properties.maximumNumberOfWorkers",
                readOnly: true,
                xmlName: "properties.maximumNumberOfWorkers",
                type: {
                    name: "Number",
                },
            }, numberOfWorkers: {
                serializedName: "properties.numberOfWorkers",
                readOnly: true,
                xmlName: "properties.numberOfWorkers",
                type: {
                    name: "Number",
                },
            }, geoRegion: {
                serializedName: "properties.geoRegion",
                readOnly: true,
                xmlName: "properties.geoRegion",
                type: {
                    name: "String",
                },
            }, perSiteScaling: {
                defaultValue: false,
                serializedName: "properties.perSiteScaling",
                xmlName: "properties.perSiteScaling",
                type: {
                    name: "Boolean",
                },
            }, elasticScaleEnabled: {
                serializedName: "properties.elasticScaleEnabled",
                xmlName: "properties.elasticScaleEnabled",
                type: {
                    name: "Boolean",
                },
            }, maximumElasticWorkerCount: {
                serializedName: "properties.maximumElasticWorkerCount",
                xmlName: "properties.maximumElasticWorkerCount",
                type: {
                    name: "Number",
                },
            }, numberOfSites: {
                serializedName: "properties.numberOfSites",
                readOnly: true,
                xmlName: "properties.numberOfSites",
                type: {
                    name: "Number",
                },
            }, isSpot: {
                serializedName: "properties.isSpot",
                xmlName: "properties.isSpot",
                type: {
                    name: "Boolean",
                },
            }, spotExpirationTime: {
                serializedName: "properties.spotExpirationTime",
                xmlName: "properties.spotExpirationTime",
                type: {
                    name: "DateTime",
                },
            }, freeOfferExpirationTime: {
                serializedName: "properties.freeOfferExpirationTime",
                xmlName: "properties.freeOfferExpirationTime",
                type: {
                    name: "DateTime",
                },
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String",
                },
            }, reserved: {
                defaultValue: false,
                serializedName: "properties.reserved",
                xmlName: "properties.reserved",
                type: {
                    name: "Boolean",
                },
            }, isXenon: {
                defaultValue: false,
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean",
                },
            }, hyperV: {
                defaultValue: false,
                serializedName: "properties.hyperV",
                xmlName: "properties.hyperV",
                type: {
                    name: "Boolean",
                },
            }, targetWorkerCount: {
                serializedName: "properties.targetWorkerCount",
                xmlName: "properties.targetWorkerCount",
                type: {
                    name: "Number",
                },
            }, targetWorkerSizeId: {
                serializedName: "properties.targetWorkerSizeId",
                xmlName: "properties.targetWorkerSizeId",
                type: {
                    name: "Number",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting",
                    ],
                },
            }, kubeEnvironmentProfile: {
                serializedName: "properties.kubeEnvironmentProfile",
                xmlName: "properties.kubeEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "KubeEnvironmentProfile",
                },
            }, zoneRedundant: {
                defaultValue: false,
                serializedName: "properties.zoneRedundant",
                xmlName: "properties.zoneRedundant",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const Certificate = {
    serializedName: "Certificate",
    type: {
        name: "Composite",
        className: "Certificate",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { password: {
                serializedName: "properties.password",
                xmlName: "properties.password",
                type: {
                    name: "String",
                },
            }, friendlyName: {
                serializedName: "properties.friendlyName",
                readOnly: true,
                xmlName: "properties.friendlyName",
                type: {
                    name: "String",
                },
            }, subjectName: {
                serializedName: "properties.subjectName",
                readOnly: true,
                xmlName: "properties.subjectName",
                type: {
                    name: "String",
                },
            }, hostNames: {
                serializedName: "properties.hostNames",
                xmlName: "properties.hostNames",
                xmlElementName: "CertificatePropertiesHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, pfxBlob: {
                serializedName: "properties.pfxBlob",
                xmlName: "properties.pfxBlob",
                type: {
                    name: "ByteArray",
                },
            }, siteName: {
                serializedName: "properties.siteName",
                readOnly: true,
                xmlName: "properties.siteName",
                type: {
                    name: "String",
                },
            }, selfLink: {
                serializedName: "properties.selfLink",
                readOnly: true,
                xmlName: "properties.selfLink",
                type: {
                    name: "String",
                },
            }, issuer: {
                serializedName: "properties.issuer",
                readOnly: true,
                xmlName: "properties.issuer",
                type: {
                    name: "String",
                },
            }, issueDate: {
                serializedName: "properties.issueDate",
                readOnly: true,
                xmlName: "properties.issueDate",
                type: {
                    name: "DateTime",
                },
            }, expirationDate: {
                serializedName: "properties.expirationDate",
                readOnly: true,
                xmlName: "properties.expirationDate",
                type: {
                    name: "DateTime",
                },
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                xmlName: "properties.thumbprint",
                type: {
                    name: "String",
                },
            }, valid: {
                serializedName: "properties.valid",
                readOnly: true,
                xmlName: "properties.valid",
                type: {
                    name: "Boolean",
                },
            }, cerBlob: {
                serializedName: "properties.cerBlob",
                readOnly: true,
                xmlName: "properties.cerBlob",
                type: {
                    name: "ByteArray",
                },
            }, publicKeyHash: {
                serializedName: "properties.publicKeyHash",
                readOnly: true,
                xmlName: "properties.publicKeyHash",
                type: {
                    name: "String",
                },
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile",
                },
            }, keyVaultId: {
                serializedName: "properties.keyVaultId",
                xmlName: "properties.keyVaultId",
                type: {
                    name: "String",
                },
            }, keyVaultSecretName: {
                serializedName: "properties.keyVaultSecretName",
                xmlName: "properties.keyVaultSecretName",
                type: {
                    name: "String",
                },
            }, keyVaultSecretStatus: {
                serializedName: "properties.keyVaultSecretStatus",
                readOnly: true,
                xmlName: "properties.keyVaultSecretStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown",
                    ],
                },
            }, serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String",
                },
            }, canonicalName: {
                serializedName: "properties.canonicalName",
                xmlName: "properties.canonicalName",
                type: {
                    name: "String",
                },
            }, domainValidationMethod: {
                serializedName: "properties.domainValidationMethod",
                xmlName: "properties.domainValidationMethod",
                type: {
                    name: "String",
                },
            } }),
    },
};
const ContainerApp = {
    serializedName: "ContainerApp",
    type: {
        name: "Composite",
        className: "ContainerApp",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String",
                },
            }, kubeEnvironmentId: {
                serializedName: "properties.kubeEnvironmentId",
                xmlName: "properties.kubeEnvironmentId",
                type: {
                    name: "String",
                },
            }, latestRevisionName: {
                serializedName: "properties.latestRevisionName",
                readOnly: true,
                xmlName: "properties.latestRevisionName",
                type: {
                    name: "String",
                },
            }, latestRevisionFqdn: {
                serializedName: "properties.latestRevisionFqdn",
                readOnly: true,
                xmlName: "properties.latestRevisionFqdn",
                type: {
                    name: "String",
                },
            }, configuration: {
                serializedName: "properties.configuration",
                xmlName: "properties.configuration",
                type: {
                    name: "Composite",
                    className: "Configuration",
                },
            }, template: {
                serializedName: "properties.template",
                xmlName: "properties.template",
                type: {
                    name: "Composite",
                    className: "Template",
                },
            } }),
    },
};
const Revision = {
    serializedName: "Revision",
    type: {
        name: "Composite",
        className: "Revision",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime",
                },
            }, fqdn: {
                serializedName: "properties.fqdn",
                readOnly: true,
                xmlName: "properties.fqdn",
                type: {
                    name: "String",
                },
            }, template: {
                serializedName: "properties.template",
                xmlName: "properties.template",
                type: {
                    name: "Composite",
                    className: "Template",
                },
            }, active: {
                serializedName: "properties.active",
                readOnly: true,
                xmlName: "properties.active",
                type: {
                    name: "Boolean",
                },
            }, replicas: {
                serializedName: "properties.replicas",
                readOnly: true,
                xmlName: "properties.replicas",
                type: {
                    name: "Number",
                },
            }, trafficWeight: {
                serializedName: "properties.trafficWeight",
                readOnly: true,
                xmlName: "properties.trafficWeight",
                type: {
                    name: "Number",
                },
            }, provisioningError: {
                serializedName: "properties.provisioningError",
                readOnly: true,
                xmlName: "properties.provisioningError",
                type: {
                    name: "String",
                },
            }, healthState: {
                serializedName: "properties.healthState",
                readOnly: true,
                xmlName: "properties.healthState",
                type: {
                    name: "String",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String",
                },
            } }),
    },
};
const KubeEnvironment = {
    serializedName: "KubeEnvironment",
    type: {
        name: "Composite",
        className: "KubeEnvironment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                xmlName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "Waiting",
                        "InitializationInProgress",
                        "InfrastructureSetupInProgress",
                        "InfrastructureSetupComplete",
                        "ScheduledForDelete",
                        "UpgradeRequested",
                        "UpgradeFailed",
                    ],
                },
            }, deploymentErrors: {
                serializedName: "properties.deploymentErrors",
                readOnly: true,
                xmlName: "properties.deploymentErrors",
                type: {
                    name: "String",
                },
            }, internalLoadBalancerEnabled: {
                serializedName: "properties.internalLoadBalancerEnabled",
                xmlName: "properties.internalLoadBalancerEnabled",
                type: {
                    name: "Boolean",
                },
            }, defaultDomain: {
                serializedName: "properties.defaultDomain",
                readOnly: true,
                xmlName: "properties.defaultDomain",
                type: {
                    name: "String",
                },
            }, staticIp: {
                serializedName: "properties.staticIp",
                xmlName: "properties.staticIp",
                type: {
                    name: "String",
                },
            }, environmentType: {
                serializedName: "properties.environmentType",
                xmlName: "properties.environmentType",
                type: {
                    name: "String",
                },
            }, arcConfiguration: {
                serializedName: "properties.arcConfiguration",
                xmlName: "properties.arcConfiguration",
                type: {
                    name: "Composite",
                    className: "ArcConfiguration",
                },
            }, appLogsConfiguration: {
                serializedName: "properties.appLogsConfiguration",
                xmlName: "properties.appLogsConfiguration",
                type: {
                    name: "Composite",
                    className: "AppLogsConfiguration",
                },
            }, containerAppsConfiguration: {
                serializedName: "properties.containerAppsConfiguration",
                xmlName: "properties.containerAppsConfiguration",
                type: {
                    name: "Composite",
                    className: "ContainerAppsConfiguration",
                },
            }, aksResourceID: {
                serializedName: "properties.aksResourceID",
                xmlName: "properties.aksResourceID",
                type: {
                    name: "String",
                },
            } }),
    },
};
const StaticSiteARMResource = {
    serializedName: "StaticSiteARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteARMResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription",
                },
            }, identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity",
                },
            }, defaultHostname: {
                serializedName: "properties.defaultHostname",
                readOnly: true,
                xmlName: "properties.defaultHostname",
                type: {
                    name: "String",
                },
            }, repositoryUrl: {
                serializedName: "properties.repositoryUrl",
                xmlName: "properties.repositoryUrl",
                type: {
                    name: "String",
                },
            }, branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String",
                },
            }, customDomains: {
                serializedName: "properties.customDomains",
                readOnly: true,
                xmlName: "properties.customDomains",
                xmlElementName: "StaticSiteCustomDomainsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, repositoryToken: {
                serializedName: "properties.repositoryToken",
                xmlName: "properties.repositoryToken",
                type: {
                    name: "String",
                },
            }, buildProperties: {
                serializedName: "properties.buildProperties",
                xmlName: "properties.buildProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteBuildProperties",
                },
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                xmlName: "properties.privateEndpointConnections",
                xmlElementName: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
                        },
                    },
                },
            }, stagingEnvironmentPolicy: {
                serializedName: "properties.stagingEnvironmentPolicy",
                xmlName: "properties.stagingEnvironmentPolicy",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"],
                },
            }, allowConfigFileUpdates: {
                serializedName: "properties.allowConfigFileUpdates",
                xmlName: "properties.allowConfigFileUpdates",
                type: {
                    name: "Boolean",
                },
            }, templateProperties: {
                serializedName: "properties.templateProperties",
                xmlName: "properties.templateProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteTemplateOptions",
                },
            }, contentDistributionEndpoint: {
                serializedName: "properties.contentDistributionEndpoint",
                readOnly: true,
                xmlName: "properties.contentDistributionEndpoint",
                type: {
                    name: "String",
                },
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                readOnly: true,
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String",
                },
            }, userProvidedFunctionApps: {
                serializedName: "properties.userProvidedFunctionApps",
                readOnly: true,
                xmlName: "properties.userProvidedFunctionApps",
                xmlElementName: "StaticSiteUserProvidedFunctionApp",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserProvidedFunctionApp",
                        },
                    },
                },
            }, linkedBackends: {
                serializedName: "properties.linkedBackends",
                readOnly: true,
                xmlName: "properties.linkedBackends",
                xmlElementName: "StaticSiteLinkedBackend",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteLinkedBackend",
                        },
                    },
                },
            }, provider: {
                serializedName: "properties.provider",
                xmlName: "properties.provider",
                type: {
                    name: "String",
                },
            }, enterpriseGradeCdnStatus: {
                serializedName: "properties.enterpriseGradeCdnStatus",
                xmlName: "properties.enterpriseGradeCdnStatus",
                type: {
                    name: "String",
                },
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String",
                },
            }, databaseConnections: {
                serializedName: "properties.databaseConnections",
                readOnly: true,
                xmlName: "properties.databaseConnections",
                xmlElementName: "DatabaseConnectionOverview",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseConnectionOverview",
                        },
                    },
                },
            } }),
    },
};
const PremierAddOn = {
    serializedName: "PremierAddOn",
    type: {
        name: "Composite",
        className: "PremierAddOn",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "String",
                },
            }, product: {
                serializedName: "properties.product",
                xmlName: "properties.product",
                type: {
                    name: "String",
                },
            }, vendor: {
                serializedName: "properties.vendor",
                xmlName: "properties.vendor",
                type: {
                    name: "String",
                },
            }, marketplacePublisher: {
                serializedName: "properties.marketplacePublisher",
                xmlName: "properties.marketplacePublisher",
                type: {
                    name: "String",
                },
            }, marketplaceOffer: {
                serializedName: "properties.marketplaceOffer",
                xmlName: "properties.marketplaceOffer",
                type: {
                    name: "String",
                },
            } }),
    },
};
const AppServiceCertificateOrderPatchResource = {
    serializedName: "AppServiceCertificateOrderPatchResource",
    type: {
        name: "Composite",
        className: "AppServiceCertificateOrderPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { certificates: {
                serializedName: "properties.certificates",
                xmlName: "properties.certificates",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AppServiceCertificate" },
                    },
                },
            }, distinguishedName: {
                serializedName: "properties.distinguishedName",
                xmlName: "properties.distinguishedName",
                type: {
                    name: "String",
                },
            }, domainVerificationToken: {
                serializedName: "properties.domainVerificationToken",
                readOnly: true,
                xmlName: "properties.domainVerificationToken",
                type: {
                    name: "String",
                },
            }, validityInYears: {
                defaultValue: 1,
                serializedName: "properties.validityInYears",
                xmlName: "properties.validityInYears",
                type: {
                    name: "Number",
                },
            }, keySize: {
                defaultValue: 2048,
                serializedName: "properties.keySize",
                xmlName: "properties.keySize",
                type: {
                    name: "Number",
                },
            }, productType: {
                serializedName: "properties.productType",
                xmlName: "properties.productType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "StandardDomainValidatedSsl",
                        "StandardDomainValidatedWildCardSsl",
                    ],
                },
            }, autoRenew: {
                defaultValue: true,
                serializedName: "properties.autoRenew",
                xmlName: "properties.autoRenew",
                type: {
                    name: "Boolean",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting",
                    ],
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Pendingissuance",
                        "Issued",
                        "Revoked",
                        "Canceled",
                        "Denied",
                        "Pendingrevocation",
                        "PendingRekey",
                        "Unused",
                        "Expired",
                        "NotSubmitted",
                    ],
                },
            }, signedCertificate: {
                serializedName: "properties.signedCertificate",
                xmlName: "properties.signedCertificate",
                type: {
                    name: "Composite",
                    className: "CertificateDetails",
                },
            }, csr: {
                serializedName: "properties.csr",
                xmlName: "properties.csr",
                type: {
                    name: "String",
                },
            }, intermediate: {
                serializedName: "properties.intermediate",
                xmlName: "properties.intermediate",
                type: {
                    name: "Composite",
                    className: "CertificateDetails",
                },
            }, root: {
                serializedName: "properties.root",
                xmlName: "properties.root",
                type: {
                    name: "Composite",
                    className: "CertificateDetails",
                },
            }, serialNumber: {
                serializedName: "properties.serialNumber",
                readOnly: true,
                xmlName: "properties.serialNumber",
                type: {
                    name: "String",
                },
            }, lastCertificateIssuanceTime: {
                serializedName: "properties.lastCertificateIssuanceTime",
                readOnly: true,
                xmlName: "properties.lastCertificateIssuanceTime",
                type: {
                    name: "DateTime",
                },
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                readOnly: true,
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime",
                },
            }, isPrivateKeyExternal: {
                serializedName: "properties.isPrivateKeyExternal",
                readOnly: true,
                xmlName: "properties.isPrivateKeyExternal",
                type: {
                    name: "Boolean",
                },
            }, appServiceCertificateNotRenewableReasons: {
                serializedName: "properties.appServiceCertificateNotRenewableReasons",
                readOnly: true,
                xmlName: "properties.appServiceCertificateNotRenewableReasons",
                xmlElementName: "ResourceNotRenewableReason",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, nextAutoRenewalTimeStamp: {
                serializedName: "properties.nextAutoRenewalTimeStamp",
                readOnly: true,
                xmlName: "properties.nextAutoRenewalTimeStamp",
                type: {
                    name: "DateTime",
                },
            }, contact: {
                serializedName: "properties.contact",
                xmlName: "properties.contact",
                type: {
                    name: "Composite",
                    className: "CertificateOrderContact",
                },
            } }),
    },
};
const AppServiceCertificatePatchResource = {
    serializedName: "AppServiceCertificatePatchResource",
    type: {
        name: "Composite",
        className: "AppServiceCertificatePatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { keyVaultId: {
                serializedName: "properties.keyVaultId",
                xmlName: "properties.keyVaultId",
                type: {
                    name: "String",
                },
            }, keyVaultSecretName: {
                serializedName: "properties.keyVaultSecretName",
                xmlName: "properties.keyVaultSecretName",
                type: {
                    name: "String",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown",
                    ],
                },
            } }),
    },
};
const ReissueCertificateOrderRequest = {
    serializedName: "ReissueCertificateOrderRequest",
    type: {
        name: "Composite",
        className: "ReissueCertificateOrderRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { keySize: {
                serializedName: "properties.keySize",
                xmlName: "properties.keySize",
                type: {
                    name: "Number",
                },
            }, delayExistingRevokeInHours: {
                serializedName: "properties.delayExistingRevokeInHours",
                xmlName: "properties.delayExistingRevokeInHours",
                type: {
                    name: "Number",
                },
            }, csr: {
                serializedName: "properties.csr",
                xmlName: "properties.csr",
                type: {
                    name: "String",
                },
            }, isPrivateKeyExternal: {
                serializedName: "properties.isPrivateKeyExternal",
                xmlName: "properties.isPrivateKeyExternal",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const RenewCertificateOrderRequest = {
    serializedName: "RenewCertificateOrderRequest",
    type: {
        name: "Composite",
        className: "RenewCertificateOrderRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { keySize: {
                serializedName: "properties.keySize",
                xmlName: "properties.keySize",
                type: {
                    name: "Number",
                },
            }, csr: {
                serializedName: "properties.csr",
                xmlName: "properties.csr",
                type: {
                    name: "String",
                },
            }, isPrivateKeyExternal: {
                serializedName: "properties.isPrivateKeyExternal",
                xmlName: "properties.isPrivateKeyExternal",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const DetectorResponse = {
    serializedName: "DetectorResponse",
    type: {
        name: "Composite",
        className: "DetectorResponse",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { metadata: {
                serializedName: "properties.metadata",
                xmlName: "properties.metadata",
                type: {
                    name: "Composite",
                    className: "DetectorInfo",
                },
            }, dataset: {
                serializedName: "properties.dataset",
                xmlName: "properties.dataset",
                xmlElementName: "DiagnosticData",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticData",
                        },
                    },
                },
            }, status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "Composite",
                    className: "Status",
                },
            }, dataProvidersMetadata: {
                serializedName: "properties.dataProvidersMetadata",
                xmlName: "properties.dataProvidersMetadata",
                xmlElementName: "DataProviderMetadata",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataProviderMetadata",
                        },
                    },
                },
            }, suggestedUtterances: {
                serializedName: "properties.suggestedUtterances",
                xmlName: "properties.suggestedUtterances",
                type: {
                    name: "Composite",
                    className: "QueryUtterancesResults",
                },
            } }),
    },
};
const DomainPatchResource = {
    serializedName: "DomainPatchResource",
    type: {
        name: "Composite",
        className: "DomainPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { contactAdmin: {
                serializedName: "properties.contactAdmin",
                xmlName: "properties.contactAdmin",
                type: {
                    name: "Composite",
                    className: "Contact",
                },
            }, contactBilling: {
                serializedName: "properties.contactBilling",
                xmlName: "properties.contactBilling",
                type: {
                    name: "Composite",
                    className: "Contact",
                },
            }, contactRegistrant: {
                serializedName: "properties.contactRegistrant",
                xmlName: "properties.contactRegistrant",
                type: {
                    name: "Composite",
                    className: "Contact",
                },
            }, contactTech: {
                serializedName: "properties.contactTech",
                xmlName: "properties.contactTech",
                type: {
                    name: "Composite",
                    className: "Contact",
                },
            }, registrationStatus: {
                serializedName: "properties.registrationStatus",
                readOnly: true,
                xmlName: "properties.registrationStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Active",
                        "Awaiting",
                        "Cancelled",
                        "Confiscated",
                        "Disabled",
                        "Excluded",
                        "Expired",
                        "Failed",
                        "Held",
                        "Locked",
                        "Parked",
                        "Pending",
                        "Reserved",
                        "Reverted",
                        "Suspended",
                        "Transferred",
                        "Unknown",
                        "Unlocked",
                        "Unparked",
                        "Updated",
                        "JsonConverterFailed",
                    ],
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting",
                    ],
                },
            }, nameServers: {
                serializedName: "properties.nameServers",
                readOnly: true,
                xmlName: "properties.nameServers",
                xmlElementName: "DomainPatchResourcePropertiesNameServersItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, privacy: {
                serializedName: "properties.privacy",
                xmlName: "properties.privacy",
                type: {
                    name: "Boolean",
                },
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime",
                },
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                readOnly: true,
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime",
                },
            }, lastRenewedTime: {
                serializedName: "properties.lastRenewedTime",
                readOnly: true,
                xmlName: "properties.lastRenewedTime",
                type: {
                    name: "DateTime",
                },
            }, autoRenew: {
                defaultValue: true,
                serializedName: "properties.autoRenew",
                xmlName: "properties.autoRenew",
                type: {
                    name: "Boolean",
                },
            }, readyForDnsRecordManagement: {
                serializedName: "properties.readyForDnsRecordManagement",
                readOnly: true,
                xmlName: "properties.readyForDnsRecordManagement",
                type: {
                    name: "Boolean",
                },
            }, managedHostNames: {
                serializedName: "properties.managedHostNames",
                readOnly: true,
                xmlName: "properties.managedHostNames",
                xmlElementName: "HostName",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostName",
                        },
                    },
                },
            }, consent: {
                serializedName: "properties.consent",
                xmlName: "properties.consent",
                type: {
                    name: "Composite",
                    className: "DomainPurchaseConsent",
                },
            }, domainNotRenewableReasons: {
                serializedName: "properties.domainNotRenewableReasons",
                readOnly: true,
                xmlName: "properties.domainNotRenewableReasons",
                xmlElementName: "ResourceNotRenewableReason",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, dnsType: {
                serializedName: "properties.dnsType",
                xmlName: "properties.dnsType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureDns", "DefaultDomainRegistrarDns"],
                },
            }, dnsZoneId: {
                serializedName: "properties.dnsZoneId",
                xmlName: "properties.dnsZoneId",
                type: {
                    name: "String",
                },
            }, targetDnsType: {
                serializedName: "properties.targetDnsType",
                xmlName: "properties.targetDnsType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureDns", "DefaultDomainRegistrarDns"],
                },
            }, authCode: {
                serializedName: "properties.authCode",
                xmlName: "properties.authCode",
                type: {
                    name: "String",
                },
            } }),
    },
};
const DomainOwnershipIdentifier = {
    serializedName: "DomainOwnershipIdentifier",
    type: {
        name: "Composite",
        className: "DomainOwnershipIdentifier",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { ownershipId: {
                serializedName: "properties.ownershipId",
                xmlName: "properties.ownershipId",
                type: {
                    name: "String",
                },
            } }),
    },
};
const TopLevelDomain = {
    serializedName: "TopLevelDomain",
    type: {
        name: "Composite",
        className: "TopLevelDomain",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { privacy: {
                serializedName: "properties.privacy",
                xmlName: "properties.privacy",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const CustomDnsSuffixConfiguration = {
    serializedName: "CustomDnsSuffixConfiguration",
    type: {
        name: "Composite",
        className: "CustomDnsSuffixConfiguration",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: ["Succeeded", "Failed", "Degraded", "InProgress"],
                },
            }, provisioningDetails: {
                serializedName: "properties.provisioningDetails",
                readOnly: true,
                xmlName: "properties.provisioningDetails",
                type: {
                    name: "String",
                },
            }, dnsSuffix: {
                serializedName: "properties.dnsSuffix",
                xmlName: "properties.dnsSuffix",
                type: {
                    name: "String",
                },
            }, certificateUrl: {
                serializedName: "properties.certificateUrl",
                xmlName: "properties.certificateUrl",
                type: {
                    name: "String",
                },
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String",
                },
            } }),
    },
};
const AseV3NetworkingConfiguration = {
    serializedName: "AseV3NetworkingConfiguration",
    type: {
        name: "Composite",
        className: "AseV3NetworkingConfiguration",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { windowsOutboundIpAddresses: {
                serializedName: "properties.windowsOutboundIpAddresses",
                readOnly: true,
                xmlName: "properties.windowsOutboundIpAddresses",
                xmlElementName: "AseV3NetworkingConfigurationPropertiesWindowsOutboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, linuxOutboundIpAddresses: {
                serializedName: "properties.linuxOutboundIpAddresses",
                readOnly: true,
                xmlName: "properties.linuxOutboundIpAddresses",
                xmlElementName: "AseV3NetworkingConfigurationPropertiesLinuxOutboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, externalInboundIpAddresses: {
                serializedName: "properties.externalInboundIpAddresses",
                readOnly: true,
                xmlName: "properties.externalInboundIpAddresses",
                xmlElementName: "AseV3NetworkingConfigurationPropertiesExternalInboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, internalInboundIpAddresses: {
                serializedName: "properties.internalInboundIpAddresses",
                readOnly: true,
                xmlName: "properties.internalInboundIpAddresses",
                xmlElementName: "AseV3NetworkingConfigurationPropertiesInternalInboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, allowNewPrivateEndpointConnections: {
                serializedName: "properties.allowNewPrivateEndpointConnections",
                xmlName: "properties.allowNewPrivateEndpointConnections",
                type: {
                    name: "Boolean",
                },
            }, ftpEnabled: {
                serializedName: "properties.ftpEnabled",
                xmlName: "properties.ftpEnabled",
                type: {
                    name: "Boolean",
                },
            }, remoteDebugEnabled: {
                serializedName: "properties.remoteDebugEnabled",
                xmlName: "properties.remoteDebugEnabled",
                type: {
                    name: "Boolean",
                },
            }, inboundIpAddressOverride: {
                serializedName: "properties.inboundIpAddressOverride",
                xmlName: "properties.inboundIpAddressOverride",
                type: {
                    name: "String",
                },
            } }),
    },
};
const AppServiceEnvironmentPatchResource = {
    serializedName: "AppServiceEnvironmentPatchResource",
    type: {
        name: "Composite",
        className: "AppServiceEnvironmentPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting",
                    ],
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Preparing", "Ready", "Scaling", "Deleting"],
                },
            }, virtualNetwork: {
                serializedName: "properties.virtualNetwork",
                xmlName: "properties.virtualNetwork",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkProfile",
                },
            }, internalLoadBalancingMode: {
                serializedName: "properties.internalLoadBalancingMode",
                xmlName: "properties.internalLoadBalancingMode",
                type: {
                    name: "String",
                },
            }, multiSize: {
                serializedName: "properties.multiSize",
                xmlName: "properties.multiSize",
                type: {
                    name: "String",
                },
            }, multiRoleCount: {
                serializedName: "properties.multiRoleCount",
                readOnly: true,
                xmlName: "properties.multiRoleCount",
                type: {
                    name: "Number",
                },
            }, ipsslAddressCount: {
                serializedName: "properties.ipsslAddressCount",
                xmlName: "properties.ipsslAddressCount",
                type: {
                    name: "Number",
                },
            }, dnsSuffix: {
                serializedName: "properties.dnsSuffix",
                xmlName: "properties.dnsSuffix",
                type: {
                    name: "String",
                },
            }, maximumNumberOfMachines: {
                serializedName: "properties.maximumNumberOfMachines",
                readOnly: true,
                xmlName: "properties.maximumNumberOfMachines",
                type: {
                    name: "Number",
                },
            }, frontEndScaleFactor: {
                serializedName: "properties.frontEndScaleFactor",
                xmlName: "properties.frontEndScaleFactor",
                type: {
                    name: "Number",
                },
            }, suspended: {
                serializedName: "properties.suspended",
                readOnly: true,
                xmlName: "properties.suspended",
                type: {
                    name: "Boolean",
                },
            }, clusterSettings: {
                serializedName: "properties.clusterSettings",
                xmlName: "properties.clusterSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair",
                        },
                    },
                },
            }, userWhitelistedIpRanges: {
                serializedName: "properties.userWhitelistedIpRanges",
                xmlName: "properties.userWhitelistedIpRanges",
                xmlElementName: "AppServiceEnvironmentUserWhitelistedIpRangesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, hasLinuxWorkers: {
                serializedName: "properties.hasLinuxWorkers",
                readOnly: true,
                xmlName: "properties.hasLinuxWorkers",
                type: {
                    name: "Boolean",
                },
            }, upgradePreference: {
                defaultValue: "None",
                serializedName: "properties.upgradePreference",
                xmlName: "properties.upgradePreference",
                type: {
                    name: "String",
                },
            }, dedicatedHostCount: {
                serializedName: "properties.dedicatedHostCount",
                xmlName: "properties.dedicatedHostCount",
                type: {
                    name: "Number",
                },
            }, zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                xmlName: "properties.zoneRedundant",
                type: {
                    name: "Boolean",
                },
            }, customDnsSuffixConfiguration: {
                serializedName: "properties.customDnsSuffixConfiguration",
                xmlName: "properties.customDnsSuffixConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomDnsSuffixConfiguration",
                },
            }, networkingConfiguration: {
                serializedName: "properties.networkingConfiguration",
                xmlName: "properties.networkingConfiguration",
                type: {
                    name: "Composite",
                    className: "AseV3NetworkingConfiguration",
                },
            }, upgradeAvailability: {
                serializedName: "properties.upgradeAvailability",
                readOnly: true,
                xmlName: "properties.upgradeAvailability",
                type: {
                    name: "String",
                },
            } }),
    },
};
const AddressResponse = {
    serializedName: "AddressResponse",
    type: {
        name: "Composite",
        className: "AddressResponse",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { serviceIpAddress: {
                serializedName: "properties.serviceIpAddress",
                xmlName: "properties.serviceIpAddress",
                type: {
                    name: "String",
                },
            }, internalIpAddress: {
                serializedName: "properties.internalIpAddress",
                xmlName: "properties.internalIpAddress",
                type: {
                    name: "String",
                },
            }, outboundIpAddresses: {
                serializedName: "properties.outboundIpAddresses",
                xmlName: "properties.outboundIpAddresses",
                xmlElementName: "AddressResponsePropertiesOutboundIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, vipMappings: {
                serializedName: "properties.vipMappings",
                xmlName: "properties.vipMappings",
                xmlElementName: "VirtualIPMapping",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualIPMapping",
                        },
                    },
                },
            } }),
    },
};
const PushSettings = {
    serializedName: "PushSettings",
    type: {
        name: "Composite",
        className: "PushSettings",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { isPushEnabled: {
                serializedName: "properties.isPushEnabled",
                xmlName: "properties.isPushEnabled",
                type: {
                    name: "Boolean",
                },
            }, tagWhitelistJson: {
                serializedName: "properties.tagWhitelistJson",
                xmlName: "properties.tagWhitelistJson",
                type: {
                    name: "String",
                },
            }, tagsRequiringAuth: {
                serializedName: "properties.tagsRequiringAuth",
                xmlName: "properties.tagsRequiringAuth",
                type: {
                    name: "String",
                },
            }, dynamicTagsJson: {
                serializedName: "properties.dynamicTagsJson",
                xmlName: "properties.dynamicTagsJson",
                type: {
                    name: "String",
                },
            } }),
    },
};
const WorkerPoolResource = {
    serializedName: "WorkerPoolResource",
    type: {
        name: "Composite",
        className: "WorkerPoolResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { sku: {
                serializedName: "sku",
                xmlName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuDescription",
                },
            }, workerSizeId: {
                serializedName: "properties.workerSizeId",
                xmlName: "properties.workerSizeId",
                type: {
                    name: "Number",
                },
            }, computeMode: {
                serializedName: "properties.computeMode",
                xmlName: "properties.computeMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Shared", "Dedicated", "Dynamic"],
                },
            }, workerSize: {
                serializedName: "properties.workerSize",
                xmlName: "properties.workerSize",
                type: {
                    name: "String",
                },
            }, workerCount: {
                serializedName: "properties.workerCount",
                xmlName: "properties.workerCount",
                type: {
                    name: "Number",
                },
            }, instanceNames: {
                serializedName: "properties.instanceNames",
                readOnly: true,
                xmlName: "properties.instanceNames",
                xmlElementName: "WorkerPoolInstanceNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            } }),
    },
};
const ResourceMetricDefinition = {
    serializedName: "ResourceMetricDefinition",
    type: {
        name: "Composite",
        className: "ResourceMetricDefinition",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { unit: {
                serializedName: "properties.unit",
                readOnly: true,
                xmlName: "properties.unit",
                type: {
                    name: "String",
                },
            }, primaryAggregationType: {
                serializedName: "properties.primaryAggregationType",
                readOnly: true,
                xmlName: "properties.primaryAggregationType",
                type: {
                    name: "String",
                },
            }, metricAvailabilities: {
                serializedName: "properties.metricAvailabilities",
                readOnly: true,
                xmlName: "properties.metricAvailabilities",
                xmlElementName: "ResourceMetricAvailability",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceMetricAvailability",
                        },
                    },
                },
            }, resourceUri: {
                serializedName: "properties.resourceUri",
                readOnly: true,
                xmlName: "properties.resourceUri",
                type: {
                    name: "String",
                },
            }, properties: {
                serializedName: "properties.properties",
                readOnly: true,
                xmlName: "properties.properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            } }),
    },
};
const Usage = {
    serializedName: "Usage",
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                xmlName: "properties.displayName",
                type: {
                    name: "String",
                },
            }, resourceName: {
                serializedName: "properties.resourceName",
                readOnly: true,
                xmlName: "properties.resourceName",
                type: {
                    name: "String",
                },
            }, unit: {
                serializedName: "properties.unit",
                readOnly: true,
                xmlName: "properties.unit",
                type: {
                    name: "String",
                },
            }, currentValue: {
                serializedName: "properties.currentValue",
                readOnly: true,
                xmlName: "properties.currentValue",
                type: {
                    name: "Number",
                },
            }, limit: {
                serializedName: "properties.limit",
                readOnly: true,
                xmlName: "properties.limit",
                type: {
                    name: "Number",
                },
            }, nextResetTime: {
                serializedName: "properties.nextResetTime",
                readOnly: true,
                xmlName: "properties.nextResetTime",
                type: {
                    name: "DateTime",
                },
            }, computeMode: {
                serializedName: "properties.computeMode",
                readOnly: true,
                xmlName: "properties.computeMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Shared", "Dedicated", "Dynamic"],
                },
            }, siteMode: {
                serializedName: "properties.siteMode",
                readOnly: true,
                xmlName: "properties.siteMode",
                type: {
                    name: "String",
                },
            } }),
    },
};
const RemotePrivateEndpointConnectionARMResource = {
    serializedName: "RemotePrivateEndpointConnectionARMResource",
    type: {
        name: "Composite",
        className: "RemotePrivateEndpointConnectionARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String",
                },
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                xmlName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "ArmIdWrapper",
                },
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                xmlName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkConnectionState",
                },
            }, ipAddresses: {
                serializedName: "properties.ipAddresses",
                xmlName: "properties.ipAddresses",
                xmlElementName: "RemotePrivateEndpointConnectionARMResourcePropertiesIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            } }),
    },
};
const AppServicePlanPatchResource = {
    serializedName: "AppServicePlanPatchResource",
    type: {
        name: "Composite",
        className: "AppServicePlanPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { workerTierName: {
                serializedName: "properties.workerTierName",
                xmlName: "properties.workerTierName",
                type: {
                    name: "String",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: ["Ready", "Pending", "Creating"],
                },
            }, subscription: {
                serializedName: "properties.subscription",
                readOnly: true,
                xmlName: "properties.subscription",
                type: {
                    name: "String",
                },
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile",
                },
            }, maximumNumberOfWorkers: {
                serializedName: "properties.maximumNumberOfWorkers",
                readOnly: true,
                xmlName: "properties.maximumNumberOfWorkers",
                type: {
                    name: "Number",
                },
            }, numberOfWorkers: {
                serializedName: "properties.numberOfWorkers",
                readOnly: true,
                xmlName: "properties.numberOfWorkers",
                type: {
                    name: "Number",
                },
            }, geoRegion: {
                serializedName: "properties.geoRegion",
                readOnly: true,
                xmlName: "properties.geoRegion",
                type: {
                    name: "String",
                },
            }, perSiteScaling: {
                defaultValue: false,
                serializedName: "properties.perSiteScaling",
                xmlName: "properties.perSiteScaling",
                type: {
                    name: "Boolean",
                },
            }, elasticScaleEnabled: {
                serializedName: "properties.elasticScaleEnabled",
                xmlName: "properties.elasticScaleEnabled",
                type: {
                    name: "Boolean",
                },
            }, maximumElasticWorkerCount: {
                serializedName: "properties.maximumElasticWorkerCount",
                xmlName: "properties.maximumElasticWorkerCount",
                type: {
                    name: "Number",
                },
            }, numberOfSites: {
                serializedName: "properties.numberOfSites",
                readOnly: true,
                xmlName: "properties.numberOfSites",
                type: {
                    name: "Number",
                },
            }, isSpot: {
                serializedName: "properties.isSpot",
                xmlName: "properties.isSpot",
                type: {
                    name: "Boolean",
                },
            }, spotExpirationTime: {
                serializedName: "properties.spotExpirationTime",
                xmlName: "properties.spotExpirationTime",
                type: {
                    name: "DateTime",
                },
            }, freeOfferExpirationTime: {
                serializedName: "properties.freeOfferExpirationTime",
                xmlName: "properties.freeOfferExpirationTime",
                type: {
                    name: "DateTime",
                },
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String",
                },
            }, reserved: {
                defaultValue: false,
                serializedName: "properties.reserved",
                xmlName: "properties.reserved",
                type: {
                    name: "Boolean",
                },
            }, isXenon: {
                defaultValue: false,
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean",
                },
            }, hyperV: {
                defaultValue: false,
                serializedName: "properties.hyperV",
                xmlName: "properties.hyperV",
                type: {
                    name: "Boolean",
                },
            }, targetWorkerCount: {
                serializedName: "properties.targetWorkerCount",
                xmlName: "properties.targetWorkerCount",
                type: {
                    name: "Number",
                },
            }, targetWorkerSizeId: {
                serializedName: "properties.targetWorkerSizeId",
                xmlName: "properties.targetWorkerSizeId",
                type: {
                    name: "Number",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "InProgress",
                        "Deleting",
                    ],
                },
            }, kubeEnvironmentProfile: {
                serializedName: "properties.kubeEnvironmentProfile",
                xmlName: "properties.kubeEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "KubeEnvironmentProfile",
                },
            }, zoneRedundant: {
                defaultValue: false,
                serializedName: "properties.zoneRedundant",
                xmlName: "properties.zoneRedundant",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const HybridConnection = {
    serializedName: "HybridConnection",
    type: {
        name: "Composite",
        className: "HybridConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { serviceBusNamespace: {
                serializedName: "properties.serviceBusNamespace",
                xmlName: "properties.serviceBusNamespace",
                type: {
                    name: "String",
                },
            }, relayName: {
                serializedName: "properties.relayName",
                xmlName: "properties.relayName",
                type: {
                    name: "String",
                },
            }, relayArmUri: {
                serializedName: "properties.relayArmUri",
                xmlName: "properties.relayArmUri",
                type: {
                    name: "String",
                },
            }, hostname: {
                serializedName: "properties.hostname",
                xmlName: "properties.hostname",
                type: {
                    name: "String",
                },
            }, port: {
                serializedName: "properties.port",
                xmlName: "properties.port",
                type: {
                    name: "Number",
                },
            }, sendKeyName: {
                serializedName: "properties.sendKeyName",
                xmlName: "properties.sendKeyName",
                type: {
                    name: "String",
                },
            }, sendKeyValue: {
                serializedName: "properties.sendKeyValue",
                xmlName: "properties.sendKeyValue",
                type: {
                    name: "String",
                },
            }, serviceBusSuffix: {
                serializedName: "properties.serviceBusSuffix",
                xmlName: "properties.serviceBusSuffix",
                type: {
                    name: "String",
                },
            } }),
    },
};
const HybridConnectionKey = {
    serializedName: "HybridConnectionKey",
    type: {
        name: "Composite",
        className: "HybridConnectionKey",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { sendKeyName: {
                serializedName: "properties.sendKeyName",
                readOnly: true,
                xmlName: "properties.sendKeyName",
                type: {
                    name: "String",
                },
            }, sendKeyValue: {
                serializedName: "properties.sendKeyValue",
                readOnly: true,
                xmlName: "properties.sendKeyValue",
                type: {
                    name: "String",
                },
            } }),
    },
};
const HybridConnectionLimits = {
    serializedName: "HybridConnectionLimits",
    type: {
        name: "Composite",
        className: "HybridConnectionLimits",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { current: {
                serializedName: "properties.current",
                readOnly: true,
                xmlName: "properties.current",
                type: {
                    name: "Number",
                },
            }, maximum: {
                serializedName: "properties.maximum",
                readOnly: true,
                xmlName: "properties.maximum",
                type: {
                    name: "Number",
                },
            } }),
    },
};
const VnetRoute = {
    serializedName: "VnetRoute",
    type: {
        name: "Composite",
        className: "VnetRoute",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { startAddress: {
                serializedName: "properties.startAddress",
                xmlName: "properties.startAddress",
                type: {
                    name: "String",
                },
            }, endAddress: {
                serializedName: "properties.endAddress",
                xmlName: "properties.endAddress",
                type: {
                    name: "String",
                },
            }, routeType: {
                serializedName: "properties.routeType",
                xmlName: "properties.routeType",
                type: {
                    name: "String",
                },
            } }),
    },
};
const VnetInfoResource = {
    serializedName: "VnetInfoResource",
    type: {
        name: "Composite",
        className: "VnetInfoResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { vnetResourceId: {
                serializedName: "properties.vnetResourceId",
                xmlName: "properties.vnetResourceId",
                type: {
                    name: "String",
                },
            }, certThumbprint: {
                serializedName: "properties.certThumbprint",
                readOnly: true,
                xmlName: "properties.certThumbprint",
                type: {
                    name: "String",
                },
            }, certBlob: {
                serializedName: "properties.certBlob",
                xmlName: "properties.certBlob",
                type: {
                    name: "String",
                },
            }, routes: {
                serializedName: "properties.routes",
                readOnly: true,
                xmlName: "properties.routes",
                xmlElementName: "VnetRoute",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VnetRoute",
                        },
                    },
                },
            }, resyncRequired: {
                serializedName: "properties.resyncRequired",
                readOnly: true,
                xmlName: "properties.resyncRequired",
                type: {
                    name: "Boolean",
                },
            }, dnsServers: {
                serializedName: "properties.dnsServers",
                xmlName: "properties.dnsServers",
                type: {
                    name: "String",
                },
            }, isSwift: {
                serializedName: "properties.isSwift",
                xmlName: "properties.isSwift",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const VnetGateway = {
    serializedName: "VnetGateway",
    type: {
        name: "Composite",
        className: "VnetGateway",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { vnetName: {
                serializedName: "properties.vnetName",
                xmlName: "properties.vnetName",
                type: {
                    name: "String",
                },
            }, vpnPackageUri: {
                serializedName: "properties.vpnPackageUri",
                xmlName: "properties.vpnPackageUri",
                type: {
                    name: "String",
                },
            } }),
    },
};
const CertificatePatchResource = {
    serializedName: "CertificatePatchResource",
    type: {
        name: "Composite",
        className: "CertificatePatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { password: {
                serializedName: "properties.password",
                xmlName: "properties.password",
                type: {
                    name: "String",
                },
            }, friendlyName: {
                serializedName: "properties.friendlyName",
                readOnly: true,
                xmlName: "properties.friendlyName",
                type: {
                    name: "String",
                },
            }, subjectName: {
                serializedName: "properties.subjectName",
                readOnly: true,
                xmlName: "properties.subjectName",
                type: {
                    name: "String",
                },
            }, hostNames: {
                serializedName: "properties.hostNames",
                xmlName: "properties.hostNames",
                xmlElementName: "CertificatePatchResourcePropertiesHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, pfxBlob: {
                serializedName: "properties.pfxBlob",
                xmlName: "properties.pfxBlob",
                type: {
                    name: "ByteArray",
                },
            }, siteName: {
                serializedName: "properties.siteName",
                readOnly: true,
                xmlName: "properties.siteName",
                type: {
                    name: "String",
                },
            }, selfLink: {
                serializedName: "properties.selfLink",
                readOnly: true,
                xmlName: "properties.selfLink",
                type: {
                    name: "String",
                },
            }, issuer: {
                serializedName: "properties.issuer",
                readOnly: true,
                xmlName: "properties.issuer",
                type: {
                    name: "String",
                },
            }, issueDate: {
                serializedName: "properties.issueDate",
                readOnly: true,
                xmlName: "properties.issueDate",
                type: {
                    name: "DateTime",
                },
            }, expirationDate: {
                serializedName: "properties.expirationDate",
                readOnly: true,
                xmlName: "properties.expirationDate",
                type: {
                    name: "DateTime",
                },
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                xmlName: "properties.thumbprint",
                type: {
                    name: "String",
                },
            }, valid: {
                serializedName: "properties.valid",
                readOnly: true,
                xmlName: "properties.valid",
                type: {
                    name: "Boolean",
                },
            }, cerBlob: {
                serializedName: "properties.cerBlob",
                readOnly: true,
                xmlName: "properties.cerBlob",
                type: {
                    name: "ByteArray",
                },
            }, publicKeyHash: {
                serializedName: "properties.publicKeyHash",
                readOnly: true,
                xmlName: "properties.publicKeyHash",
                type: {
                    name: "String",
                },
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile",
                },
            }, keyVaultId: {
                serializedName: "properties.keyVaultId",
                xmlName: "properties.keyVaultId",
                type: {
                    name: "String",
                },
            }, keyVaultSecretName: {
                serializedName: "properties.keyVaultSecretName",
                xmlName: "properties.keyVaultSecretName",
                type: {
                    name: "String",
                },
            }, keyVaultSecretStatus: {
                serializedName: "properties.keyVaultSecretStatus",
                readOnly: true,
                xmlName: "properties.keyVaultSecretStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "WaitingOnCertificateOrder",
                        "Succeeded",
                        "CertificateOrderFailed",
                        "OperationNotPermittedOnKeyVault",
                        "AzureServiceUnauthorizedToAccessKeyVault",
                        "KeyVaultDoesNotExist",
                        "KeyVaultSecretDoesNotExist",
                        "UnknownError",
                        "ExternalPrivateKey",
                        "Unknown",
                    ],
                },
            }, serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String",
                },
            }, canonicalName: {
                serializedName: "properties.canonicalName",
                xmlName: "properties.canonicalName",
                type: {
                    name: "String",
                },
            }, domainValidationMethod: {
                serializedName: "properties.domainValidationMethod",
                xmlName: "properties.domainValidationMethod",
                type: {
                    name: "String",
                },
            } }),
    },
};
const DeletedSite = {
    serializedName: "DeletedSite",
    type: {
        name: "Composite",
        className: "DeletedSite",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { deletedSiteId: {
                serializedName: "properties.deletedSiteId",
                readOnly: true,
                xmlName: "properties.deletedSiteId",
                type: {
                    name: "Number",
                },
            }, deletedTimestamp: {
                serializedName: "properties.deletedTimestamp",
                readOnly: true,
                xmlName: "properties.deletedTimestamp",
                type: {
                    name: "String",
                },
            }, subscription: {
                serializedName: "properties.subscription",
                readOnly: true,
                xmlName: "properties.subscription",
                type: {
                    name: "String",
                },
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String",
                },
            }, deletedSiteName: {
                serializedName: "properties.deletedSiteName",
                readOnly: true,
                xmlName: "properties.deletedSiteName",
                type: {
                    name: "String",
                },
            }, slot: {
                serializedName: "properties.slot",
                readOnly: true,
                xmlName: "properties.slot",
                type: {
                    name: "String",
                },
            }, kindPropertiesKind: {
                serializedName: "properties.kind",
                readOnly: true,
                xmlName: "properties.kind",
                type: {
                    name: "String",
                },
            }, geoRegionName: {
                serializedName: "properties.geoRegionName",
                readOnly: true,
                xmlName: "properties.geoRegionName",
                type: {
                    name: "String",
                },
            } }),
    },
};
const DiagnosticCategory = {
    serializedName: "DiagnosticCategory",
    type: {
        name: "Composite",
        className: "DiagnosticCategory",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String",
                },
            } }),
    },
};
const AnalysisDefinition = {
    serializedName: "AnalysisDefinition",
    type: {
        name: "Composite",
        className: "AnalysisDefinition",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String",
                },
            } }),
    },
};
const DiagnosticAnalysis = {
    serializedName: "DiagnosticAnalysis",
    type: {
        name: "Composite",
        className: "DiagnosticAnalysis",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { startTime: {
                serializedName: "properties.startTime",
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime",
                },
            }, endTime: {
                serializedName: "properties.endTime",
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime",
                },
            }, abnormalTimePeriods: {
                serializedName: "properties.abnormalTimePeriods",
                xmlName: "properties.abnormalTimePeriods",
                xmlElementName: "AbnormalTimePeriod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AbnormalTimePeriod",
                        },
                    },
                },
            }, payload: {
                serializedName: "properties.payload",
                xmlName: "properties.payload",
                xmlElementName: "AnalysisData",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnalysisData",
                        },
                    },
                },
            }, nonCorrelatedDetectors: {
                serializedName: "properties.nonCorrelatedDetectors",
                xmlName: "properties.nonCorrelatedDetectors",
                xmlElementName: "DetectorDefinition",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorDefinition",
                        },
                    },
                },
            } }),
    },
};
const DetectorDefinitionResource = {
    serializedName: "DetectorDefinitionResource",
    type: {
        name: "Composite",
        className: "DetectorDefinitionResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                xmlName: "properties.displayName",
                type: {
                    name: "String",
                },
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String",
                },
            }, rank: {
                serializedName: "properties.rank",
                readOnly: true,
                xmlName: "properties.rank",
                type: {
                    name: "Number",
                },
            }, isEnabled: {
                serializedName: "properties.isEnabled",
                readOnly: true,
                xmlName: "properties.isEnabled",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const DiagnosticDetectorResponse = {
    serializedName: "DiagnosticDetectorResponse",
    type: {
        name: "Composite",
        className: "DiagnosticDetectorResponse",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { startTime: {
                serializedName: "properties.startTime",
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime",
                },
            }, endTime: {
                serializedName: "properties.endTime",
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime",
                },
            }, issueDetected: {
                serializedName: "properties.issueDetected",
                xmlName: "properties.issueDetected",
                type: {
                    name: "Boolean",
                },
            }, detectorDefinition: {
                serializedName: "properties.detectorDefinition",
                xmlName: "properties.detectorDefinition",
                type: {
                    name: "Composite",
                    className: "DetectorDefinition",
                },
            }, metrics: {
                serializedName: "properties.metrics",
                xmlName: "properties.metrics",
                xmlElementName: "DiagnosticMetricSet",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticMetricSet",
                        },
                    },
                },
            }, abnormalTimePeriods: {
                serializedName: "properties.abnormalTimePeriods",
                xmlName: "properties.abnormalTimePeriods",
                xmlElementName: "DetectorAbnormalTimePeriod",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorAbnormalTimePeriod",
                        },
                    },
                },
            }, data: {
                serializedName: "properties.data",
                xmlName: "properties.data",
                xmlElementName: "DiagnosticDetectorResponsePropertiesDataItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "NameValuePair",
                                },
                            },
                        },
                    },
                },
            }, responseMetaData: {
                serializedName: "properties.responseMetaData",
                xmlName: "properties.responseMetaData",
                type: {
                    name: "Composite",
                    className: "ResponseMetaData",
                },
            } }),
    },
};
const Snapshot = {
    serializedName: "Snapshot",
    type: {
        name: "Composite",
        className: "Snapshot",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { time: {
                serializedName: "properties.time",
                readOnly: true,
                xmlName: "properties.time",
                type: {
                    name: "String",
                },
            } }),
    },
};
const KubeEnvironmentPatchResource = {
    serializedName: "KubeEnvironmentPatchResource",
    type: {
        name: "Composite",
        className: "KubeEnvironmentPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Succeeded",
                        "Failed",
                        "Canceled",
                        "Waiting",
                        "InitializationInProgress",
                        "InfrastructureSetupInProgress",
                        "InfrastructureSetupComplete",
                        "ScheduledForDelete",
                        "UpgradeRequested",
                        "UpgradeFailed",
                    ],
                },
            }, deploymentErrors: {
                serializedName: "properties.deploymentErrors",
                readOnly: true,
                xmlName: "properties.deploymentErrors",
                type: {
                    name: "String",
                },
            }, internalLoadBalancerEnabled: {
                serializedName: "properties.internalLoadBalancerEnabled",
                xmlName: "properties.internalLoadBalancerEnabled",
                type: {
                    name: "Boolean",
                },
            }, defaultDomain: {
                serializedName: "properties.defaultDomain",
                readOnly: true,
                xmlName: "properties.defaultDomain",
                type: {
                    name: "String",
                },
            }, staticIp: {
                serializedName: "properties.staticIp",
                xmlName: "properties.staticIp",
                type: {
                    name: "String",
                },
            }, arcConfiguration: {
                serializedName: "properties.arcConfiguration",
                xmlName: "properties.arcConfiguration",
                type: {
                    name: "Composite",
                    className: "ArcConfiguration",
                },
            }, appLogsConfiguration: {
                serializedName: "properties.appLogsConfiguration",
                xmlName: "properties.appLogsConfiguration",
                type: {
                    name: "Composite",
                    className: "AppLogsConfiguration",
                },
            }, containerAppsConfiguration: {
                serializedName: "properties.containerAppsConfiguration",
                xmlName: "properties.containerAppsConfiguration",
                type: {
                    name: "Composite",
                    className: "ContainerAppsConfiguration",
                },
            }, aksResourceID: {
                serializedName: "properties.aksResourceID",
                xmlName: "properties.aksResourceID",
                type: {
                    name: "String",
                },
            } }),
    },
};
const ApplicationStackResource = {
    serializedName: "ApplicationStackResource",
    type: {
        name: "Composite",
        className: "ApplicationStackResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { namePropertiesName: {
                serializedName: "properties.name",
                xmlName: "properties.name",
                type: {
                    name: "String",
                },
            }, display: {
                serializedName: "properties.display",
                xmlName: "properties.display",
                type: {
                    name: "String",
                },
            }, dependency: {
                serializedName: "properties.dependency",
                xmlName: "properties.dependency",
                type: {
                    name: "String",
                },
            }, majorVersions: {
                serializedName: "properties.majorVersions",
                xmlName: "properties.majorVersions",
                xmlElementName: "StackMajorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StackMajorVersion",
                        },
                    },
                },
            }, frameworks: {
                serializedName: "properties.frameworks",
                xmlName: "properties.frameworks",
                xmlElementName: "ApplicationStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStack",
                        },
                    },
                },
            }, isDeprecated: {
                serializedName: "properties.isDeprecated",
                xmlName: "properties.isDeprecated",
                xmlElementName: "ApplicationStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationStack",
                        },
                    },
                },
            } }),
    },
};
const FunctionAppStack = {
    serializedName: "FunctionAppStack",
    type: {
        name: "Composite",
        className: "FunctionAppStack",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                xmlName: "location",
                type: {
                    name: "String",
                },
            }, displayText: {
                serializedName: "properties.displayText",
                readOnly: true,
                xmlName: "properties.displayText",
                type: {
                    name: "String",
                },
            }, value: {
                serializedName: "properties.value",
                readOnly: true,
                xmlName: "properties.value",
                type: {
                    name: "String",
                },
            }, majorVersions: {
                serializedName: "properties.majorVersions",
                readOnly: true,
                xmlName: "properties.majorVersions",
                xmlElementName: "FunctionAppMajorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FunctionAppMajorVersion",
                        },
                    },
                },
            }, preferredOs: {
                serializedName: "properties.preferredOs",
                readOnly: true,
                xmlName: "properties.preferredOs",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"],
                },
            } }),
    },
};
const WebAppStack = {
    serializedName: "WebAppStack",
    type: {
        name: "Composite",
        className: "WebAppStack",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                xmlName: "location",
                type: {
                    name: "String",
                },
            }, displayText: {
                serializedName: "properties.displayText",
                readOnly: true,
                xmlName: "properties.displayText",
                type: {
                    name: "String",
                },
            }, value: {
                serializedName: "properties.value",
                readOnly: true,
                xmlName: "properties.value",
                type: {
                    name: "String",
                },
            }, majorVersions: {
                serializedName: "properties.majorVersions",
                readOnly: true,
                xmlName: "properties.majorVersions",
                xmlElementName: "WebAppMajorVersion",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebAppMajorVersion",
                        },
                    },
                },
            }, preferredOs: {
                serializedName: "properties.preferredOs",
                readOnly: true,
                xmlName: "properties.preferredOs",
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"],
                },
            } }),
    },
};
const Recommendation = {
    serializedName: "Recommendation",
    type: {
        name: "Composite",
        className: "Recommendation",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { creationTime: {
                serializedName: "properties.creationTime",
                xmlName: "properties.creationTime",
                type: {
                    name: "DateTime",
                },
            }, recommendationId: {
                serializedName: "properties.recommendationId",
                xmlName: "properties.recommendationId",
                type: {
                    name: "Uuid",
                },
            }, resourceId: {
                serializedName: "properties.resourceId",
                xmlName: "properties.resourceId",
                type: {
                    name: "String",
                },
            }, resourceScope: {
                serializedName: "properties.resourceScope",
                xmlName: "properties.resourceScope",
                type: {
                    name: "String",
                },
            }, ruleName: {
                serializedName: "properties.ruleName",
                xmlName: "properties.ruleName",
                type: {
                    name: "String",
                },
            }, displayName: {
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String",
                },
            }, message: {
                serializedName: "properties.message",
                xmlName: "properties.message",
                type: {
                    name: "String",
                },
            }, level: {
                serializedName: "properties.level",
                xmlName: "properties.level",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Critical",
                        "Warning",
                        "Information",
                        "NonUrgentSuggestion",
                    ],
                },
            }, channels: {
                serializedName: "properties.channels",
                xmlName: "properties.channels",
                type: {
                    name: "Enum",
                    allowedValues: ["Notification", "Api", "Email", "Webhook", "All"],
                },
            }, categoryTags: {
                serializedName: "properties.categoryTags",
                readOnly: true,
                xmlName: "properties.categoryTags",
                xmlElementName: "RecommendationPropertiesCategoryTagsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, actionName: {
                serializedName: "properties.actionName",
                xmlName: "properties.actionName",
                type: {
                    name: "String",
                },
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Number",
                },
            }, states: {
                serializedName: "properties.states",
                xmlName: "properties.states",
                xmlElementName: "RecommendationPropertiesStatesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, startTime: {
                serializedName: "properties.startTime",
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime",
                },
            }, endTime: {
                serializedName: "properties.endTime",
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime",
                },
            }, nextNotificationTime: {
                serializedName: "properties.nextNotificationTime",
                xmlName: "properties.nextNotificationTime",
                type: {
                    name: "DateTime",
                },
            }, notificationExpirationTime: {
                serializedName: "properties.notificationExpirationTime",
                xmlName: "properties.notificationExpirationTime",
                type: {
                    name: "DateTime",
                },
            }, notifiedTime: {
                serializedName: "properties.notifiedTime",
                xmlName: "properties.notifiedTime",
                type: {
                    name: "DateTime",
                },
            }, score: {
                serializedName: "properties.score",
                xmlName: "properties.score",
                type: {
                    name: "Number",
                },
            }, isDynamic: {
                serializedName: "properties.isDynamic",
                xmlName: "properties.isDynamic",
                type: {
                    name: "Boolean",
                },
            }, extensionName: {
                serializedName: "properties.extensionName",
                xmlName: "properties.extensionName",
                type: {
                    name: "String",
                },
            }, bladeName: {
                serializedName: "properties.bladeName",
                xmlName: "properties.bladeName",
                type: {
                    name: "String",
                },
            }, forwardLink: {
                serializedName: "properties.forwardLink",
                xmlName: "properties.forwardLink",
                type: {
                    name: "String",
                },
            } }),
    },
};
const RecommendationRule = {
    serializedName: "RecommendationRule",
    type: {
        name: "Composite",
        className: "RecommendationRule",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { recommendationName: {
                serializedName: "properties.recommendationName",
                xmlName: "properties.recommendationName",
                type: {
                    name: "String",
                },
            }, displayName: {
                serializedName: "properties.displayName",
                xmlName: "properties.displayName",
                type: {
                    name: "String",
                },
            }, message: {
                serializedName: "properties.message",
                xmlName: "properties.message",
                type: {
                    name: "String",
                },
            }, recommendationId: {
                serializedName: "properties.recommendationId",
                xmlName: "properties.recommendationId",
                type: {
                    name: "Uuid",
                },
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String",
                },
            }, actionName: {
                serializedName: "properties.actionName",
                xmlName: "properties.actionName",
                type: {
                    name: "String",
                },
            }, level: {
                serializedName: "properties.level",
                xmlName: "properties.level",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Critical",
                        "Warning",
                        "Information",
                        "NonUrgentSuggestion",
                    ],
                },
            }, channels: {
                serializedName: "properties.channels",
                xmlName: "properties.channels",
                type: {
                    name: "Enum",
                    allowedValues: ["Notification", "Api", "Email", "Webhook", "All"],
                },
            }, categoryTags: {
                serializedName: "properties.categoryTags",
                readOnly: true,
                xmlName: "properties.categoryTags",
                xmlElementName: "RecommendationRulePropertiesCategoryTagsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, isDynamic: {
                serializedName: "properties.isDynamic",
                xmlName: "properties.isDynamic",
                type: {
                    name: "Boolean",
                },
            }, extensionName: {
                serializedName: "properties.extensionName",
                xmlName: "properties.extensionName",
                type: {
                    name: "String",
                },
            }, bladeName: {
                serializedName: "properties.bladeName",
                xmlName: "properties.bladeName",
                type: {
                    name: "String",
                },
            }, forwardLink: {
                serializedName: "properties.forwardLink",
                xmlName: "properties.forwardLink",
                type: {
                    name: "String",
                },
            } }),
    },
};
const ResourceHealthMetadata = {
    serializedName: "ResourceHealthMetadata",
    type: {
        name: "Composite",
        className: "ResourceHealthMetadata",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { category: {
                serializedName: "properties.category",
                xmlName: "properties.category",
                type: {
                    name: "String",
                },
            }, signalAvailability: {
                serializedName: "properties.signalAvailability",
                xmlName: "properties.signalAvailability",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const User = {
    serializedName: "User",
    type: {
        name: "Composite",
        className: "User",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { publishingUserName: {
                serializedName: "properties.publishingUserName",
                xmlName: "properties.publishingUserName",
                type: {
                    name: "String",
                },
            }, publishingPassword: {
                serializedName: "properties.publishingPassword",
                xmlName: "properties.publishingPassword",
                type: {
                    name: "String",
                },
            }, publishingPasswordHash: {
                serializedName: "properties.publishingPasswordHash",
                xmlName: "properties.publishingPasswordHash",
                type: {
                    name: "String",
                },
            }, publishingPasswordHashSalt: {
                serializedName: "properties.publishingPasswordHashSalt",
                xmlName: "properties.publishingPasswordHashSalt",
                type: {
                    name: "String",
                },
            }, scmUri: {
                serializedName: "properties.scmUri",
                xmlName: "properties.scmUri",
                type: {
                    name: "String",
                },
            } }),
    },
};
const SourceControl = {
    serializedName: "SourceControl",
    type: {
        name: "Composite",
        className: "SourceControl",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { token: {
                serializedName: "properties.token",
                xmlName: "properties.token",
                type: {
                    name: "String",
                },
            }, tokenSecret: {
                serializedName: "properties.tokenSecret",
                xmlName: "properties.tokenSecret",
                type: {
                    name: "String",
                },
            }, refreshToken: {
                serializedName: "properties.refreshToken",
                xmlName: "properties.refreshToken",
                type: {
                    name: "String",
                },
            }, expirationTime: {
                serializedName: "properties.expirationTime",
                xmlName: "properties.expirationTime",
                type: {
                    name: "DateTime",
                },
            } }),
    },
};
const BillingMeter = {
    serializedName: "BillingMeter",
    type: {
        name: "Composite",
        className: "BillingMeter",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { meterId: {
                serializedName: "properties.meterId",
                xmlName: "properties.meterId",
                type: {
                    name: "String",
                },
            }, billingLocation: {
                serializedName: "properties.billingLocation",
                xmlName: "properties.billingLocation",
                type: {
                    name: "String",
                },
            }, shortName: {
                serializedName: "properties.shortName",
                xmlName: "properties.shortName",
                type: {
                    name: "String",
                },
            }, friendlyName: {
                serializedName: "properties.friendlyName",
                xmlName: "properties.friendlyName",
                type: {
                    name: "String",
                },
            }, resourceType: {
                serializedName: "properties.resourceType",
                xmlName: "properties.resourceType",
                type: {
                    name: "String",
                },
            }, osType: {
                serializedName: "properties.osType",
                xmlName: "properties.osType",
                type: {
                    name: "String",
                },
            }, multiplier: {
                serializedName: "properties.multiplier",
                xmlName: "properties.multiplier",
                type: {
                    name: "Number",
                },
            } }),
    },
};
const Identifier = {
    serializedName: "Identifier",
    type: {
        name: "Composite",
        className: "Identifier",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { value: {
                serializedName: "properties.id",
                xmlName: "properties.id",
                type: {
                    name: "String",
                },
            } }),
    },
};
const CustomHostnameSites = {
    serializedName: "CustomHostnameSites",
    type: {
        name: "Composite",
        className: "CustomHostnameSites",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { customHostname: {
                serializedName: "properties.customHostname",
                xmlName: "properties.customHostname",
                type: {
                    name: "String",
                },
            }, region: {
                serializedName: "properties.region",
                xmlName: "properties.region",
                type: {
                    name: "String",
                },
            }, siteResourceIds: {
                serializedName: "properties.siteResourceIds",
                xmlName: "properties.siteResourceIds",
                xmlElementName: "Identifier",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Identifier",
                        },
                    },
                },
            } }),
    },
};
const GeoRegion = {
    serializedName: "GeoRegion",
    type: {
        name: "Composite",
        className: "GeoRegion",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String",
                },
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                xmlName: "properties.displayName",
                type: {
                    name: "String",
                },
            }, orgDomain: {
                serializedName: "properties.orgDomain",
                readOnly: true,
                xmlName: "properties.orgDomain",
                type: {
                    name: "String",
                },
            } }),
    },
};
const AseRegion = {
    serializedName: "AseRegion",
    type: {
        name: "Composite",
        className: "AseRegion",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                xmlName: "properties.displayName",
                type: {
                    name: "String",
                },
            }, standard: {
                serializedName: "properties.standard",
                readOnly: true,
                xmlName: "properties.standard",
                type: {
                    name: "Boolean",
                },
            }, dedicatedHost: {
                serializedName: "properties.dedicatedHost",
                readOnly: true,
                xmlName: "properties.dedicatedHost",
                type: {
                    name: "Boolean",
                },
            }, zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                readOnly: true,
                xmlName: "properties.zoneRedundant",
                type: {
                    name: "Boolean",
                },
            }, availableSku: {
                serializedName: "properties.availableSku",
                xmlName: "properties.availableSku",
                xmlElementName: "AseRegionPropertiesAvailableSkuItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, availableOS: {
                serializedName: "properties.availableOS",
                xmlName: "properties.availableOS",
                xmlElementName: "AseRegionPropertiesAvailableOSItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            } }),
    },
};
const PremierAddOnOffer = {
    serializedName: "PremierAddOnOffer",
    type: {
        name: "Composite",
        className: "PremierAddOnOffer",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "String",
                },
            }, product: {
                serializedName: "properties.product",
                xmlName: "properties.product",
                type: {
                    name: "String",
                },
            }, vendor: {
                serializedName: "properties.vendor",
                xmlName: "properties.vendor",
                type: {
                    name: "String",
                },
            }, promoCodeRequired: {
                serializedName: "properties.promoCodeRequired",
                xmlName: "properties.promoCodeRequired",
                type: {
                    name: "Boolean",
                },
            }, quota: {
                serializedName: "properties.quota",
                xmlName: "properties.quota",
                type: {
                    name: "Number",
                },
            }, webHostingPlanRestrictions: {
                serializedName: "properties.webHostingPlanRestrictions",
                xmlName: "properties.webHostingPlanRestrictions",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "Free",
                        "Shared",
                        "Basic",
                        "Standard",
                        "Premium",
                    ],
                },
            }, privacyPolicyUrl: {
                serializedName: "properties.privacyPolicyUrl",
                xmlName: "properties.privacyPolicyUrl",
                type: {
                    name: "String",
                },
            }, legalTermsUrl: {
                serializedName: "properties.legalTermsUrl",
                xmlName: "properties.legalTermsUrl",
                type: {
                    name: "String",
                },
            }, marketplacePublisher: {
                serializedName: "properties.marketplacePublisher",
                xmlName: "properties.marketplacePublisher",
                type: {
                    name: "String",
                },
            }, marketplaceOffer: {
                serializedName: "properties.marketplaceOffer",
                xmlName: "properties.marketplaceOffer",
                type: {
                    name: "String",
                },
            } }),
    },
};
const VnetParameters = {
    serializedName: "VnetParameters",
    type: {
        name: "Composite",
        className: "VnetParameters",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { vnetResourceGroup: {
                serializedName: "properties.vnetResourceGroup",
                xmlName: "properties.vnetResourceGroup",
                type: {
                    name: "String",
                },
            }, vnetName: {
                serializedName: "properties.vnetName",
                xmlName: "properties.vnetName",
                type: {
                    name: "String",
                },
            }, vnetSubnetName: {
                serializedName: "properties.vnetSubnetName",
                xmlName: "properties.vnetSubnetName",
                type: {
                    name: "String",
                },
            }, subnetResourceId: {
                serializedName: "properties.subnetResourceId",
                xmlName: "properties.subnetResourceId",
                type: {
                    name: "String",
                },
            } }),
    },
};
const VnetValidationTestFailure = {
    serializedName: "VnetValidationTestFailure",
    type: {
        name: "Composite",
        className: "VnetValidationTestFailure",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { testName: {
                serializedName: "properties.testName",
                xmlName: "properties.testName",
                type: {
                    name: "String",
                },
            }, details: {
                serializedName: "properties.details",
                xmlName: "properties.details",
                type: {
                    name: "String",
                },
            } }),
    },
};
const VnetValidationFailureDetails = {
    serializedName: "VnetValidationFailureDetails",
    type: {
        name: "Composite",
        className: "VnetValidationFailureDetails",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { message: {
                serializedName: "properties.message",
                xmlName: "properties.message",
                type: {
                    name: "String",
                },
            }, failed: {
                serializedName: "properties.failed",
                xmlName: "properties.failed",
                type: {
                    name: "Boolean",
                },
            }, failedTests: {
                serializedName: "properties.failedTests",
                xmlName: "properties.failedTests",
                xmlElementName: "VnetValidationTestFailure",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VnetValidationTestFailure",
                        },
                    },
                },
            }, warnings: {
                serializedName: "properties.warnings",
                xmlName: "properties.warnings",
                xmlElementName: "VnetValidationTestFailure",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VnetValidationTestFailure",
                        },
                    },
                },
            } }),
    },
};
const StaticSitesWorkflowPreviewRequest = {
    serializedName: "StaticSitesWorkflowPreviewRequest",
    type: {
        name: "Composite",
        className: "StaticSitesWorkflowPreviewRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { repositoryUrl: {
                serializedName: "properties.repositoryUrl",
                xmlName: "properties.repositoryUrl",
                type: {
                    name: "String",
                },
            }, branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String",
                },
            }, buildProperties: {
                serializedName: "properties.buildProperties",
                xmlName: "properties.buildProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteBuildProperties",
                },
            } }),
    },
};
const StaticSitesWorkflowPreview = {
    serializedName: "StaticSitesWorkflowPreview",
    type: {
        name: "Composite",
        className: "StaticSitesWorkflowPreview",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { path: {
                serializedName: "properties.path",
                readOnly: true,
                xmlName: "properties.path",
                type: {
                    name: "String",
                },
            }, contents: {
                serializedName: "properties.contents",
                readOnly: true,
                xmlName: "properties.contents",
                type: {
                    name: "String",
                },
            } }),
    },
};
const RemotePrivateEndpointConnection = {
    serializedName: "RemotePrivateEndpointConnection",
    type: {
        name: "Composite",
        className: "RemotePrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String",
                },
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                xmlName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "ArmIdWrapper",
                },
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                xmlName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkConnectionState",
                },
            }, ipAddresses: {
                serializedName: "properties.ipAddresses",
                xmlName: "properties.ipAddresses",
                xmlElementName: "RemotePrivateEndpointConnectionPropertiesIpAddressesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            } }),
    },
};
const StaticSiteUserProvidedFunctionApp = {
    serializedName: "StaticSiteUserProvidedFunctionApp",
    type: {
        name: "Composite",
        className: "StaticSiteUserProvidedFunctionApp",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { functionAppResourceId: {
                serializedName: "properties.functionAppResourceId",
                xmlName: "properties.functionAppResourceId",
                type: {
                    name: "String",
                },
            }, functionAppRegion: {
                serializedName: "properties.functionAppRegion",
                xmlName: "properties.functionAppRegion",
                type: {
                    name: "String",
                },
            }, createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                xmlName: "properties.createdOn",
                type: {
                    name: "DateTime",
                },
            } }),
    },
};
const StaticSitePatchResource = {
    serializedName: "StaticSitePatchResource",
    type: {
        name: "Composite",
        className: "StaticSitePatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { defaultHostname: {
                serializedName: "properties.defaultHostname",
                readOnly: true,
                xmlName: "properties.defaultHostname",
                type: {
                    name: "String",
                },
            }, repositoryUrl: {
                serializedName: "properties.repositoryUrl",
                xmlName: "properties.repositoryUrl",
                type: {
                    name: "String",
                },
            }, branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String",
                },
            }, customDomains: {
                serializedName: "properties.customDomains",
                readOnly: true,
                xmlName: "properties.customDomains",
                xmlElementName: "StaticSiteCustomDomainsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, repositoryToken: {
                serializedName: "properties.repositoryToken",
                xmlName: "properties.repositoryToken",
                type: {
                    name: "String",
                },
            }, buildProperties: {
                serializedName: "properties.buildProperties",
                xmlName: "properties.buildProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteBuildProperties",
                },
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                xmlName: "properties.privateEndpointConnections",
                xmlElementName: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResponseMessageEnvelopeRemotePrivateEndpointConnection",
                        },
                    },
                },
            }, stagingEnvironmentPolicy: {
                serializedName: "properties.stagingEnvironmentPolicy",
                xmlName: "properties.stagingEnvironmentPolicy",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"],
                },
            }, allowConfigFileUpdates: {
                serializedName: "properties.allowConfigFileUpdates",
                xmlName: "properties.allowConfigFileUpdates",
                type: {
                    name: "Boolean",
                },
            }, templateProperties: {
                serializedName: "properties.templateProperties",
                xmlName: "properties.templateProperties",
                type: {
                    name: "Composite",
                    className: "StaticSiteTemplateOptions",
                },
            }, contentDistributionEndpoint: {
                serializedName: "properties.contentDistributionEndpoint",
                readOnly: true,
                xmlName: "properties.contentDistributionEndpoint",
                type: {
                    name: "String",
                },
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                readOnly: true,
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String",
                },
            }, userProvidedFunctionApps: {
                serializedName: "properties.userProvidedFunctionApps",
                readOnly: true,
                xmlName: "properties.userProvidedFunctionApps",
                xmlElementName: "StaticSiteUserProvidedFunctionApp",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserProvidedFunctionApp",
                        },
                    },
                },
            }, linkedBackends: {
                serializedName: "properties.linkedBackends",
                readOnly: true,
                xmlName: "properties.linkedBackends",
                xmlElementName: "StaticSiteLinkedBackend",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteLinkedBackend",
                        },
                    },
                },
            }, provider: {
                serializedName: "properties.provider",
                xmlName: "properties.provider",
                type: {
                    name: "String",
                },
            }, enterpriseGradeCdnStatus: {
                serializedName: "properties.enterpriseGradeCdnStatus",
                xmlName: "properties.enterpriseGradeCdnStatus",
                type: {
                    name: "String",
                },
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String",
                },
            }, databaseConnections: {
                serializedName: "properties.databaseConnections",
                readOnly: true,
                xmlName: "properties.databaseConnections",
                xmlElementName: "DatabaseConnectionOverview",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseConnectionOverview",
                        },
                    },
                },
            } }),
    },
};
const StaticSiteUserARMResource = {
    serializedName: "StaticSiteUserARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteUserARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { provider: {
                serializedName: "properties.provider",
                readOnly: true,
                xmlName: "properties.provider",
                type: {
                    name: "String",
                },
            }, userId: {
                serializedName: "properties.userId",
                readOnly: true,
                xmlName: "properties.userId",
                type: {
                    name: "String",
                },
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                xmlName: "properties.displayName",
                type: {
                    name: "String",
                },
            }, roles: {
                serializedName: "properties.roles",
                xmlName: "properties.roles",
                type: {
                    name: "String",
                },
            } }),
    },
};
const StaticSiteBuildARMResource = {
    serializedName: "StaticSiteBuildARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteBuildARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { buildId: {
                serializedName: "properties.buildId",
                readOnly: true,
                xmlName: "properties.buildId",
                type: {
                    name: "String",
                },
            }, sourceBranch: {
                serializedName: "properties.sourceBranch",
                readOnly: true,
                xmlName: "properties.sourceBranch",
                type: {
                    name: "String",
                },
            }, pullRequestTitle: {
                serializedName: "properties.pullRequestTitle",
                readOnly: true,
                xmlName: "properties.pullRequestTitle",
                type: {
                    name: "String",
                },
            }, hostname: {
                serializedName: "properties.hostname",
                readOnly: true,
                xmlName: "properties.hostname",
                type: {
                    name: "String",
                },
            }, createdTimeUtc: {
                serializedName: "properties.createdTimeUtc",
                readOnly: true,
                xmlName: "properties.createdTimeUtc",
                type: {
                    name: "DateTime",
                },
            }, lastUpdatedOn: {
                serializedName: "properties.lastUpdatedOn",
                readOnly: true,
                xmlName: "properties.lastUpdatedOn",
                type: {
                    name: "DateTime",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String",
                },
            }, userProvidedFunctionApps: {
                serializedName: "properties.userProvidedFunctionApps",
                readOnly: true,
                xmlName: "properties.userProvidedFunctionApps",
                xmlElementName: "StaticSiteUserProvidedFunctionApp",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteUserProvidedFunctionApp",
                        },
                    },
                },
            }, linkedBackends: {
                serializedName: "properties.linkedBackends",
                readOnly: true,
                xmlName: "properties.linkedBackends",
                xmlElementName: "StaticSiteLinkedBackend",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteLinkedBackend",
                        },
                    },
                },
            }, databaseConnections: {
                serializedName: "properties.databaseConnections",
                readOnly: true,
                xmlName: "properties.databaseConnections",
                xmlElementName: "DatabaseConnectionOverview",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseConnectionOverview",
                        },
                    },
                },
            } }),
    },
};
const StringDictionary = {
    serializedName: "StringDictionary",
    type: {
        name: "Composite",
        className: "StringDictionary",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            } }),
    },
};
const DatabaseConnection = {
    serializedName: "DatabaseConnection",
    type: {
        name: "Composite",
        className: "DatabaseConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { resourceId: {
                serializedName: "properties.resourceId",
                xmlName: "properties.resourceId",
                type: {
                    name: "String",
                },
            }, connectionIdentity: {
                serializedName: "properties.connectionIdentity",
                xmlName: "properties.connectionIdentity",
                type: {
                    name: "String",
                },
            }, connectionString: {
                serializedName: "properties.connectionString",
                xmlName: "properties.connectionString",
                type: {
                    name: "String",
                },
            }, region: {
                serializedName: "properties.region",
                xmlName: "properties.region",
                type: {
                    name: "String",
                },
            }, configurationFiles: {
                serializedName: "properties.configurationFiles",
                readOnly: true,
                xmlName: "properties.configurationFiles",
                xmlElementName: "StaticSiteDatabaseConnectionConfigurationFileOverview",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticSiteDatabaseConnectionConfigurationFileOverview",
                        },
                    },
                },
            } }),
    },
};
const StaticSiteFunctionOverviewARMResource = {
    serializedName: "StaticSiteFunctionOverviewARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteFunctionOverviewARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { functionName: {
                serializedName: "properties.functionName",
                readOnly: true,
                xmlName: "properties.functionName",
                type: {
                    name: "String",
                },
            }, triggerType: {
                serializedName: "properties.triggerType",
                readOnly: true,
                xmlName: "properties.triggerType",
                type: {
                    name: "String",
                },
            } }),
    },
};
const StaticSiteUserProvidedFunctionAppARMResource = {
    serializedName: "StaticSiteUserProvidedFunctionAppARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteUserProvidedFunctionAppARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { functionAppResourceId: {
                serializedName: "properties.functionAppResourceId",
                xmlName: "properties.functionAppResourceId",
                type: {
                    name: "String",
                },
            }, functionAppRegion: {
                serializedName: "properties.functionAppRegion",
                xmlName: "properties.functionAppRegion",
                type: {
                    name: "String",
                },
            }, createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                xmlName: "properties.createdOn",
                type: {
                    name: "DateTime",
                },
            } }),
    },
};
const StaticSiteZipDeploymentARMResource = {
    serializedName: "StaticSiteZipDeploymentARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteZipDeploymentARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { appZipUrl: {
                serializedName: "properties.appZipUrl",
                xmlName: "properties.appZipUrl",
                type: {
                    name: "String",
                },
            }, apiZipUrl: {
                serializedName: "properties.apiZipUrl",
                xmlName: "properties.apiZipUrl",
                type: {
                    name: "String",
                },
            }, deploymentTitle: {
                serializedName: "properties.deploymentTitle",
                xmlName: "properties.deploymentTitle",
                type: {
                    name: "String",
                },
            }, provider: {
                serializedName: "properties.provider",
                xmlName: "properties.provider",
                type: {
                    name: "String",
                },
            }, functionLanguage: {
                serializedName: "properties.functionLanguage",
                xmlName: "properties.functionLanguage",
                type: {
                    name: "String",
                },
            } }),
    },
};
const StaticSiteBasicAuthPropertiesARMResource = {
    serializedName: "StaticSiteBasicAuthPropertiesARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteBasicAuthPropertiesARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { password: {
                serializedName: "properties.password",
                xmlName: "properties.password",
                type: {
                    name: "String",
                },
            }, secretUrl: {
                serializedName: "properties.secretUrl",
                xmlName: "properties.secretUrl",
                type: {
                    name: "String",
                },
            }, applicableEnvironmentsMode: {
                serializedName: "properties.applicableEnvironmentsMode",
                xmlName: "properties.applicableEnvironmentsMode",
                type: {
                    name: "String",
                },
            }, environments: {
                serializedName: "properties.environments",
                xmlName: "properties.environments",
                xmlElementName: "StaticSiteBasicAuthPropertiesARMResourcePropertiesEnvironmentsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, secretState: {
                serializedName: "properties.secretState",
                readOnly: true,
                xmlName: "properties.secretState",
                type: {
                    name: "String",
                },
            } }),
    },
};
const StaticSiteUserInvitationRequestResource = {
    serializedName: "StaticSiteUserInvitationRequestResource",
    type: {
        name: "Composite",
        className: "StaticSiteUserInvitationRequestResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { domain: {
                serializedName: "properties.domain",
                xmlName: "properties.domain",
                type: {
                    name: "String",
                },
            }, provider: {
                serializedName: "properties.provider",
                xmlName: "properties.provider",
                type: {
                    name: "String",
                },
            }, userDetails: {
                serializedName: "properties.userDetails",
                xmlName: "properties.userDetails",
                type: {
                    name: "String",
                },
            }, roles: {
                serializedName: "properties.roles",
                xmlName: "properties.roles",
                type: {
                    name: "String",
                },
            }, numHoursToExpiration: {
                serializedName: "properties.numHoursToExpiration",
                xmlName: "properties.numHoursToExpiration",
                type: {
                    name: "Number",
                },
            } }),
    },
};
const StaticSiteUserInvitationResponseResource = {
    serializedName: "StaticSiteUserInvitationResponseResource",
    type: {
        name: "Composite",
        className: "StaticSiteUserInvitationResponseResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { expiresOn: {
                serializedName: "properties.expiresOn",
                readOnly: true,
                xmlName: "properties.expiresOn",
                type: {
                    name: "DateTime",
                },
            }, invitationUrl: {
                serializedName: "properties.invitationUrl",
                readOnly: true,
                xmlName: "properties.invitationUrl",
                type: {
                    name: "String",
                },
            } }),
    },
};
const StaticSiteCustomDomainOverviewARMResource = {
    serializedName: "StaticSiteCustomDomainOverviewARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteCustomDomainOverviewARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { domainName: {
                serializedName: "properties.domainName",
                readOnly: true,
                xmlName: "properties.domainName",
                type: {
                    name: "String",
                },
            }, createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                xmlName: "properties.createdOn",
                type: {
                    name: "DateTime",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String",
                },
            }, validationToken: {
                serializedName: "properties.validationToken",
                readOnly: true,
                xmlName: "properties.validationToken",
                type: {
                    name: "String",
                },
            }, errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                xmlName: "properties.errorMessage",
                type: {
                    name: "String",
                },
            } }),
    },
};
const StaticSiteCustomDomainRequestPropertiesARMResource = {
    serializedName: "StaticSiteCustomDomainRequestPropertiesARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteCustomDomainRequestPropertiesARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { validationMethod: {
                defaultValue: "cname-delegation",
                serializedName: "properties.validationMethod",
                xmlName: "properties.validationMethod",
                type: {
                    name: "String",
                },
            } }),
    },
};
const StringList = {
    serializedName: "StringList",
    type: {
        name: "Composite",
        className: "StringList",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                xmlElementName: "StringListPropertiesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            } }),
    },
};
const StaticSiteResetPropertiesARMResource = {
    serializedName: "StaticSiteResetPropertiesARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteResetPropertiesARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { repositoryToken: {
                serializedName: "properties.repositoryToken",
                xmlName: "properties.repositoryToken",
                type: {
                    name: "String",
                },
            }, shouldUpdateRepository: {
                serializedName: "properties.shouldUpdateRepository",
                xmlName: "properties.shouldUpdateRepository",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const StaticSiteLinkedBackendARMResource = {
    serializedName: "StaticSiteLinkedBackendARMResource",
    type: {
        name: "Composite",
        className: "StaticSiteLinkedBackendARMResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { backendResourceId: {
                serializedName: "properties.backendResourceId",
                xmlName: "properties.backendResourceId",
                type: {
                    name: "String",
                },
            }, region: {
                serializedName: "properties.region",
                xmlName: "properties.region",
                type: {
                    name: "String",
                },
            }, createdOn: {
                serializedName: "properties.createdOn",
                readOnly: true,
                xmlName: "properties.createdOn",
                type: {
                    name: "DateTime",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String",
                },
            } }),
    },
};
const SitePatchResource = {
    serializedName: "SitePatchResource",
    type: {
        name: "Composite",
        className: "SitePatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity",
                },
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                xmlName: "properties.state",
                type: {
                    name: "String",
                },
            }, hostNames: {
                serializedName: "properties.hostNames",
                readOnly: true,
                xmlName: "properties.hostNames",
                xmlElementName: "SitePatchResourcePropertiesHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, repositorySiteName: {
                serializedName: "properties.repositorySiteName",
                readOnly: true,
                xmlName: "properties.repositorySiteName",
                type: {
                    name: "String",
                },
            }, usageState: {
                serializedName: "properties.usageState",
                readOnly: true,
                xmlName: "properties.usageState",
                type: {
                    name: "Enum",
                    allowedValues: ["Normal", "Exceeded"],
                },
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean",
                },
            }, enabledHostNames: {
                serializedName: "properties.enabledHostNames",
                readOnly: true,
                xmlName: "properties.enabledHostNames",
                xmlElementName: "SitePatchResourcePropertiesEnabledHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, availabilityState: {
                serializedName: "properties.availabilityState",
                readOnly: true,
                xmlName: "properties.availabilityState",
                type: {
                    name: "Enum",
                    allowedValues: ["Normal", "Limited", "DisasterRecoveryMode"],
                },
            }, hostNameSslStates: {
                serializedName: "properties.hostNameSslStates",
                xmlName: "properties.hostNameSslStates",
                xmlElementName: "HostNameSslState",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostNameSslState",
                        },
                    },
                },
            }, serverFarmId: {
                serializedName: "properties.serverFarmId",
                xmlName: "properties.serverFarmId",
                type: {
                    name: "String",
                },
            }, reserved: {
                defaultValue: false,
                serializedName: "properties.reserved",
                xmlName: "properties.reserved",
                type: {
                    name: "Boolean",
                },
            }, isXenon: {
                defaultValue: false,
                serializedName: "properties.isXenon",
                xmlName: "properties.isXenon",
                type: {
                    name: "Boolean",
                },
            }, hyperV: {
                defaultValue: false,
                serializedName: "properties.hyperV",
                xmlName: "properties.hyperV",
                type: {
                    name: "Boolean",
                },
            }, lastModifiedTimeUtc: {
                serializedName: "properties.lastModifiedTimeUtc",
                readOnly: true,
                xmlName: "properties.lastModifiedTimeUtc",
                type: {
                    name: "DateTime",
                },
            }, dnsConfiguration: {
                serializedName: "properties.dnsConfiguration",
                xmlName: "properties.dnsConfiguration",
                type: {
                    name: "Composite",
                    className: "SiteDnsConfig",
                },
            }, siteConfig: {
                serializedName: "properties.siteConfig",
                xmlName: "properties.siteConfig",
                type: {
                    name: "Composite",
                    className: "SiteConfig",
                },
            }, trafficManagerHostNames: {
                serializedName: "properties.trafficManagerHostNames",
                readOnly: true,
                xmlName: "properties.trafficManagerHostNames",
                xmlElementName: "SitePatchResourcePropertiesTrafficManagerHostNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, scmSiteAlsoStopped: {
                defaultValue: false,
                serializedName: "properties.scmSiteAlsoStopped",
                xmlName: "properties.scmSiteAlsoStopped",
                type: {
                    name: "Boolean",
                },
            }, targetSwapSlot: {
                serializedName: "properties.targetSwapSlot",
                readOnly: true,
                xmlName: "properties.targetSwapSlot",
                type: {
                    name: "String",
                },
            }, hostingEnvironmentProfile: {
                serializedName: "properties.hostingEnvironmentProfile",
                xmlName: "properties.hostingEnvironmentProfile",
                type: {
                    name: "Composite",
                    className: "HostingEnvironmentProfile",
                },
            }, clientAffinityEnabled: {
                serializedName: "properties.clientAffinityEnabled",
                xmlName: "properties.clientAffinityEnabled",
                type: {
                    name: "Boolean",
                },
            }, clientCertEnabled: {
                serializedName: "properties.clientCertEnabled",
                xmlName: "properties.clientCertEnabled",
                type: {
                    name: "Boolean",
                },
            }, clientCertMode: {
                serializedName: "properties.clientCertMode",
                xmlName: "properties.clientCertMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Required", "Optional", "OptionalInteractiveUser"],
                },
            }, clientCertExclusionPaths: {
                serializedName: "properties.clientCertExclusionPaths",
                xmlName: "properties.clientCertExclusionPaths",
                type: {
                    name: "String",
                },
            }, hostNamesDisabled: {
                serializedName: "properties.hostNamesDisabled",
                xmlName: "properties.hostNamesDisabled",
                type: {
                    name: "Boolean",
                },
            }, customDomainVerificationId: {
                serializedName: "properties.customDomainVerificationId",
                xmlName: "properties.customDomainVerificationId",
                type: {
                    name: "String",
                },
            }, outboundIpAddresses: {
                serializedName: "properties.outboundIpAddresses",
                readOnly: true,
                xmlName: "properties.outboundIpAddresses",
                type: {
                    name: "String",
                },
            }, possibleOutboundIpAddresses: {
                serializedName: "properties.possibleOutboundIpAddresses",
                readOnly: true,
                xmlName: "properties.possibleOutboundIpAddresses",
                type: {
                    name: "String",
                },
            }, containerSize: {
                serializedName: "properties.containerSize",
                xmlName: "properties.containerSize",
                type: {
                    name: "Number",
                },
            }, dailyMemoryTimeQuota: {
                serializedName: "properties.dailyMemoryTimeQuota",
                xmlName: "properties.dailyMemoryTimeQuota",
                type: {
                    name: "Number",
                },
            }, suspendedTill: {
                serializedName: "properties.suspendedTill",
                readOnly: true,
                xmlName: "properties.suspendedTill",
                type: {
                    name: "DateTime",
                },
            }, maxNumberOfWorkers: {
                serializedName: "properties.maxNumberOfWorkers",
                readOnly: true,
                xmlName: "properties.maxNumberOfWorkers",
                type: {
                    name: "Number",
                },
            }, cloningInfo: {
                serializedName: "properties.cloningInfo",
                xmlName: "properties.cloningInfo",
                type: {
                    name: "Composite",
                    className: "CloningInfo",
                },
            }, resourceGroup: {
                serializedName: "properties.resourceGroup",
                readOnly: true,
                xmlName: "properties.resourceGroup",
                type: {
                    name: "String",
                },
            }, isDefaultContainer: {
                serializedName: "properties.isDefaultContainer",
                readOnly: true,
                xmlName: "properties.isDefaultContainer",
                type: {
                    name: "Boolean",
                },
            }, defaultHostName: {
                serializedName: "properties.defaultHostName",
                readOnly: true,
                xmlName: "properties.defaultHostName",
                type: {
                    name: "String",
                },
            }, slotSwapStatus: {
                serializedName: "properties.slotSwapStatus",
                xmlName: "properties.slotSwapStatus",
                type: {
                    name: "Composite",
                    className: "SlotSwapStatus",
                },
            }, httpsOnly: {
                serializedName: "properties.httpsOnly",
                xmlName: "properties.httpsOnly",
                type: {
                    name: "Boolean",
                },
            }, redundancyMode: {
                serializedName: "properties.redundancyMode",
                xmlName: "properties.redundancyMode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "None",
                        "Manual",
                        "Failover",
                        "ActiveActive",
                        "GeoRedundant",
                    ],
                },
            }, inProgressOperationId: {
                serializedName: "properties.inProgressOperationId",
                readOnly: true,
                xmlName: "properties.inProgressOperationId",
                type: {
                    name: "Uuid",
                },
            }, storageAccountRequired: {
                serializedName: "properties.storageAccountRequired",
                xmlName: "properties.storageAccountRequired",
                type: {
                    name: "Boolean",
                },
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String",
                },
            }, virtualNetworkSubnetId: {
                serializedName: "properties.virtualNetworkSubnetId",
                xmlName: "properties.virtualNetworkSubnetId",
                type: {
                    name: "String",
                },
            } }),
    },
};
const CustomHostnameAnalysisResult = {
    serializedName: "CustomHostnameAnalysisResult",
    type: {
        name: "Composite",
        className: "CustomHostnameAnalysisResult",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { isHostnameAlreadyVerified: {
                serializedName: "properties.isHostnameAlreadyVerified",
                readOnly: true,
                xmlName: "properties.isHostnameAlreadyVerified",
                type: {
                    name: "Boolean",
                },
            }, customDomainVerificationTest: {
                serializedName: "properties.customDomainVerificationTest",
                readOnly: true,
                xmlName: "properties.customDomainVerificationTest",
                type: {
                    name: "Enum",
                    allowedValues: ["Passed", "Failed", "Skipped"],
                },
            }, customDomainVerificationFailureInfo: {
                serializedName: "properties.customDomainVerificationFailureInfo",
                xmlName: "properties.customDomainVerificationFailureInfo",
                type: {
                    name: "Composite",
                    className: "ErrorEntity",
                },
            }, hasConflictOnScaleUnit: {
                serializedName: "properties.hasConflictOnScaleUnit",
                readOnly: true,
                xmlName: "properties.hasConflictOnScaleUnit",
                type: {
                    name: "Boolean",
                },
            }, hasConflictAcrossSubscription: {
                serializedName: "properties.hasConflictAcrossSubscription",
                readOnly: true,
                xmlName: "properties.hasConflictAcrossSubscription",
                type: {
                    name: "Boolean",
                },
            }, conflictingAppResourceId: {
                serializedName: "properties.conflictingAppResourceId",
                readOnly: true,
                xmlName: "properties.conflictingAppResourceId",
                type: {
                    name: "String",
                },
            }, cNameRecords: {
                serializedName: "properties.cNameRecords",
                xmlName: "properties.cNameRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesCNameRecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, txtRecords: {
                serializedName: "properties.txtRecords",
                xmlName: "properties.txtRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesTxtRecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, aRecords: {
                serializedName: "properties.aRecords",
                xmlName: "properties.aRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesARecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, alternateCNameRecords: {
                serializedName: "properties.alternateCNameRecords",
                xmlName: "properties.alternateCNameRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesAlternateCNameRecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, alternateTxtRecords: {
                serializedName: "properties.alternateTxtRecords",
                xmlName: "properties.alternateTxtRecords",
                xmlElementName: "CustomHostnameAnalysisResultPropertiesAlternateTxtRecordsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            } }),
    },
};
const BackupRequest = {
    serializedName: "BackupRequest",
    type: {
        name: "Composite",
        className: "BackupRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { backupName: {
                serializedName: "properties.backupName",
                xmlName: "properties.backupName",
                type: {
                    name: "String",
                },
            }, enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean",
                },
            }, storageAccountUrl: {
                serializedName: "properties.storageAccountUrl",
                xmlName: "properties.storageAccountUrl",
                type: {
                    name: "String",
                },
            }, backupSchedule: {
                serializedName: "properties.backupSchedule",
                xmlName: "properties.backupSchedule",
                type: {
                    name: "Composite",
                    className: "BackupSchedule",
                },
            }, databases: {
                serializedName: "properties.databases",
                xmlName: "properties.databases",
                xmlElementName: "DatabaseBackupSetting",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseBackupSetting",
                        },
                    },
                },
            } }),
    },
};
const BackupItem = {
    serializedName: "BackupItem",
    type: {
        name: "Composite",
        className: "BackupItem",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { backupId: {
                serializedName: "properties.id",
                readOnly: true,
                xmlName: "properties.id",
                type: {
                    name: "Number",
                },
            }, storageAccountUrl: {
                serializedName: "properties.storageAccountUrl",
                readOnly: true,
                xmlName: "properties.storageAccountUrl",
                type: {
                    name: "String",
                },
            }, blobName: {
                serializedName: "properties.blobName",
                readOnly: true,
                xmlName: "properties.blobName",
                type: {
                    name: "String",
                },
            }, namePropertiesName: {
                serializedName: "properties.name",
                readOnly: true,
                xmlName: "properties.name",
                type: {
                    name: "String",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "InProgress",
                        "Failed",
                        "Succeeded",
                        "TimedOut",
                        "Created",
                        "Skipped",
                        "PartiallySucceeded",
                        "DeleteInProgress",
                        "DeleteFailed",
                        "Deleted",
                    ],
                },
            }, sizeInBytes: {
                serializedName: "properties.sizeInBytes",
                readOnly: true,
                xmlName: "properties.sizeInBytes",
                type: {
                    name: "Number",
                },
            }, created: {
                serializedName: "properties.created",
                readOnly: true,
                xmlName: "properties.created",
                type: {
                    name: "DateTime",
                },
            }, log: {
                serializedName: "properties.log",
                readOnly: true,
                xmlName: "properties.log",
                type: {
                    name: "String",
                },
            }, databases: {
                serializedName: "properties.databases",
                readOnly: true,
                xmlName: "properties.databases",
                xmlElementName: "DatabaseBackupSetting",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseBackupSetting",
                        },
                    },
                },
            }, scheduled: {
                serializedName: "properties.scheduled",
                readOnly: true,
                xmlName: "properties.scheduled",
                type: {
                    name: "Boolean",
                },
            }, lastRestoreTimeStamp: {
                serializedName: "properties.lastRestoreTimeStamp",
                readOnly: true,
                xmlName: "properties.lastRestoreTimeStamp",
                type: {
                    name: "DateTime",
                },
            }, finishedTimeStamp: {
                serializedName: "properties.finishedTimeStamp",
                readOnly: true,
                xmlName: "properties.finishedTimeStamp",
                type: {
                    name: "DateTime",
                },
            }, correlationId: {
                serializedName: "properties.correlationId",
                readOnly: true,
                xmlName: "properties.correlationId",
                type: {
                    name: "String",
                },
            }, websiteSizeInBytes: {
                serializedName: "properties.websiteSizeInBytes",
                readOnly: true,
                xmlName: "properties.websiteSizeInBytes",
                type: {
                    name: "Number",
                },
            } }),
    },
};
const RestoreRequest = {
    serializedName: "RestoreRequest",
    type: {
        name: "Composite",
        className: "RestoreRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { storageAccountUrl: {
                serializedName: "properties.storageAccountUrl",
                xmlName: "properties.storageAccountUrl",
                type: {
                    name: "String",
                },
            }, blobName: {
                serializedName: "properties.blobName",
                xmlName: "properties.blobName",
                type: {
                    name: "String",
                },
            }, overwrite: {
                serializedName: "properties.overwrite",
                xmlName: "properties.overwrite",
                type: {
                    name: "Boolean",
                },
            }, siteName: {
                serializedName: "properties.siteName",
                xmlName: "properties.siteName",
                type: {
                    name: "String",
                },
            }, databases: {
                serializedName: "properties.databases",
                xmlName: "properties.databases",
                xmlElementName: "DatabaseBackupSetting",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseBackupSetting",
                        },
                    },
                },
            }, ignoreConflictingHostNames: {
                defaultValue: false,
                serializedName: "properties.ignoreConflictingHostNames",
                xmlName: "properties.ignoreConflictingHostNames",
                type: {
                    name: "Boolean",
                },
            }, ignoreDatabases: {
                defaultValue: false,
                serializedName: "properties.ignoreDatabases",
                xmlName: "properties.ignoreDatabases",
                type: {
                    name: "Boolean",
                },
            }, appServicePlan: {
                serializedName: "properties.appServicePlan",
                xmlName: "properties.appServicePlan",
                type: {
                    name: "String",
                },
            }, operationType: {
                defaultValue: "Default",
                serializedName: "properties.operationType",
                xmlName: "properties.operationType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Default",
                        "Clone",
                        "Relocation",
                        "Snapshot",
                        "CloudFS",
                    ],
                },
            }, adjustConnectionStrings: {
                serializedName: "properties.adjustConnectionStrings",
                xmlName: "properties.adjustConnectionStrings",
                type: {
                    name: "Boolean",
                },
            }, hostingEnvironment: {
                serializedName: "properties.hostingEnvironment",
                xmlName: "properties.hostingEnvironment",
                type: {
                    name: "String",
                },
            } }),
    },
};
const CsmPublishingCredentialsPoliciesEntity = {
    serializedName: "CsmPublishingCredentialsPoliciesEntity",
    type: {
        name: "Composite",
        className: "CsmPublishingCredentialsPoliciesEntity",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { allow: {
                serializedName: "properties.allow",
                xmlName: "properties.allow",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const SiteConfigResource = {
    serializedName: "SiteConfigResource",
    type: {
        name: "Composite",
        className: "SiteConfigResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { numberOfWorkers: {
                serializedName: "properties.numberOfWorkers",
                xmlName: "properties.numberOfWorkers",
                type: {
                    name: "Number",
                },
            }, defaultDocuments: {
                serializedName: "properties.defaultDocuments",
                xmlName: "properties.defaultDocuments",
                xmlElementName: "SiteConfigDefaultDocumentsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, netFrameworkVersion: {
                defaultValue: "v4.6",
                serializedName: "properties.netFrameworkVersion",
                xmlName: "properties.netFrameworkVersion",
                type: {
                    name: "String",
                },
            }, phpVersion: {
                serializedName: "properties.phpVersion",
                xmlName: "properties.phpVersion",
                type: {
                    name: "String",
                },
            }, pythonVersion: {
                serializedName: "properties.pythonVersion",
                xmlName: "properties.pythonVersion",
                type: {
                    name: "String",
                },
            }, nodeVersion: {
                serializedName: "properties.nodeVersion",
                xmlName: "properties.nodeVersion",
                type: {
                    name: "String",
                },
            }, powerShellVersion: {
                serializedName: "properties.powerShellVersion",
                xmlName: "properties.powerShellVersion",
                type: {
                    name: "String",
                },
            }, linuxFxVersion: {
                serializedName: "properties.linuxFxVersion",
                xmlName: "properties.linuxFxVersion",
                type: {
                    name: "String",
                },
            }, windowsFxVersion: {
                serializedName: "properties.windowsFxVersion",
                xmlName: "properties.windowsFxVersion",
                type: {
                    name: "String",
                },
            }, requestTracingEnabled: {
                serializedName: "properties.requestTracingEnabled",
                xmlName: "properties.requestTracingEnabled",
                type: {
                    name: "Boolean",
                },
            }, requestTracingExpirationTime: {
                serializedName: "properties.requestTracingExpirationTime",
                xmlName: "properties.requestTracingExpirationTime",
                type: {
                    name: "DateTime",
                },
            }, remoteDebuggingEnabled: {
                serializedName: "properties.remoteDebuggingEnabled",
                xmlName: "properties.remoteDebuggingEnabled",
                type: {
                    name: "Boolean",
                },
            }, remoteDebuggingVersion: {
                serializedName: "properties.remoteDebuggingVersion",
                xmlName: "properties.remoteDebuggingVersion",
                type: {
                    name: "String",
                },
            }, httpLoggingEnabled: {
                serializedName: "properties.httpLoggingEnabled",
                xmlName: "properties.httpLoggingEnabled",
                type: {
                    name: "Boolean",
                },
            }, acrUseManagedIdentityCreds: {
                serializedName: "properties.acrUseManagedIdentityCreds",
                xmlName: "properties.acrUseManagedIdentityCreds",
                type: {
                    name: "Boolean",
                },
            }, acrUserManagedIdentityID: {
                serializedName: "properties.acrUserManagedIdentityID",
                xmlName: "properties.acrUserManagedIdentityID",
                type: {
                    name: "String",
                },
            }, logsDirectorySizeLimit: {
                serializedName: "properties.logsDirectorySizeLimit",
                xmlName: "properties.logsDirectorySizeLimit",
                type: {
                    name: "Number",
                },
            }, detailedErrorLoggingEnabled: {
                serializedName: "properties.detailedErrorLoggingEnabled",
                xmlName: "properties.detailedErrorLoggingEnabled",
                type: {
                    name: "Boolean",
                },
            }, publishingUsername: {
                serializedName: "properties.publishingUsername",
                xmlName: "properties.publishingUsername",
                type: {
                    name: "String",
                },
            }, appSettings: {
                serializedName: "properties.appSettings",
                xmlName: "properties.appSettings",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair",
                        },
                    },
                },
            }, metadata: {
                serializedName: "properties.metadata",
                xmlName: "properties.metadata",
                xmlElementName: "NameValuePair",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NameValuePair",
                        },
                    },
                },
            }, connectionStrings: {
                serializedName: "properties.connectionStrings",
                xmlName: "properties.connectionStrings",
                xmlElementName: "ConnStringInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnStringInfo",
                        },
                    },
                },
            }, machineKey: {
                serializedName: "properties.machineKey",
                xmlName: "properties.machineKey",
                type: {
                    name: "Composite",
                    className: "SiteMachineKey",
                },
            }, handlerMappings: {
                serializedName: "properties.handlerMappings",
                xmlName: "properties.handlerMappings",
                xmlElementName: "HandlerMapping",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HandlerMapping",
                        },
                    },
                },
            }, documentRoot: {
                serializedName: "properties.documentRoot",
                xmlName: "properties.documentRoot",
                type: {
                    name: "String",
                },
            }, scmType: {
                serializedName: "properties.scmType",
                xmlName: "properties.scmType",
                type: {
                    name: "String",
                },
            }, use32BitWorkerProcess: {
                serializedName: "properties.use32BitWorkerProcess",
                xmlName: "properties.use32BitWorkerProcess",
                type: {
                    name: "Boolean",
                },
            }, webSocketsEnabled: {
                serializedName: "properties.webSocketsEnabled",
                xmlName: "properties.webSocketsEnabled",
                type: {
                    name: "Boolean",
                },
            }, alwaysOn: {
                serializedName: "properties.alwaysOn",
                xmlName: "properties.alwaysOn",
                type: {
                    name: "Boolean",
                },
            }, javaVersion: {
                serializedName: "properties.javaVersion",
                xmlName: "properties.javaVersion",
                type: {
                    name: "String",
                },
            }, javaContainer: {
                serializedName: "properties.javaContainer",
                xmlName: "properties.javaContainer",
                type: {
                    name: "String",
                },
            }, javaContainerVersion: {
                serializedName: "properties.javaContainerVersion",
                xmlName: "properties.javaContainerVersion",
                type: {
                    name: "String",
                },
            }, appCommandLine: {
                serializedName: "properties.appCommandLine",
                xmlName: "properties.appCommandLine",
                type: {
                    name: "String",
                },
            }, managedPipelineMode: {
                serializedName: "properties.managedPipelineMode",
                xmlName: "properties.managedPipelineMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Integrated", "Classic"],
                },
            }, virtualApplications: {
                serializedName: "properties.virtualApplications",
                xmlName: "properties.virtualApplications",
                xmlElementName: "VirtualApplication",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualApplication",
                        },
                    },
                },
            }, loadBalancing: {
                serializedName: "properties.loadBalancing",
                xmlName: "properties.loadBalancing",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "WeightedRoundRobin",
                        "LeastRequests",
                        "LeastResponseTime",
                        "WeightedTotalTraffic",
                        "RequestHash",
                        "PerSiteRoundRobin",
                    ],
                },
            }, experiments: {
                serializedName: "properties.experiments",
                xmlName: "properties.experiments",
                type: {
                    name: "Composite",
                    className: "Experiments",
                },
            }, limits: {
                serializedName: "properties.limits",
                xmlName: "properties.limits",
                type: {
                    name: "Composite",
                    className: "SiteLimits",
                },
            }, autoHealEnabled: {
                serializedName: "properties.autoHealEnabled",
                xmlName: "properties.autoHealEnabled",
                type: {
                    name: "Boolean",
                },
            }, autoHealRules: {
                serializedName: "properties.autoHealRules",
                xmlName: "properties.autoHealRules",
                type: {
                    name: "Composite",
                    className: "AutoHealRules",
                },
            }, tracingOptions: {
                serializedName: "properties.tracingOptions",
                xmlName: "properties.tracingOptions",
                type: {
                    name: "String",
                },
            }, vnetName: {
                serializedName: "properties.vnetName",
                xmlName: "properties.vnetName",
                type: {
                    name: "String",
                },
            }, vnetRouteAllEnabled: {
                serializedName: "properties.vnetRouteAllEnabled",
                xmlName: "properties.vnetRouteAllEnabled",
                type: {
                    name: "Boolean",
                },
            }, vnetPrivatePortsCount: {
                serializedName: "properties.vnetPrivatePortsCount",
                xmlName: "properties.vnetPrivatePortsCount",
                type: {
                    name: "Number",
                },
            }, cors: {
                serializedName: "properties.cors",
                xmlName: "properties.cors",
                type: {
                    name: "Composite",
                    className: "CorsSettings",
                },
            }, push: {
                serializedName: "properties.push",
                xmlName: "properties.push",
                type: {
                    name: "Composite",
                    className: "PushSettings",
                },
            }, apiDefinition: {
                serializedName: "properties.apiDefinition",
                xmlName: "properties.apiDefinition",
                type: {
                    name: "Composite",
                    className: "ApiDefinitionInfo",
                },
            }, apiManagementConfig: {
                serializedName: "properties.apiManagementConfig",
                xmlName: "properties.apiManagementConfig",
                type: {
                    name: "Composite",
                    className: "ApiManagementConfig",
                },
            }, autoSwapSlotName: {
                serializedName: "properties.autoSwapSlotName",
                xmlName: "properties.autoSwapSlotName",
                type: {
                    name: "String",
                },
            }, localMySqlEnabled: {
                defaultValue: false,
                serializedName: "properties.localMySqlEnabled",
                xmlName: "properties.localMySqlEnabled",
                type: {
                    name: "Boolean",
                },
            }, managedServiceIdentityId: {
                serializedName: "properties.managedServiceIdentityId",
                xmlName: "properties.managedServiceIdentityId",
                type: {
                    name: "Number",
                },
            }, xManagedServiceIdentityId: {
                serializedName: "properties.xManagedServiceIdentityId",
                xmlName: "properties.xManagedServiceIdentityId",
                type: {
                    name: "Number",
                },
            }, keyVaultReferenceIdentity: {
                serializedName: "properties.keyVaultReferenceIdentity",
                xmlName: "properties.keyVaultReferenceIdentity",
                type: {
                    name: "String",
                },
            }, ipSecurityRestrictions: {
                serializedName: "properties.ipSecurityRestrictions",
                xmlName: "properties.ipSecurityRestrictions",
                xmlElementName: "IpSecurityRestriction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpSecurityRestriction",
                        },
                    },
                },
            }, ipSecurityRestrictionsDefaultAction: {
                serializedName: "properties.ipSecurityRestrictionsDefaultAction",
                xmlName: "properties.ipSecurityRestrictionsDefaultAction",
                type: {
                    name: "String",
                },
            }, scmIpSecurityRestrictions: {
                serializedName: "properties.scmIpSecurityRestrictions",
                xmlName: "properties.scmIpSecurityRestrictions",
                xmlElementName: "IpSecurityRestriction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpSecurityRestriction",
                        },
                    },
                },
            }, scmIpSecurityRestrictionsDefaultAction: {
                serializedName: "properties.scmIpSecurityRestrictionsDefaultAction",
                xmlName: "properties.scmIpSecurityRestrictionsDefaultAction",
                type: {
                    name: "String",
                },
            }, scmIpSecurityRestrictionsUseMain: {
                serializedName: "properties.scmIpSecurityRestrictionsUseMain",
                xmlName: "properties.scmIpSecurityRestrictionsUseMain",
                type: {
                    name: "Boolean",
                },
            }, http20Enabled: {
                defaultValue: true,
                serializedName: "properties.http20Enabled",
                xmlName: "properties.http20Enabled",
                type: {
                    name: "Boolean",
                },
            }, minTlsVersion: {
                serializedName: "properties.minTlsVersion",
                xmlName: "properties.minTlsVersion",
                type: {
                    name: "String",
                },
            }, minTlsCipherSuite: {
                serializedName: "properties.minTlsCipherSuite",
                xmlName: "properties.minTlsCipherSuite",
                type: {
                    name: "String",
                },
            }, scmMinTlsVersion: {
                serializedName: "properties.scmMinTlsVersion",
                xmlName: "properties.scmMinTlsVersion",
                type: {
                    name: "String",
                },
            }, ftpsState: {
                serializedName: "properties.ftpsState",
                xmlName: "properties.ftpsState",
                type: {
                    name: "String",
                },
            }, preWarmedInstanceCount: {
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 0,
                },
                serializedName: "properties.preWarmedInstanceCount",
                xmlName: "properties.preWarmedInstanceCount",
                type: {
                    name: "Number",
                },
            }, functionAppScaleLimit: {
                constraints: {
                    InclusiveMinimum: 0,
                },
                serializedName: "properties.functionAppScaleLimit",
                xmlName: "properties.functionAppScaleLimit",
                type: {
                    name: "Number",
                },
            }, elasticWebAppScaleLimit: {
                constraints: {
                    InclusiveMinimum: 0,
                },
                serializedName: "properties.elasticWebAppScaleLimit",
                xmlName: "properties.elasticWebAppScaleLimit",
                type: {
                    name: "Number",
                },
            }, healthCheckPath: {
                serializedName: "properties.healthCheckPath",
                xmlName: "properties.healthCheckPath",
                type: {
                    name: "String",
                },
            }, functionsRuntimeScaleMonitoringEnabled: {
                serializedName: "properties.functionsRuntimeScaleMonitoringEnabled",
                xmlName: "properties.functionsRuntimeScaleMonitoringEnabled",
                type: {
                    name: "Boolean",
                },
            }, websiteTimeZone: {
                serializedName: "properties.websiteTimeZone",
                xmlName: "properties.websiteTimeZone",
                type: {
                    name: "String",
                },
            }, minimumElasticInstanceCount: {
                constraints: {
                    InclusiveMaximum: 20,
                    InclusiveMinimum: 0,
                },
                serializedName: "properties.minimumElasticInstanceCount",
                xmlName: "properties.minimumElasticInstanceCount",
                type: {
                    name: "Number",
                },
            }, azureStorageAccounts: {
                serializedName: "properties.azureStorageAccounts",
                xmlName: "properties.azureStorageAccounts",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AzureStorageInfoValue" },
                    },
                },
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String",
                },
            } }),
    },
};
const SiteAuthSettings = {
    serializedName: "SiteAuthSettings",
    type: {
        name: "Composite",
        className: "SiteAuthSettings",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean",
                },
            }, runtimeVersion: {
                serializedName: "properties.runtimeVersion",
                xmlName: "properties.runtimeVersion",
                type: {
                    name: "String",
                },
            }, unauthenticatedClientAction: {
                serializedName: "properties.unauthenticatedClientAction",
                xmlName: "properties.unauthenticatedClientAction",
                type: {
                    name: "Enum",
                    allowedValues: ["RedirectToLoginPage", "AllowAnonymous"],
                },
            }, tokenStoreEnabled: {
                serializedName: "properties.tokenStoreEnabled",
                xmlName: "properties.tokenStoreEnabled",
                type: {
                    name: "Boolean",
                },
            }, allowedExternalRedirectUrls: {
                serializedName: "properties.allowedExternalRedirectUrls",
                xmlName: "properties.allowedExternalRedirectUrls",
                xmlElementName: "SiteAuthSettingsPropertiesAllowedExternalRedirectUrlsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, defaultProvider: {
                serializedName: "properties.defaultProvider",
                xmlName: "properties.defaultProvider",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "AzureActiveDirectory",
                        "Facebook",
                        "Google",
                        "MicrosoftAccount",
                        "Twitter",
                        "Github",
                    ],
                },
            }, tokenRefreshExtensionHours: {
                serializedName: "properties.tokenRefreshExtensionHours",
                xmlName: "properties.tokenRefreshExtensionHours",
                type: {
                    name: "Number",
                },
            }, clientId: {
                serializedName: "properties.clientId",
                xmlName: "properties.clientId",
                type: {
                    name: "String",
                },
            }, clientSecret: {
                serializedName: "properties.clientSecret",
                xmlName: "properties.clientSecret",
                type: {
                    name: "String",
                },
            }, clientSecretSettingName: {
                serializedName: "properties.clientSecretSettingName",
                xmlName: "properties.clientSecretSettingName",
                type: {
                    name: "String",
                },
            }, clientSecretCertificateThumbprint: {
                serializedName: "properties.clientSecretCertificateThumbprint",
                xmlName: "properties.clientSecretCertificateThumbprint",
                type: {
                    name: "String",
                },
            }, issuer: {
                serializedName: "properties.issuer",
                xmlName: "properties.issuer",
                type: {
                    name: "String",
                },
            }, validateIssuer: {
                serializedName: "properties.validateIssuer",
                xmlName: "properties.validateIssuer",
                type: {
                    name: "Boolean",
                },
            }, allowedAudiences: {
                serializedName: "properties.allowedAudiences",
                xmlName: "properties.allowedAudiences",
                xmlElementName: "SiteAuthSettingsPropertiesAllowedAudiencesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, additionalLoginParams: {
                serializedName: "properties.additionalLoginParams",
                xmlName: "properties.additionalLoginParams",
                xmlElementName: "SiteAuthSettingsPropertiesAdditionalLoginParamsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, aadClaimsAuthorization: {
                serializedName: "properties.aadClaimsAuthorization",
                xmlName: "properties.aadClaimsAuthorization",
                type: {
                    name: "String",
                },
            }, googleClientId: {
                serializedName: "properties.googleClientId",
                xmlName: "properties.googleClientId",
                type: {
                    name: "String",
                },
            }, googleClientSecret: {
                serializedName: "properties.googleClientSecret",
                xmlName: "properties.googleClientSecret",
                type: {
                    name: "String",
                },
            }, googleClientSecretSettingName: {
                serializedName: "properties.googleClientSecretSettingName",
                xmlName: "properties.googleClientSecretSettingName",
                type: {
                    name: "String",
                },
            }, googleOAuthScopes: {
                serializedName: "properties.googleOAuthScopes",
                xmlName: "properties.googleOAuthScopes",
                xmlElementName: "SiteAuthSettingsPropertiesGoogleOAuthScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, facebookAppId: {
                serializedName: "properties.facebookAppId",
                xmlName: "properties.facebookAppId",
                type: {
                    name: "String",
                },
            }, facebookAppSecret: {
                serializedName: "properties.facebookAppSecret",
                xmlName: "properties.facebookAppSecret",
                type: {
                    name: "String",
                },
            }, facebookAppSecretSettingName: {
                serializedName: "properties.facebookAppSecretSettingName",
                xmlName: "properties.facebookAppSecretSettingName",
                type: {
                    name: "String",
                },
            }, facebookOAuthScopes: {
                serializedName: "properties.facebookOAuthScopes",
                xmlName: "properties.facebookOAuthScopes",
                xmlElementName: "SiteAuthSettingsPropertiesFacebookOAuthScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, gitHubClientId: {
                serializedName: "properties.gitHubClientId",
                xmlName: "properties.gitHubClientId",
                type: {
                    name: "String",
                },
            }, gitHubClientSecret: {
                serializedName: "properties.gitHubClientSecret",
                xmlName: "properties.gitHubClientSecret",
                type: {
                    name: "String",
                },
            }, gitHubClientSecretSettingName: {
                serializedName: "properties.gitHubClientSecretSettingName",
                xmlName: "properties.gitHubClientSecretSettingName",
                type: {
                    name: "String",
                },
            }, gitHubOAuthScopes: {
                serializedName: "properties.gitHubOAuthScopes",
                xmlName: "properties.gitHubOAuthScopes",
                xmlElementName: "SiteAuthSettingsPropertiesGitHubOAuthScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, twitterConsumerKey: {
                serializedName: "properties.twitterConsumerKey",
                xmlName: "properties.twitterConsumerKey",
                type: {
                    name: "String",
                },
            }, twitterConsumerSecret: {
                serializedName: "properties.twitterConsumerSecret",
                xmlName: "properties.twitterConsumerSecret",
                type: {
                    name: "String",
                },
            }, twitterConsumerSecretSettingName: {
                serializedName: "properties.twitterConsumerSecretSettingName",
                xmlName: "properties.twitterConsumerSecretSettingName",
                type: {
                    name: "String",
                },
            }, microsoftAccountClientId: {
                serializedName: "properties.microsoftAccountClientId",
                xmlName: "properties.microsoftAccountClientId",
                type: {
                    name: "String",
                },
            }, microsoftAccountClientSecret: {
                serializedName: "properties.microsoftAccountClientSecret",
                xmlName: "properties.microsoftAccountClientSecret",
                type: {
                    name: "String",
                },
            }, microsoftAccountClientSecretSettingName: {
                serializedName: "properties.microsoftAccountClientSecretSettingName",
                xmlName: "properties.microsoftAccountClientSecretSettingName",
                type: {
                    name: "String",
                },
            }, microsoftAccountOAuthScopes: {
                serializedName: "properties.microsoftAccountOAuthScopes",
                xmlName: "properties.microsoftAccountOAuthScopes",
                xmlElementName: "SiteAuthSettingsPropertiesMicrosoftAccountOAuthScopesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, isAuthFromFile: {
                serializedName: "properties.isAuthFromFile",
                xmlName: "properties.isAuthFromFile",
                type: {
                    name: "String",
                },
            }, authFilePath: {
                serializedName: "properties.authFilePath",
                xmlName: "properties.authFilePath",
                type: {
                    name: "String",
                },
            }, configVersion: {
                serializedName: "properties.configVersion",
                xmlName: "properties.configVersion",
                type: {
                    name: "String",
                },
            } }),
    },
};
const SiteAuthSettingsV2 = {
    serializedName: "SiteAuthSettingsV2",
    type: {
        name: "Composite",
        className: "SiteAuthSettingsV2",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { platform: {
                serializedName: "properties.platform",
                xmlName: "properties.platform",
                type: {
                    name: "Composite",
                    className: "AuthPlatform",
                },
            }, globalValidation: {
                serializedName: "properties.globalValidation",
                xmlName: "properties.globalValidation",
                type: {
                    name: "Composite",
                    className: "GlobalValidation",
                },
            }, identityProviders: {
                serializedName: "properties.identityProviders",
                xmlName: "properties.identityProviders",
                type: {
                    name: "Composite",
                    className: "IdentityProviders",
                },
            }, login: {
                serializedName: "properties.login",
                xmlName: "properties.login",
                type: {
                    name: "Composite",
                    className: "Login",
                },
            }, httpSettings: {
                serializedName: "properties.httpSettings",
                xmlName: "properties.httpSettings",
                type: {
                    name: "Composite",
                    className: "HttpSettings",
                },
            } }),
    },
};
const AzureStoragePropertyDictionaryResource = {
    serializedName: "AzureStoragePropertyDictionaryResource",
    type: {
        name: "Composite",
        className: "AzureStoragePropertyDictionaryResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AzureStorageInfoValue" },
                    },
                },
            } }),
    },
};
const ApiKVReference = {
    serializedName: "ApiKVReference",
    type: {
        name: "Composite",
        className: "ApiKVReference",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { reference: {
                serializedName: "properties.reference",
                xmlName: "properties.reference",
                type: {
                    name: "String",
                },
            }, status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initialized",
                        "Resolved",
                        "InvalidSyntax",
                        "MSINotEnabled",
                        "VaultNotFound",
                        "SecretNotFound",
                        "SecretVersionNotFound",
                        "AccessToKeyVaultDenied",
                        "OtherReasons",
                        "FetchTimedOut",
                        "UnauthorizedClient",
                    ],
                },
            }, vaultName: {
                serializedName: "properties.vaultName",
                xmlName: "properties.vaultName",
                type: {
                    name: "String",
                },
            }, secretName: {
                serializedName: "properties.secretName",
                xmlName: "properties.secretName",
                type: {
                    name: "String",
                },
            }, secretVersion: {
                serializedName: "properties.secretVersion",
                xmlName: "properties.secretVersion",
                type: {
                    name: "String",
                },
            }, identityType: {
                serializedName: "properties.identityType",
                xmlName: "properties.identityType",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity",
                },
            }, details: {
                serializedName: "properties.details",
                xmlName: "properties.details",
                type: {
                    name: "String",
                },
            }, source: {
                defaultValue: "KeyVault",
                isConstant: true,
                serializedName: "properties.source",
                type: {
                    name: "String",
                },
            }, activeVersion: {
                serializedName: "properties.activeVersion",
                xmlName: "properties.activeVersion",
                type: {
                    name: "String",
                },
            } }),
    },
};
const ConnectionStringDictionary = {
    serializedName: "ConnectionStringDictionary",
    type: {
        name: "Composite",
        className: "ConnectionStringDictionary",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ConnStringValueTypePair" },
                    },
                },
            } }),
    },
};
const SiteLogsConfig = {
    serializedName: "SiteLogsConfig",
    type: {
        name: "Composite",
        className: "SiteLogsConfig",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { applicationLogs: {
                serializedName: "properties.applicationLogs",
                xmlName: "properties.applicationLogs",
                type: {
                    name: "Composite",
                    className: "ApplicationLogsConfig",
                },
            }, httpLogs: {
                serializedName: "properties.httpLogs",
                xmlName: "properties.httpLogs",
                type: {
                    name: "Composite",
                    className: "HttpLogsConfig",
                },
            }, failedRequestsTracing: {
                serializedName: "properties.failedRequestsTracing",
                xmlName: "properties.failedRequestsTracing",
                type: {
                    name: "Composite",
                    className: "EnabledConfig",
                },
            }, detailedErrorMessages: {
                serializedName: "properties.detailedErrorMessages",
                xmlName: "properties.detailedErrorMessages",
                type: {
                    name: "Composite",
                    className: "EnabledConfig",
                },
            } }),
    },
};
const SlotConfigNamesResource = {
    serializedName: "SlotConfigNamesResource",
    type: {
        name: "Composite",
        className: "SlotConfigNamesResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { connectionStringNames: {
                serializedName: "properties.connectionStringNames",
                xmlName: "properties.connectionStringNames",
                xmlElementName: "SlotConfigNamesConnectionStringNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, appSettingNames: {
                serializedName: "properties.appSettingNames",
                xmlName: "properties.appSettingNames",
                xmlElementName: "SlotConfigNamesAppSettingNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, azureStorageConfigNames: {
                serializedName: "properties.azureStorageConfigNames",
                xmlName: "properties.azureStorageConfigNames",
                xmlElementName: "SlotConfigNamesAzureStorageConfigNamesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            } }),
    },
};
const SiteConfigurationSnapshotInfo = {
    serializedName: "SiteConfigurationSnapshotInfo",
    type: {
        name: "Composite",
        className: "SiteConfigurationSnapshotInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { time: {
                serializedName: "properties.time",
                readOnly: true,
                xmlName: "properties.time",
                type: {
                    name: "DateTime",
                },
            }, snapshotId: {
                serializedName: "properties.snapshotId",
                readOnly: true,
                xmlName: "properties.snapshotId",
                type: {
                    name: "Number",
                },
            } }),
    },
};
const ContinuousWebJob = {
    serializedName: "ContinuousWebJob",
    type: {
        name: "Composite",
        className: "ContinuousWebJob",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Initializing",
                        "Starting",
                        "Running",
                        "PendingRestart",
                        "Stopped",
                    ],
                },
            }, detailedStatus: {
                serializedName: "properties.detailed_status",
                xmlName: "properties.detailed_status",
                type: {
                    name: "String",
                },
            }, logUrl: {
                serializedName: "properties.log_url",
                xmlName: "properties.log_url",
                type: {
                    name: "String",
                },
            }, runCommand: {
                serializedName: "properties.run_command",
                xmlName: "properties.run_command",
                type: {
                    name: "String",
                },
            }, url: {
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String",
                },
            }, extraInfoUrl: {
                serializedName: "properties.extra_info_url",
                xmlName: "properties.extra_info_url",
                type: {
                    name: "String",
                },
            }, webJobType: {
                serializedName: "properties.web_job_type",
                xmlName: "properties.web_job_type",
                type: {
                    name: "Enum",
                    allowedValues: ["Continuous", "Triggered"],
                },
            }, error: {
                serializedName: "properties.error",
                xmlName: "properties.error",
                type: {
                    name: "String",
                },
            }, usingSdk: {
                serializedName: "properties.using_sdk",
                xmlName: "properties.using_sdk",
                type: {
                    name: "Boolean",
                },
            }, settings: {
                serializedName: "properties.settings",
                xmlName: "properties.settings",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } },
                    },
                },
            } }),
    },
};
const CsmDeploymentStatus = {
    serializedName: "CsmDeploymentStatus",
    type: {
        name: "Composite",
        className: "CsmDeploymentStatus",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { deploymentId: {
                serializedName: "properties.deploymentId",
                xmlName: "properties.deploymentId",
                type: {
                    name: "String",
                },
            }, status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "String",
                },
            }, numberOfInstancesInProgress: {
                serializedName: "properties.numberOfInstancesInProgress",
                xmlName: "properties.numberOfInstancesInProgress",
                type: {
                    name: "Number",
                },
            }, numberOfInstancesSuccessful: {
                serializedName: "properties.numberOfInstancesSuccessful",
                xmlName: "properties.numberOfInstancesSuccessful",
                type: {
                    name: "Number",
                },
            }, numberOfInstancesFailed: {
                serializedName: "properties.numberOfInstancesFailed",
                xmlName: "properties.numberOfInstancesFailed",
                type: {
                    name: "Number",
                },
            }, failedInstancesLogs: {
                serializedName: "properties.failedInstancesLogs",
                xmlName: "properties.failedInstancesLogs",
                xmlElementName: "CsmDeploymentStatusPropertiesFailedInstancesLogsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, errors: {
                serializedName: "properties.errors",
                xmlName: "properties.errors",
                xmlElementName: "ErrorEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorEntity",
                        },
                    },
                },
            } }),
    },
};
const Deployment = {
    serializedName: "Deployment",
    type: {
        name: "Composite",
        className: "Deployment",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "Number",
                },
            }, message: {
                serializedName: "properties.message",
                xmlName: "properties.message",
                type: {
                    name: "String",
                },
            }, author: {
                serializedName: "properties.author",
                xmlName: "properties.author",
                type: {
                    name: "String",
                },
            }, deployer: {
                serializedName: "properties.deployer",
                xmlName: "properties.deployer",
                type: {
                    name: "String",
                },
            }, authorEmail: {
                serializedName: "properties.author_email",
                xmlName: "properties.author_email",
                type: {
                    name: "String",
                },
            }, startTime: {
                serializedName: "properties.start_time",
                xmlName: "properties.start_time",
                type: {
                    name: "DateTime",
                },
            }, endTime: {
                serializedName: "properties.end_time",
                xmlName: "properties.end_time",
                type: {
                    name: "DateTime",
                },
            }, active: {
                serializedName: "properties.active",
                xmlName: "properties.active",
                type: {
                    name: "Boolean",
                },
            }, details: {
                serializedName: "properties.details",
                xmlName: "properties.details",
                type: {
                    name: "String",
                },
            } }),
    },
};
const MSDeployStatus = {
    serializedName: "MSDeployStatus",
    type: {
        name: "Composite",
        className: "MSDeployStatus",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { deployer: {
                serializedName: "properties.deployer",
                readOnly: true,
                xmlName: "properties.deployer",
                type: {
                    name: "String",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "accepted",
                        "running",
                        "succeeded",
                        "failed",
                        "canceled",
                    ],
                },
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime",
                },
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime",
                },
            }, complete: {
                serializedName: "properties.complete",
                readOnly: true,
                xmlName: "properties.complete",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const MSDeploy = {
    serializedName: "MSDeploy",
    type: {
        name: "Composite",
        className: "MSDeploy",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { packageUri: {
                serializedName: "properties.packageUri",
                xmlName: "properties.packageUri",
                type: {
                    name: "String",
                },
            }, connectionString: {
                serializedName: "properties.connectionString",
                xmlName: "properties.connectionString",
                type: {
                    name: "String",
                },
            }, dbType: {
                serializedName: "properties.dbType",
                xmlName: "properties.dbType",
                type: {
                    name: "String",
                },
            }, setParametersXmlFileUri: {
                serializedName: "properties.setParametersXmlFileUri",
                xmlName: "properties.setParametersXmlFileUri",
                type: {
                    name: "String",
                },
            }, setParameters: {
                serializedName: "properties.setParameters",
                xmlName: "properties.setParameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            }, skipAppData: {
                serializedName: "properties.skipAppData",
                xmlName: "properties.skipAppData",
                type: {
                    name: "Boolean",
                },
            }, appOffline: {
                serializedName: "properties.appOffline",
                xmlName: "properties.appOffline",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const MSDeployLog = {
    serializedName: "MSDeployLog",
    type: {
        name: "Composite",
        className: "MSDeployLog",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { entries: {
                serializedName: "properties.entries",
                readOnly: true,
                xmlName: "properties.entries",
                xmlElementName: "MSDeployLogEntry",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MSDeployLogEntry",
                        },
                    },
                },
            } }),
    },
};
const FunctionEnvelope = {
    serializedName: "FunctionEnvelope",
    type: {
        name: "Composite",
        className: "FunctionEnvelope",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { functionAppId: {
                serializedName: "properties.function_app_id",
                xmlName: "properties.function_app_id",
                type: {
                    name: "String",
                },
            }, scriptRootPathHref: {
                serializedName: "properties.script_root_path_href",
                xmlName: "properties.script_root_path_href",
                type: {
                    name: "String",
                },
            }, scriptHref: {
                serializedName: "properties.script_href",
                xmlName: "properties.script_href",
                type: {
                    name: "String",
                },
            }, configHref: {
                serializedName: "properties.config_href",
                xmlName: "properties.config_href",
                type: {
                    name: "String",
                },
            }, testDataHref: {
                serializedName: "properties.test_data_href",
                xmlName: "properties.test_data_href",
                type: {
                    name: "String",
                },
            }, secretsFileHref: {
                serializedName: "properties.secrets_file_href",
                xmlName: "properties.secrets_file_href",
                type: {
                    name: "String",
                },
            }, href: {
                serializedName: "properties.href",
                xmlName: "properties.href",
                type: {
                    name: "String",
                },
            }, config: {
                serializedName: "properties.config",
                xmlName: "properties.config",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, files: {
                serializedName: "properties.files",
                xmlName: "properties.files",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            }, testData: {
                serializedName: "properties.test_data",
                xmlName: "properties.test_data",
                type: {
                    name: "String",
                },
            }, invokeUrlTemplate: {
                serializedName: "properties.invoke_url_template",
                xmlName: "properties.invoke_url_template",
                type: {
                    name: "String",
                },
            }, language: {
                serializedName: "properties.language",
                xmlName: "properties.language",
                type: {
                    name: "String",
                },
            }, isDisabled: {
                serializedName: "properties.isDisabled",
                xmlName: "properties.isDisabled",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const HostNameBinding = {
    serializedName: "HostNameBinding",
    type: {
        name: "Composite",
        className: "HostNameBinding",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { siteName: {
                serializedName: "properties.siteName",
                xmlName: "properties.siteName",
                type: {
                    name: "String",
                },
            }, domainId: {
                serializedName: "properties.domainId",
                xmlName: "properties.domainId",
                type: {
                    name: "String",
                },
            }, azureResourceName: {
                serializedName: "properties.azureResourceName",
                xmlName: "properties.azureResourceName",
                type: {
                    name: "String",
                },
            }, azureResourceType: {
                serializedName: "properties.azureResourceType",
                xmlName: "properties.azureResourceType",
                type: {
                    name: "Enum",
                    allowedValues: ["Website", "TrafficManager"],
                },
            }, customHostNameDnsRecordType: {
                serializedName: "properties.customHostNameDnsRecordType",
                xmlName: "properties.customHostNameDnsRecordType",
                type: {
                    name: "Enum",
                    allowedValues: ["CName", "A"],
                },
            }, hostNameType: {
                serializedName: "properties.hostNameType",
                xmlName: "properties.hostNameType",
                type: {
                    name: "Enum",
                    allowedValues: ["Verified", "Managed"],
                },
            }, sslState: {
                serializedName: "properties.sslState",
                xmlName: "properties.sslState",
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "SniEnabled", "IpBasedEnabled"],
                },
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                xmlName: "properties.thumbprint",
                type: {
                    name: "String",
                },
            }, virtualIP: {
                serializedName: "properties.virtualIP",
                readOnly: true,
                xmlName: "properties.virtualIP",
                type: {
                    name: "String",
                },
            } }),
    },
};
const RelayServiceConnectionEntity = {
    serializedName: "RelayServiceConnectionEntity",
    type: {
        name: "Composite",
        className: "RelayServiceConnectionEntity",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { entityName: {
                serializedName: "properties.entityName",
                xmlName: "properties.entityName",
                type: {
                    name: "String",
                },
            }, entityConnectionString: {
                serializedName: "properties.entityConnectionString",
                xmlName: "properties.entityConnectionString",
                type: {
                    name: "String",
                },
            }, resourceType: {
                serializedName: "properties.resourceType",
                xmlName: "properties.resourceType",
                type: {
                    name: "String",
                },
            }, resourceConnectionString: {
                serializedName: "properties.resourceConnectionString",
                xmlName: "properties.resourceConnectionString",
                type: {
                    name: "String",
                },
            }, hostname: {
                serializedName: "properties.hostname",
                xmlName: "properties.hostname",
                type: {
                    name: "String",
                },
            }, port: {
                serializedName: "properties.port",
                xmlName: "properties.port",
                type: {
                    name: "Number",
                },
            }, biztalkUri: {
                serializedName: "properties.biztalkUri",
                xmlName: "properties.biztalkUri",
                type: {
                    name: "String",
                },
            } }),
    },
};
const WebSiteInstanceStatus = {
    serializedName: "WebSiteInstanceStatus",
    type: {
        name: "Composite",
        className: "WebSiteInstanceStatus",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["READY", "STOPPED", "UNKNOWN"],
                },
            }, statusUrl: {
                serializedName: "properties.statusUrl",
                xmlName: "properties.statusUrl",
                type: {
                    name: "String",
                },
            }, detectorUrl: {
                serializedName: "properties.detectorUrl",
                xmlName: "properties.detectorUrl",
                type: {
                    name: "String",
                },
            }, consoleUrl: {
                serializedName: "properties.consoleUrl",
                xmlName: "properties.consoleUrl",
                type: {
                    name: "String",
                },
            }, healthCheckUrl: {
                serializedName: "properties.healthCheckUrl",
                xmlName: "properties.healthCheckUrl",
                type: {
                    name: "String",
                },
            }, containers: {
                serializedName: "properties.containers",
                xmlName: "properties.containers",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "ContainerInfo" } },
                },
            } }),
    },
};
const ProcessThreadInfo = {
    serializedName: "ProcessThreadInfo",
    type: {
        name: "Composite",
        className: "ProcessThreadInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { identifier: {
                serializedName: "properties.identifier",
                readOnly: true,
                xmlName: "properties.identifier",
                type: {
                    name: "Number",
                },
            }, href: {
                serializedName: "properties.href",
                xmlName: "properties.href",
                type: {
                    name: "String",
                },
            }, process: {
                serializedName: "properties.process",
                xmlName: "properties.process",
                type: {
                    name: "String",
                },
            }, startAddress: {
                serializedName: "properties.start_address",
                xmlName: "properties.start_address",
                type: {
                    name: "String",
                },
            }, currentPriority: {
                serializedName: "properties.current_priority",
                xmlName: "properties.current_priority",
                type: {
                    name: "Number",
                },
            }, priorityLevel: {
                serializedName: "properties.priority_level",
                xmlName: "properties.priority_level",
                type: {
                    name: "String",
                },
            }, basePriority: {
                serializedName: "properties.base_priority",
                xmlName: "properties.base_priority",
                type: {
                    name: "Number",
                },
            }, startTime: {
                serializedName: "properties.start_time",
                xmlName: "properties.start_time",
                type: {
                    name: "DateTime",
                },
            }, totalProcessorTime: {
                serializedName: "properties.total_processor_time",
                xmlName: "properties.total_processor_time",
                type: {
                    name: "String",
                },
            }, userProcessorTime: {
                serializedName: "properties.user_processor_time",
                xmlName: "properties.user_processor_time",
                type: {
                    name: "String",
                },
            }, state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String",
                },
            }, waitReason: {
                serializedName: "properties.wait_reason",
                xmlName: "properties.wait_reason",
                type: {
                    name: "String",
                },
            } }),
    },
};
const ProcessModuleInfo = {
    serializedName: "ProcessModuleInfo",
    type: {
        name: "Composite",
        className: "ProcessModuleInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { baseAddress: {
                serializedName: "properties.base_address",
                xmlName: "properties.base_address",
                type: {
                    name: "String",
                },
            }, fileName: {
                serializedName: "properties.file_name",
                xmlName: "properties.file_name",
                type: {
                    name: "String",
                },
            }, href: {
                serializedName: "properties.href",
                xmlName: "properties.href",
                type: {
                    name: "String",
                },
            }, filePath: {
                serializedName: "properties.file_path",
                xmlName: "properties.file_path",
                type: {
                    name: "String",
                },
            }, moduleMemorySize: {
                serializedName: "properties.module_memory_size",
                xmlName: "properties.module_memory_size",
                type: {
                    name: "Number",
                },
            }, fileVersion: {
                serializedName: "properties.file_version",
                xmlName: "properties.file_version",
                type: {
                    name: "String",
                },
            }, fileDescription: {
                serializedName: "properties.file_description",
                xmlName: "properties.file_description",
                type: {
                    name: "String",
                },
            }, product: {
                serializedName: "properties.product",
                xmlName: "properties.product",
                type: {
                    name: "String",
                },
            }, productVersion: {
                serializedName: "properties.product_version",
                xmlName: "properties.product_version",
                type: {
                    name: "String",
                },
            }, isDebug: {
                serializedName: "properties.is_debug",
                xmlName: "properties.is_debug",
                type: {
                    name: "Boolean",
                },
            }, language: {
                serializedName: "properties.language",
                xmlName: "properties.language",
                type: {
                    name: "String",
                },
            } }),
    },
};
const ProcessInfo = {
    serializedName: "ProcessInfo",
    type: {
        name: "Composite",
        className: "ProcessInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { identifier: {
                serializedName: "properties.identifier",
                readOnly: true,
                xmlName: "properties.identifier",
                type: {
                    name: "Number",
                },
            }, deploymentName: {
                serializedName: "properties.deployment_name",
                xmlName: "properties.deployment_name",
                type: {
                    name: "String",
                },
            }, href: {
                serializedName: "properties.href",
                xmlName: "properties.href",
                type: {
                    name: "String",
                },
            }, minidump: {
                serializedName: "properties.minidump",
                xmlName: "properties.minidump",
                type: {
                    name: "String",
                },
            }, isProfileRunning: {
                serializedName: "properties.is_profile_running",
                xmlName: "properties.is_profile_running",
                type: {
                    name: "Boolean",
                },
            }, isIisProfileRunning: {
                serializedName: "properties.is_iis_profile_running",
                xmlName: "properties.is_iis_profile_running",
                type: {
                    name: "Boolean",
                },
            }, iisProfileTimeoutInSeconds: {
                serializedName: "properties.iis_profile_timeout_in_seconds",
                xmlName: "properties.iis_profile_timeout_in_seconds",
                type: {
                    name: "Number",
                },
            }, parent: {
                serializedName: "properties.parent",
                xmlName: "properties.parent",
                type: {
                    name: "String",
                },
            }, children: {
                serializedName: "properties.children",
                xmlName: "properties.children",
                xmlElementName: "ProcessInfoPropertiesChildrenItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, threads: {
                serializedName: "properties.threads",
                xmlName: "properties.threads",
                xmlElementName: "ProcessThreadInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessThreadInfo",
                        },
                    },
                },
            }, openFileHandles: {
                serializedName: "properties.open_file_handles",
                xmlName: "properties.open_file_handles",
                xmlElementName: "ProcessInfoPropertiesOpenFileHandlesItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, modules: {
                serializedName: "properties.modules",
                xmlName: "properties.modules",
                xmlElementName: "ProcessModuleInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessModuleInfo",
                        },
                    },
                },
            }, fileName: {
                serializedName: "properties.file_name",
                xmlName: "properties.file_name",
                type: {
                    name: "String",
                },
            }, commandLine: {
                serializedName: "properties.command_line",
                xmlName: "properties.command_line",
                type: {
                    name: "String",
                },
            }, userName: {
                serializedName: "properties.user_name",
                xmlName: "properties.user_name",
                type: {
                    name: "String",
                },
            }, handleCount: {
                serializedName: "properties.handle_count",
                xmlName: "properties.handle_count",
                type: {
                    name: "Number",
                },
            }, moduleCount: {
                serializedName: "properties.module_count",
                xmlName: "properties.module_count",
                type: {
                    name: "Number",
                },
            }, threadCount: {
                serializedName: "properties.thread_count",
                xmlName: "properties.thread_count",
                type: {
                    name: "Number",
                },
            }, startTime: {
                serializedName: "properties.start_time",
                xmlName: "properties.start_time",
                type: {
                    name: "DateTime",
                },
            }, totalCpuTime: {
                serializedName: "properties.total_cpu_time",
                xmlName: "properties.total_cpu_time",
                type: {
                    name: "String",
                },
            }, userCpuTime: {
                serializedName: "properties.user_cpu_time",
                xmlName: "properties.user_cpu_time",
                type: {
                    name: "String",
                },
            }, privilegedCpuTime: {
                serializedName: "properties.privileged_cpu_time",
                xmlName: "properties.privileged_cpu_time",
                type: {
                    name: "String",
                },
            }, workingSet: {
                serializedName: "properties.working_set",
                xmlName: "properties.working_set",
                type: {
                    name: "Number",
                },
            }, peakWorkingSet: {
                serializedName: "properties.peak_working_set",
                xmlName: "properties.peak_working_set",
                type: {
                    name: "Number",
                },
            }, privateMemory: {
                serializedName: "properties.private_memory",
                xmlName: "properties.private_memory",
                type: {
                    name: "Number",
                },
            }, virtualMemory: {
                serializedName: "properties.virtual_memory",
                xmlName: "properties.virtual_memory",
                type: {
                    name: "Number",
                },
            }, peakVirtualMemory: {
                serializedName: "properties.peak_virtual_memory",
                xmlName: "properties.peak_virtual_memory",
                type: {
                    name: "Number",
                },
            }, pagedSystemMemory: {
                serializedName: "properties.paged_system_memory",
                xmlName: "properties.paged_system_memory",
                type: {
                    name: "Number",
                },
            }, nonPagedSystemMemory: {
                serializedName: "properties.non_paged_system_memory",
                xmlName: "properties.non_paged_system_memory",
                type: {
                    name: "Number",
                },
            }, pagedMemory: {
                serializedName: "properties.paged_memory",
                xmlName: "properties.paged_memory",
                type: {
                    name: "Number",
                },
            }, peakPagedMemory: {
                serializedName: "properties.peak_paged_memory",
                xmlName: "properties.peak_paged_memory",
                type: {
                    name: "Number",
                },
            }, timeStamp: {
                serializedName: "properties.time_stamp",
                xmlName: "properties.time_stamp",
                type: {
                    name: "DateTime",
                },
            }, environmentVariables: {
                serializedName: "properties.environment_variables",
                xmlName: "properties.environment_variables",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            }, isScmSite: {
                serializedName: "properties.is_scm_site",
                xmlName: "properties.is_scm_site",
                type: {
                    name: "Boolean",
                },
            }, isWebjob: {
                serializedName: "properties.is_webjob",
                xmlName: "properties.is_webjob",
                type: {
                    name: "Boolean",
                },
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String",
                },
            } }),
    },
};
const StorageMigrationOptions = {
    serializedName: "StorageMigrationOptions",
    type: {
        name: "Composite",
        className: "StorageMigrationOptions",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { azurefilesConnectionString: {
                serializedName: "properties.azurefilesConnectionString",
                xmlName: "properties.azurefilesConnectionString",
                type: {
                    name: "String",
                },
            }, azurefilesShare: {
                serializedName: "properties.azurefilesShare",
                xmlName: "properties.azurefilesShare",
                type: {
                    name: "String",
                },
            }, switchSiteAfterMigration: {
                defaultValue: false,
                serializedName: "properties.switchSiteAfterMigration",
                xmlName: "properties.switchSiteAfterMigration",
                type: {
                    name: "Boolean",
                },
            }, blockWriteAccessToSite: {
                defaultValue: false,
                serializedName: "properties.blockWriteAccessToSite",
                xmlName: "properties.blockWriteAccessToSite",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const StorageMigrationResponse = {
    serializedName: "StorageMigrationResponse",
    type: {
        name: "Composite",
        className: "StorageMigrationResponse",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { operationId: {
                serializedName: "properties.operationId",
                readOnly: true,
                xmlName: "properties.operationId",
                type: {
                    name: "String",
                },
            } }),
    },
};
const MigrateMySqlRequest = {
    serializedName: "MigrateMySqlRequest",
    type: {
        name: "Composite",
        className: "MigrateMySqlRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { connectionString: {
                serializedName: "properties.connectionString",
                xmlName: "properties.connectionString",
                type: {
                    name: "String",
                },
            }, migrationType: {
                serializedName: "properties.migrationType",
                xmlName: "properties.migrationType",
                type: {
                    name: "Enum",
                    allowedValues: ["LocalToRemote", "RemoteToLocal"],
                },
            } }),
    },
};
const MigrateMySqlStatus = {
    serializedName: "MigrateMySqlStatus",
    type: {
        name: "Composite",
        className: "MigrateMySqlStatus",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { migrationOperationStatus: {
                serializedName: "properties.migrationOperationStatus",
                readOnly: true,
                xmlName: "properties.migrationOperationStatus",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "InProgress",
                        "Failed",
                        "Succeeded",
                        "TimedOut",
                        "Created",
                    ],
                },
            }, operationId: {
                serializedName: "properties.operationId",
                readOnly: true,
                xmlName: "properties.operationId",
                type: {
                    name: "String",
                },
            }, localMySqlEnabled: {
                serializedName: "properties.localMySqlEnabled",
                readOnly: true,
                xmlName: "properties.localMySqlEnabled",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const SwiftVirtualNetwork = {
    serializedName: "SwiftVirtualNetwork",
    type: {
        name: "Composite",
        className: "SwiftVirtualNetwork",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { subnetResourceId: {
                serializedName: "properties.subnetResourceId",
                xmlName: "properties.subnetResourceId",
                type: {
                    name: "String",
                },
            }, swiftSupported: {
                serializedName: "properties.swiftSupported",
                xmlName: "properties.swiftSupported",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const NetworkFeatures = {
    serializedName: "NetworkFeatures",
    type: {
        name: "Composite",
        className: "NetworkFeatures",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { virtualNetworkName: {
                serializedName: "properties.virtualNetworkName",
                readOnly: true,
                xmlName: "properties.virtualNetworkName",
                type: {
                    name: "String",
                },
            }, virtualNetworkConnection: {
                serializedName: "properties.virtualNetworkConnection",
                xmlName: "properties.virtualNetworkConnection",
                type: {
                    name: "Composite",
                    className: "VnetInfo",
                },
            }, hybridConnections: {
                serializedName: "properties.hybridConnections",
                readOnly: true,
                xmlName: "properties.hybridConnections",
                xmlElementName: "RelayServiceConnectionEntity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RelayServiceConnectionEntity",
                        },
                    },
                },
            }, hybridConnectionsV2: {
                serializedName: "properties.hybridConnectionsV2",
                readOnly: true,
                xmlName: "properties.hybridConnectionsV2",
                xmlElementName: "HybridConnection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HybridConnection",
                        },
                    },
                },
            } }),
    },
};
const SitePhpErrorLogFlag = {
    serializedName: "SitePhpErrorLogFlag",
    type: {
        name: "Composite",
        className: "SitePhpErrorLogFlag",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { localLogErrors: {
                serializedName: "properties.localLogErrors",
                xmlName: "properties.localLogErrors",
                type: {
                    name: "String",
                },
            }, masterLogErrors: {
                serializedName: "properties.masterLogErrors",
                xmlName: "properties.masterLogErrors",
                type: {
                    name: "String",
                },
            }, localLogErrorsMaxLength: {
                serializedName: "properties.localLogErrorsMaxLength",
                xmlName: "properties.localLogErrorsMaxLength",
                type: {
                    name: "String",
                },
            }, masterLogErrorsMaxLength: {
                serializedName: "properties.masterLogErrorsMaxLength",
                xmlName: "properties.masterLogErrorsMaxLength",
                type: {
                    name: "String",
                },
            } }),
    },
};
const PremierAddOnPatchResource = {
    serializedName: "PremierAddOnPatchResource",
    type: {
        name: "Composite",
        className: "PremierAddOnPatchResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "String",
                },
            }, product: {
                serializedName: "properties.product",
                xmlName: "properties.product",
                type: {
                    name: "String",
                },
            }, vendor: {
                serializedName: "properties.vendor",
                xmlName: "properties.vendor",
                type: {
                    name: "String",
                },
            }, marketplacePublisher: {
                serializedName: "properties.marketplacePublisher",
                xmlName: "properties.marketplacePublisher",
                type: {
                    name: "String",
                },
            }, marketplaceOffer: {
                serializedName: "properties.marketplaceOffer",
                xmlName: "properties.marketplaceOffer",
                type: {
                    name: "String",
                },
            } }),
    },
};
const PrivateAccess = {
    serializedName: "PrivateAccess",
    type: {
        name: "Composite",
        className: "PrivateAccess",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { enabled: {
                serializedName: "properties.enabled",
                xmlName: "properties.enabled",
                type: {
                    name: "Boolean",
                },
            }, virtualNetworks: {
                serializedName: "properties.virtualNetworks",
                xmlName: "properties.virtualNetworks",
                xmlElementName: "PrivateAccessVirtualNetwork",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateAccessVirtualNetwork",
                        },
                    },
                },
            } }),
    },
};
const PublicCertificate = {
    serializedName: "PublicCertificate",
    type: {
        name: "Composite",
        className: "PublicCertificate",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { blob: {
                serializedName: "properties.blob",
                xmlName: "properties.blob",
                type: {
                    name: "ByteArray",
                },
            }, publicCertificateLocation: {
                serializedName: "properties.publicCertificateLocation",
                xmlName: "properties.publicCertificateLocation",
                type: {
                    name: "Enum",
                    allowedValues: ["CurrentUserMy", "LocalMachineMy", "Unknown"],
                },
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                xmlName: "properties.thumbprint",
                type: {
                    name: "String",
                },
            } }),
    },
};
const DeletedAppRestoreRequest = {
    serializedName: "DeletedAppRestoreRequest",
    type: {
        name: "Composite",
        className: "DeletedAppRestoreRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { deletedSiteId: {
                serializedName: "properties.deletedSiteId",
                xmlName: "properties.deletedSiteId",
                type: {
                    name: "String",
                },
            }, recoverConfiguration: {
                serializedName: "properties.recoverConfiguration",
                xmlName: "properties.recoverConfiguration",
                type: {
                    name: "Boolean",
                },
            }, snapshotTime: {
                serializedName: "properties.snapshotTime",
                xmlName: "properties.snapshotTime",
                type: {
                    name: "String",
                },
            }, useDRSecondary: {
                serializedName: "properties.useDRSecondary",
                xmlName: "properties.useDRSecondary",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const SnapshotRestoreRequest = {
    serializedName: "SnapshotRestoreRequest",
    type: {
        name: "Composite",
        className: "SnapshotRestoreRequest",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { snapshotTime: {
                serializedName: "properties.snapshotTime",
                xmlName: "properties.snapshotTime",
                type: {
                    name: "String",
                },
            }, recoverySource: {
                serializedName: "properties.recoverySource",
                xmlName: "properties.recoverySource",
                type: {
                    name: "Composite",
                    className: "SnapshotRecoverySource",
                },
            }, overwrite: {
                serializedName: "properties.overwrite",
                xmlName: "properties.overwrite",
                type: {
                    name: "Boolean",
                },
            }, recoverConfiguration: {
                serializedName: "properties.recoverConfiguration",
                xmlName: "properties.recoverConfiguration",
                type: {
                    name: "Boolean",
                },
            }, ignoreConflictingHostNames: {
                serializedName: "properties.ignoreConflictingHostNames",
                xmlName: "properties.ignoreConflictingHostNames",
                type: {
                    name: "Boolean",
                },
            }, useDRSecondary: {
                serializedName: "properties.useDRSecondary",
                xmlName: "properties.useDRSecondary",
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const SiteContainer = {
    serializedName: "SiteContainer",
    type: {
        name: "Composite",
        className: "SiteContainer",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { image: {
                serializedName: "properties.image",
                xmlName: "properties.image",
                type: {
                    name: "String",
                },
            }, targetPort: {
                serializedName: "properties.targetPort",
                xmlName: "properties.targetPort",
                type: {
                    name: "String",
                },
            }, isMain: {
                serializedName: "properties.isMain",
                xmlName: "properties.isMain",
                type: {
                    name: "Boolean",
                },
            }, startUpCommand: {
                serializedName: "properties.startUpCommand",
                xmlName: "properties.startUpCommand",
                type: {
                    name: "String",
                },
            }, authType: {
                serializedName: "properties.authType",
                xmlName: "properties.authType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Anonymous",
                        "UserCredentials",
                        "SystemIdentity",
                        "UserAssigned",
                    ],
                },
            }, userName: {
                serializedName: "properties.userName",
                xmlName: "properties.userName",
                type: {
                    name: "String",
                },
            }, passwordSecret: {
                serializedName: "properties.passwordSecret",
                xmlName: "properties.passwordSecret",
                type: {
                    name: "String",
                },
            }, userManagedIdentityClientId: {
                serializedName: "properties.userManagedIdentityClientId",
                xmlName: "properties.userManagedIdentityClientId",
                type: {
                    name: "String",
                },
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime",
                },
            }, lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                xmlName: "properties.lastModifiedTime",
                type: {
                    name: "DateTime",
                },
            }, volumeMounts: {
                serializedName: "properties.volumeMounts",
                xmlName: "properties.volumeMounts",
                xmlElementName: "VolumeMount",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VolumeMount",
                        },
                    },
                },
            }, environmentVariables: {
                serializedName: "properties.environmentVariables",
                xmlName: "properties.environmentVariables",
                xmlElementName: "EnvironmentVariable",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentVariable",
                        },
                    },
                },
            } }),
    },
};
const SiteExtensionInfo = {
    serializedName: "SiteExtensionInfo",
    type: {
        name: "Composite",
        className: "SiteExtensionInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { extensionId: {
                serializedName: "properties.extension_id",
                xmlName: "properties.extension_id",
                type: {
                    name: "String",
                },
            }, title: {
                serializedName: "properties.title",
                xmlName: "properties.title",
                type: {
                    name: "String",
                },
            }, extensionType: {
                serializedName: "properties.extension_type",
                xmlName: "properties.extension_type",
                type: {
                    name: "Enum",
                    allowedValues: ["Gallery", "WebRoot"],
                },
            }, summary: {
                serializedName: "properties.summary",
                xmlName: "properties.summary",
                type: {
                    name: "String",
                },
            }, description: {
                serializedName: "properties.description",
                xmlName: "properties.description",
                type: {
                    name: "String",
                },
            }, version: {
                serializedName: "properties.version",
                xmlName: "properties.version",
                type: {
                    name: "String",
                },
            }, extensionUrl: {
                serializedName: "properties.extension_url",
                xmlName: "properties.extension_url",
                type: {
                    name: "String",
                },
            }, projectUrl: {
                serializedName: "properties.project_url",
                xmlName: "properties.project_url",
                type: {
                    name: "String",
                },
            }, iconUrl: {
                serializedName: "properties.icon_url",
                xmlName: "properties.icon_url",
                type: {
                    name: "String",
                },
            }, licenseUrl: {
                serializedName: "properties.license_url",
                xmlName: "properties.license_url",
                type: {
                    name: "String",
                },
            }, feedUrl: {
                serializedName: "properties.feed_url",
                xmlName: "properties.feed_url",
                type: {
                    name: "String",
                },
            }, authors: {
                serializedName: "properties.authors",
                xmlName: "properties.authors",
                xmlElementName: "SiteExtensionInfoPropertiesAuthorsItem",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, installerCommandLineParams: {
                serializedName: "properties.installer_command_line_params",
                xmlName: "properties.installer_command_line_params",
                type: {
                    name: "String",
                },
            }, publishedDateTime: {
                serializedName: "properties.published_date_time",
                xmlName: "properties.published_date_time",
                type: {
                    name: "DateTime",
                },
            }, downloadCount: {
                serializedName: "properties.download_count",
                xmlName: "properties.download_count",
                type: {
                    name: "Number",
                },
            }, localIsLatestVersion: {
                serializedName: "properties.local_is_latest_version",
                xmlName: "properties.local_is_latest_version",
                type: {
                    name: "Boolean",
                },
            }, localPath: {
                serializedName: "properties.local_path",
                xmlName: "properties.local_path",
                type: {
                    name: "String",
                },
            }, installedDateTime: {
                serializedName: "properties.installed_date_time",
                xmlName: "properties.installed_date_time",
                type: {
                    name: "DateTime",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                xmlName: "properties.provisioningState",
                type: {
                    name: "String",
                },
            }, comment: {
                serializedName: "properties.comment",
                xmlName: "properties.comment",
                type: {
                    name: "String",
                },
            } }),
    },
};
const SlotDifference = {
    serializedName: "SlotDifference",
    type: {
        name: "Composite",
        className: "SlotDifference",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { level: {
                serializedName: "properties.level",
                readOnly: true,
                xmlName: "properties.level",
                type: {
                    name: "String",
                },
            }, settingType: {
                serializedName: "properties.settingType",
                readOnly: true,
                xmlName: "properties.settingType",
                type: {
                    name: "String",
                },
            }, diffRule: {
                serializedName: "properties.diffRule",
                readOnly: true,
                xmlName: "properties.diffRule",
                type: {
                    name: "String",
                },
            }, settingName: {
                serializedName: "properties.settingName",
                readOnly: true,
                xmlName: "properties.settingName",
                type: {
                    name: "String",
                },
            }, valueInCurrentSlot: {
                serializedName: "properties.valueInCurrentSlot",
                readOnly: true,
                xmlName: "properties.valueInCurrentSlot",
                type: {
                    name: "String",
                },
            }, valueInTargetSlot: {
                serializedName: "properties.valueInTargetSlot",
                readOnly: true,
                xmlName: "properties.valueInTargetSlot",
                type: {
                    name: "String",
                },
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                xmlName: "properties.description",
                type: {
                    name: "String",
                },
            } }),
    },
};
const SiteSourceControl = {
    serializedName: "SiteSourceControl",
    type: {
        name: "Composite",
        className: "SiteSourceControl",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { repoUrl: {
                serializedName: "properties.repoUrl",
                xmlName: "properties.repoUrl",
                type: {
                    name: "String",
                },
            }, branch: {
                serializedName: "properties.branch",
                xmlName: "properties.branch",
                type: {
                    name: "String",
                },
            }, isManualIntegration: {
                serializedName: "properties.isManualIntegration",
                xmlName: "properties.isManualIntegration",
                type: {
                    name: "Boolean",
                },
            }, isGitHubAction: {
                serializedName: "properties.isGitHubAction",
                xmlName: "properties.isGitHubAction",
                type: {
                    name: "Boolean",
                },
            }, deploymentRollbackEnabled: {
                serializedName: "properties.deploymentRollbackEnabled",
                xmlName: "properties.deploymentRollbackEnabled",
                type: {
                    name: "Boolean",
                },
            }, isMercurial: {
                serializedName: "properties.isMercurial",
                xmlName: "properties.isMercurial",
                type: {
                    name: "Boolean",
                },
            }, gitHubActionConfiguration: {
                serializedName: "properties.gitHubActionConfiguration",
                xmlName: "properties.gitHubActionConfiguration",
                type: {
                    name: "Composite",
                    className: "GitHubActionConfiguration",
                },
            } }),
    },
};
const TriggeredWebJob = {
    serializedName: "TriggeredWebJob",
    type: {
        name: "Composite",
        className: "TriggeredWebJob",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { latestRun: {
                serializedName: "properties.latest_run",
                xmlName: "properties.latest_run",
                type: {
                    name: "Composite",
                    className: "TriggeredJobRun",
                },
            }, historyUrl: {
                serializedName: "properties.history_url",
                xmlName: "properties.history_url",
                type: {
                    name: "String",
                },
            }, schedulerLogsUrl: {
                serializedName: "properties.scheduler_logs_url",
                xmlName: "properties.scheduler_logs_url",
                type: {
                    name: "String",
                },
            }, runCommand: {
                serializedName: "properties.run_command",
                xmlName: "properties.run_command",
                type: {
                    name: "String",
                },
            }, url: {
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String",
                },
            }, extraInfoUrl: {
                serializedName: "properties.extra_info_url",
                xmlName: "properties.extra_info_url",
                type: {
                    name: "String",
                },
            }, webJobType: {
                serializedName: "properties.web_job_type",
                xmlName: "properties.web_job_type",
                type: {
                    name: "Enum",
                    allowedValues: ["Continuous", "Triggered"],
                },
            }, error: {
                serializedName: "properties.error",
                xmlName: "properties.error",
                type: {
                    name: "String",
                },
            }, usingSdk: {
                serializedName: "properties.using_sdk",
                xmlName: "properties.using_sdk",
                type: {
                    name: "Boolean",
                },
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                xmlName: "properties.publicNetworkAccess",
                type: {
                    name: "String",
                },
            }, storageAccountRequired: {
                serializedName: "properties.storageAccountRequired",
                xmlName: "properties.storageAccountRequired",
                type: {
                    name: "Boolean",
                },
            }, settings: {
                serializedName: "properties.settings",
                xmlName: "properties.settings",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } },
                    },
                },
            } }),
    },
};
const TriggeredJobHistory = {
    serializedName: "TriggeredJobHistory",
    type: {
        name: "Composite",
        className: "TriggeredJobHistory",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { runs: {
                serializedName: "properties.runs",
                xmlName: "properties.runs",
                xmlElementName: "TriggeredJobRun",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TriggeredJobRun",
                        },
                    },
                },
            } }),
    },
};
const WebJob = {
    serializedName: "WebJob",
    type: {
        name: "Composite",
        className: "WebJob",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { runCommand: {
                serializedName: "properties.run_command",
                xmlName: "properties.run_command",
                type: {
                    name: "String",
                },
            }, url: {
                serializedName: "properties.url",
                xmlName: "properties.url",
                type: {
                    name: "String",
                },
            }, extraInfoUrl: {
                serializedName: "properties.extra_info_url",
                xmlName: "properties.extra_info_url",
                type: {
                    name: "String",
                },
            }, webJobType: {
                serializedName: "properties.web_job_type",
                xmlName: "properties.web_job_type",
                type: {
                    name: "Enum",
                    allowedValues: ["Continuous", "Triggered"],
                },
            }, error: {
                serializedName: "properties.error",
                xmlName: "properties.error",
                type: {
                    name: "String",
                },
            }, usingSdk: {
                serializedName: "properties.using_sdk",
                xmlName: "properties.using_sdk",
                type: {
                    name: "Boolean",
                },
            }, settings: {
                serializedName: "properties.settings",
                xmlName: "properties.settings",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } },
                    },
                },
            } }),
    },
};
const PrivateLinkConnectionApprovalRequestResource = {
    serializedName: "PrivateLinkConnectionApprovalRequestResource",
    type: {
        name: "Composite",
        className: "PrivateLinkConnectionApprovalRequestResource",
        modelProperties: Object.assign(Object.assign({}, ProxyOnlyResource.type.modelProperties), { privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                xmlName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkConnectionState",
                },
            } }),
    },
};
const WorkflowOutputParameter = {
    serializedName: "WorkflowOutputParameter",
    type: {
        name: "Composite",
        className: "WorkflowOutputParameter",
        modelProperties: Object.assign(Object.assign({}, WorkflowParameter.type.modelProperties), { error: {
                serializedName: "error",
                readOnly: true,
                xmlName: "error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            } }),
    },
};
const WorkflowRun = {
    serializedName: "WorkflowRun",
    type: {
        name: "Composite",
        className: "WorkflowRun",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            }, type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            }, waitEndTime: {
                serializedName: "properties.waitEndTime",
                readOnly: true,
                xmlName: "properties.waitEndTime",
                type: {
                    name: "DateTime",
                },
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime",
                },
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String",
                },
            }, code: {
                serializedName: "properties.code",
                readOnly: true,
                xmlName: "properties.code",
                type: {
                    name: "String",
                },
            }, error: {
                serializedName: "properties.error",
                readOnly: true,
                xmlName: "properties.error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, correlationId: {
                serializedName: "properties.correlationId",
                readOnly: true,
                xmlName: "properties.correlationId",
                type: {
                    name: "String",
                },
            }, correlation: {
                serializedName: "properties.correlation",
                xmlName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "Correlation",
                },
            }, workflow: {
                serializedName: "properties.workflow",
                xmlName: "properties.workflow",
                type: {
                    name: "Composite",
                    className: "ResourceReference",
                },
            }, trigger: {
                serializedName: "properties.trigger",
                xmlName: "properties.trigger",
                type: {
                    name: "Composite",
                    className: "WorkflowRunTrigger",
                },
            }, outputs: {
                serializedName: "properties.outputs",
                readOnly: true,
                xmlName: "properties.outputs",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "WorkflowOutputParameter" },
                    },
                },
            }, response: {
                serializedName: "properties.response",
                xmlName: "properties.response",
                type: {
                    name: "Composite",
                    className: "WorkflowRunTrigger",
                },
            } }),
    },
};
const WorkflowRunAction = {
    serializedName: "WorkflowRunAction",
    type: {
        name: "Composite",
        className: "WorkflowRunAction",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            }, type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime",
                },
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String",
                },
            }, code: {
                serializedName: "properties.code",
                readOnly: true,
                xmlName: "properties.code",
                type: {
                    name: "String",
                },
            }, error: {
                serializedName: "properties.error",
                readOnly: true,
                xmlName: "properties.error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, trackingId: {
                serializedName: "properties.trackingId",
                readOnly: true,
                xmlName: "properties.trackingId",
                type: {
                    name: "String",
                },
            }, correlation: {
                serializedName: "properties.correlation",
                xmlName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "RunActionCorrelation",
                },
            }, inputsLink: {
                serializedName: "properties.inputsLink",
                xmlName: "properties.inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            }, outputsLink: {
                serializedName: "properties.outputsLink",
                xmlName: "properties.outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            }, trackedProperties: {
                serializedName: "properties.trackedProperties",
                readOnly: true,
                xmlName: "properties.trackedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, retryHistory: {
                serializedName: "properties.retryHistory",
                xmlName: "properties.retryHistory",
                xmlElementName: "RetryHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RetryHistory",
                        },
                    },
                },
            } }),
    },
};
const WorkflowTrigger = {
    serializedName: "WorkflowTrigger",
    type: {
        name: "Composite",
        className: "WorkflowTrigger",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            }, type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String",
                },
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime",
                },
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                xmlName: "properties.changedTime",
                type: {
                    name: "DateTime",
                },
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                xmlName: "properties.state",
                type: {
                    name: "String",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String",
                },
            }, lastExecutionTime: {
                serializedName: "properties.lastExecutionTime",
                readOnly: true,
                xmlName: "properties.lastExecutionTime",
                type: {
                    name: "DateTime",
                },
            }, nextExecutionTime: {
                serializedName: "properties.nextExecutionTime",
                readOnly: true,
                xmlName: "properties.nextExecutionTime",
                type: {
                    name: "DateTime",
                },
            }, recurrence: {
                serializedName: "properties.recurrence",
                xmlName: "properties.recurrence",
                type: {
                    name: "Composite",
                    className: "WorkflowTriggerRecurrence",
                },
            }, workflow: {
                serializedName: "properties.workflow",
                xmlName: "properties.workflow",
                type: {
                    name: "Composite",
                    className: "ResourceReference",
                },
            } }),
    },
};
const WorkflowTriggerHistory = {
    serializedName: "WorkflowTriggerHistory",
    type: {
        name: "Composite",
        className: "WorkflowTriggerHistory",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                xmlName: "name",
                type: {
                    name: "String",
                },
            }, type: {
                serializedName: "type",
                readOnly: true,
                xmlName: "type",
                type: {
                    name: "String",
                },
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime",
                },
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime",
                },
            }, scheduledTime: {
                serializedName: "properties.scheduledTime",
                readOnly: true,
                xmlName: "properties.scheduledTime",
                type: {
                    name: "DateTime",
                },
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                xmlName: "properties.status",
                type: {
                    name: "String",
                },
            }, code: {
                serializedName: "properties.code",
                readOnly: true,
                xmlName: "properties.code",
                type: {
                    name: "String",
                },
            }, error: {
                serializedName: "properties.error",
                readOnly: true,
                xmlName: "properties.error",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, trackingId: {
                serializedName: "properties.trackingId",
                readOnly: true,
                xmlName: "properties.trackingId",
                type: {
                    name: "String",
                },
            }, correlation: {
                serializedName: "properties.correlation",
                xmlName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "Correlation",
                },
            }, inputsLink: {
                serializedName: "properties.inputsLink",
                xmlName: "properties.inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            }, outputsLink: {
                serializedName: "properties.outputsLink",
                xmlName: "properties.outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            }, fired: {
                serializedName: "properties.fired",
                readOnly: true,
                xmlName: "properties.fired",
                type: {
                    name: "Boolean",
                },
            }, run: {
                serializedName: "properties.run",
                xmlName: "properties.run",
                type: {
                    name: "Composite",
                    className: "ResourceReference",
                },
            } }),
    },
};
const RunActionCorrelation = {
    serializedName: "RunActionCorrelation",
    type: {
        name: "Composite",
        className: "RunActionCorrelation",
        modelProperties: Object.assign(Object.assign({}, RunCorrelation.type.modelProperties), { actionTrackingId: {
                serializedName: "actionTrackingId",
                xmlName: "actionTrackingId",
                type: {
                    name: "String",
                },
            } }),
    },
};
const ExpressionRoot = {
    serializedName: "ExpressionRoot",
    type: {
        name: "Composite",
        className: "ExpressionRoot",
        modelProperties: Object.assign(Object.assign({}, Expression.type.modelProperties), { path: {
                serializedName: "path",
                xmlName: "path",
                type: {
                    name: "String",
                },
            } }),
    },
};
const AzureResourceErrorInfo = {
    serializedName: "AzureResourceErrorInfo",
    type: {
        name: "Composite",
        className: "AzureResourceErrorInfo",
        modelProperties: Object.assign(Object.assign({}, ErrorInfo.type.modelProperties), { message: {
                serializedName: "message",
                required: true,
                xmlName: "message",
                type: {
                    name: "String",
                },
            }, details: {
                serializedName: "details",
                xmlName: "details",
                xmlElementName: "AzureResourceErrorInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureResourceErrorInfo",
                        },
                    },
                },
            } }),
    },
};
const OperationResult = {
    serializedName: "OperationResult",
    type: {
        name: "Composite",
        className: "OperationResult",
        modelProperties: Object.assign(Object.assign({}, OperationResultProperties.type.modelProperties), { trackingId: {
                serializedName: "trackingId",
                readOnly: true,
                xmlName: "trackingId",
                type: {
                    name: "String",
                },
            }, inputs: {
                serializedName: "inputs",
                readOnly: true,
                xmlName: "inputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, inputsLink: {
                serializedName: "inputsLink",
                xmlName: "inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            }, outputs: {
                serializedName: "outputs",
                readOnly: true,
                xmlName: "outputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, outputsLink: {
                serializedName: "outputsLink",
                xmlName: "outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            }, trackedProperties: {
                serializedName: "trackedProperties",
                readOnly: true,
                xmlName: "trackedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, retryHistory: {
                serializedName: "retryHistory",
                xmlName: "retryHistory",
                xmlElementName: "RetryHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RetryHistory",
                        },
                    },
                },
            }, iterationCount: {
                serializedName: "iterationCount",
                xmlName: "iterationCount",
                type: {
                    name: "Number",
                },
            } }),
    },
};
const WorkflowRunActionRepetitionDefinition = {
    serializedName: "WorkflowRunActionRepetitionDefinition",
    type: {
        name: "Composite",
        className: "WorkflowRunActionRepetitionDefinition",
        modelProperties: Object.assign(Object.assign({}, WorkflowResource.type.modelProperties), { startTime: {
                serializedName: "properties.startTime",
                xmlName: "properties.startTime",
                type: {
                    name: "DateTime",
                },
            }, endTime: {
                serializedName: "properties.endTime",
                xmlName: "properties.endTime",
                type: {
                    name: "DateTime",
                },
            }, correlation: {
                serializedName: "properties.correlation",
                xmlName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "RunActionCorrelation",
                },
            }, status: {
                serializedName: "properties.status",
                xmlName: "properties.status",
                type: {
                    name: "String",
                },
            }, code: {
                serializedName: "properties.code",
                xmlName: "properties.code",
                type: {
                    name: "String",
                },
            }, error: {
                serializedName: "properties.error",
                xmlName: "properties.error",
                type: {
                    name: "any",
                },
            }, trackingId: {
                serializedName: "properties.trackingId",
                readOnly: true,
                xmlName: "properties.trackingId",
                type: {
                    name: "String",
                },
            }, inputs: {
                serializedName: "properties.inputs",
                readOnly: true,
                xmlName: "properties.inputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, inputsLink: {
                serializedName: "properties.inputsLink",
                xmlName: "properties.inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            }, outputs: {
                serializedName: "properties.outputs",
                readOnly: true,
                xmlName: "properties.outputs",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, outputsLink: {
                serializedName: "properties.outputsLink",
                xmlName: "properties.outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink",
                },
            }, trackedProperties: {
                serializedName: "properties.trackedProperties",
                readOnly: true,
                xmlName: "properties.trackedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, retryHistory: {
                serializedName: "properties.retryHistory",
                xmlName: "properties.retryHistory",
                xmlElementName: "RetryHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RetryHistory",
                        },
                    },
                },
            }, iterationCount: {
                serializedName: "properties.iterationCount",
                xmlName: "properties.iterationCount",
                type: {
                    name: "Number",
                },
            }, repetitionIndexes: {
                serializedName: "properties.repetitionIndexes",
                xmlName: "properties.repetitionIndexes",
                xmlElementName: "RepetitionIndex",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RepetitionIndex",
                        },
                    },
                },
            } }),
    },
};
const RequestHistory = {
    serializedName: "RequestHistory",
    type: {
        name: "Composite",
        className: "RequestHistory",
        modelProperties: Object.assign(Object.assign({}, WorkflowResource.type.modelProperties), { properties: {
                serializedName: "properties",
                xmlName: "properties",
                type: {
                    name: "Composite",
                    className: "RequestHistoryProperties",
                },
            } }),
    },
};
const Workflow = {
    serializedName: "Workflow",
    type: {
        name: "Composite",
        className: "Workflow",
        modelProperties: Object.assign(Object.assign({}, WorkflowResource.type.modelProperties), { identity: {
                serializedName: "identity",
                xmlName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String",
                },
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime",
                },
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                xmlName: "properties.changedTime",
                type: {
                    name: "DateTime",
                },
            }, state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String",
                },
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                xmlName: "properties.version",
                type: {
                    name: "String",
                },
            }, accessEndpoint: {
                serializedName: "properties.accessEndpoint",
                readOnly: true,
                xmlName: "properties.accessEndpoint",
                type: {
                    name: "String",
                },
            }, endpointsConfiguration: {
                serializedName: "properties.endpointsConfiguration",
                xmlName: "properties.endpointsConfiguration",
                type: {
                    name: "Composite",
                    className: "FlowEndpointsConfiguration",
                },
            }, accessControl: {
                serializedName: "properties.accessControl",
                xmlName: "properties.accessControl",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfiguration",
                },
            }, sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "WorkflowSku",
                },
            }, integrationAccount: {
                serializedName: "properties.integrationAccount",
                xmlName: "properties.integrationAccount",
                type: {
                    name: "Composite",
                    className: "ResourceReference",
                },
            }, integrationServiceEnvironment: {
                serializedName: "properties.integrationServiceEnvironment",
                xmlName: "properties.integrationServiceEnvironment",
                type: {
                    name: "Composite",
                    className: "ResourceReference",
                },
            }, definition: {
                serializedName: "properties.definition",
                xmlName: "properties.definition",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, parameters: {
                serializedName: "properties.parameters",
                xmlName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "WorkflowParameter" },
                    },
                },
            }, kind: {
                serializedName: "properties.kind",
                xmlName: "properties.kind",
                type: {
                    name: "String",
                },
            } }),
    },
};
const WorkflowVersion = {
    serializedName: "WorkflowVersion",
    type: {
        name: "Composite",
        className: "WorkflowVersion",
        modelProperties: Object.assign(Object.assign({}, WorkflowResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                xmlName: "properties.provisioningState",
                type: {
                    name: "String",
                },
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                xmlName: "properties.createdTime",
                type: {
                    name: "DateTime",
                },
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                xmlName: "properties.changedTime",
                type: {
                    name: "DateTime",
                },
            }, state: {
                serializedName: "properties.state",
                xmlName: "properties.state",
                type: {
                    name: "String",
                },
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                xmlName: "properties.version",
                type: {
                    name: "String",
                },
            }, accessEndpoint: {
                serializedName: "properties.accessEndpoint",
                readOnly: true,
                xmlName: "properties.accessEndpoint",
                type: {
                    name: "String",
                },
            }, endpointsConfiguration: {
                serializedName: "properties.endpointsConfiguration",
                xmlName: "properties.endpointsConfiguration",
                type: {
                    name: "Composite",
                    className: "FlowEndpointsConfiguration",
                },
            }, accessControl: {
                serializedName: "properties.accessControl",
                xmlName: "properties.accessControl",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfiguration",
                },
            }, sku: {
                serializedName: "properties.sku",
                xmlName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "WorkflowSku",
                },
            }, integrationAccount: {
                serializedName: "properties.integrationAccount",
                xmlName: "properties.integrationAccount",
                type: {
                    name: "Composite",
                    className: "ResourceReference",
                },
            }, definition: {
                serializedName: "properties.definition",
                xmlName: "properties.definition",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            }, parameters: {
                serializedName: "properties.parameters",
                xmlName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "WorkflowParameter" },
                    },
                },
            } }),
    },
};
const WorkflowRunActionRepetitionProperties = {
    serializedName: "WorkflowRunActionRepetitionProperties",
    type: {
        name: "Composite",
        className: "WorkflowRunActionRepetitionProperties",
        modelProperties: Object.assign(Object.assign({}, OperationResult.type.modelProperties), { repetitionIndexes: {
                serializedName: "repetitionIndexes",
                xmlName: "repetitionIndexes",
                xmlElementName: "RepetitionIndex",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RepetitionIndex",
                        },
                    },
                },
            } }),
    },
};
const AppServiceEnvironmentsCreateOrUpdateHeaders = {
    serializedName: "AppServiceEnvironments_createOrUpdateHeaders",
    type: {
        name: "Composite",
        className: "AppServiceEnvironmentsCreateOrUpdateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                xmlName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AbnormalTimePeriod: AbnormalTimePeriod,
    Address: Address,
    AddressResponse: AddressResponse,
    AllowedAudiencesValidation: AllowedAudiencesValidation,
    AllowedPrincipals: AllowedPrincipals,
    AnalysisData: AnalysisData,
    AnalysisDefinition: AnalysisDefinition,
    ApiDefinitionInfo: ApiDefinitionInfo,
    ApiKVReference: ApiKVReference,
    ApiKVReferenceCollection: ApiKVReferenceCollection,
    ApiManagementConfig: ApiManagementConfig,
    AppInsightsWebAppStackSettings: AppInsightsWebAppStackSettings,
    AppLogsConfiguration: AppLogsConfiguration,
    AppRegistration: AppRegistration,
    AppServiceCertificate: AppServiceCertificate,
    AppServiceCertificateCollection: AppServiceCertificateCollection,
    AppServiceCertificateOrder: AppServiceCertificateOrder,
    AppServiceCertificateOrderCollection: AppServiceCertificateOrderCollection,
    AppServiceCertificateOrderPatchResource: AppServiceCertificateOrderPatchResource,
    AppServiceCertificatePatchResource: AppServiceCertificatePatchResource,
    AppServiceCertificateResource: AppServiceCertificateResource,
    AppServiceEnvironment: AppServiceEnvironment,
    AppServiceEnvironmentCollection: AppServiceEnvironmentCollection,
    AppServiceEnvironmentPatchResource: AppServiceEnvironmentPatchResource,
    AppServiceEnvironmentResource: AppServiceEnvironmentResource,
    AppServiceEnvironmentsCreateOrUpdateHeaders: AppServiceEnvironmentsCreateOrUpdateHeaders,
    AppServicePlan: AppServicePlan,
    AppServicePlanCollection: AppServicePlanCollection,
    AppServicePlanPatchResource: AppServicePlanPatchResource,
    Apple: Apple,
    AppleRegistration: AppleRegistration,
    ApplicationLogsConfig: ApplicationLogsConfig,
    ApplicationStack: ApplicationStack,
    ApplicationStackCollection: ApplicationStackCollection,
    ApplicationStackResource: ApplicationStackResource,
    AppserviceGithubToken: AppserviceGithubToken,
    AppserviceGithubTokenRequest: AppserviceGithubTokenRequest,
    ArcConfiguration: ArcConfiguration,
    ArmIdWrapper: ArmIdWrapper,
    ArmPlan: ArmPlan,
    AseRegion: AseRegion,
    AseRegionCollection: AseRegionCollection,
    AseV3NetworkingConfiguration: AseV3NetworkingConfiguration,
    AuthPlatform: AuthPlatform,
    AutoHealActions: AutoHealActions,
    AutoHealCustomAction: AutoHealCustomAction,
    AutoHealRules: AutoHealRules,
    AutoHealTriggers: AutoHealTriggers,
    AzureActiveDirectory: AzureActiveDirectory,
    AzureActiveDirectoryLogin: AzureActiveDirectoryLogin,
    AzureActiveDirectoryRegistration: AzureActiveDirectoryRegistration,
    AzureActiveDirectoryValidation: AzureActiveDirectoryValidation,
    AzureBlobStorageApplicationLogsConfig: AzureBlobStorageApplicationLogsConfig,
    AzureBlobStorageHttpLogsConfig: AzureBlobStorageHttpLogsConfig,
    AzureResourceErrorInfo: AzureResourceErrorInfo,
    AzureStaticWebApps: AzureStaticWebApps,
    AzureStaticWebAppsRegistration: AzureStaticWebAppsRegistration,
    AzureStorageInfoValue: AzureStorageInfoValue,
    AzureStoragePropertyDictionaryResource: AzureStoragePropertyDictionaryResource,
    AzureTableStorageApplicationLogsConfig: AzureTableStorageApplicationLogsConfig,
    BackupItem: BackupItem,
    BackupItemCollection: BackupItemCollection,
    BackupRequest: BackupRequest,
    BackupSchedule: BackupSchedule,
    BillingMeter: BillingMeter,
    BillingMeterCollection: BillingMeterCollection,
    BlobStorageTokenStore: BlobStorageTokenStore,
    Capability: Capability,
    Certificate: Certificate,
    CertificateCollection: CertificateCollection,
    CertificateDetails: CertificateDetails,
    CertificateEmail: CertificateEmail,
    CertificateOrderAction: CertificateOrderAction,
    CertificateOrderContact: CertificateOrderContact,
    CertificatePatchResource: CertificatePatchResource,
    ClientRegistration: ClientRegistration,
    CloningInfo: CloningInfo,
    Configuration: Configuration,
    ConnStringInfo: ConnStringInfo,
    ConnStringValueTypePair: ConnStringValueTypePair,
    ConnectionStringDictionary: ConnectionStringDictionary,
    Contact: Contact,
    Container: Container,
    ContainerApp: ContainerApp,
    ContainerAppCollection: ContainerAppCollection,
    ContainerAppSecret: ContainerAppSecret,
    ContainerAppsConfiguration: ContainerAppsConfiguration,
    ContainerCpuStatistics: ContainerCpuStatistics,
    ContainerCpuUsage: ContainerCpuUsage,
    ContainerInfo: ContainerInfo,
    ContainerMemoryStatistics: ContainerMemoryStatistics,
    ContainerNetworkInterfaceStatistics: ContainerNetworkInterfaceStatistics,
    ContainerResources: ContainerResources,
    ContainerThrottlingData: ContainerThrottlingData,
    ContentHash: ContentHash,
    ContentLink: ContentLink,
    ContinuousWebJob: ContinuousWebJob,
    ContinuousWebJobCollection: ContinuousWebJobCollection,
    CookieExpiration: CookieExpiration,
    Correlation: Correlation,
    CorsSettings: CorsSettings,
    CsmDeploymentStatus: CsmDeploymentStatus,
    CsmDeploymentStatusCollection: CsmDeploymentStatusCollection,
    CsmMoveResourceEnvelope: CsmMoveResourceEnvelope,
    CsmOperationCollection: CsmOperationCollection,
    CsmOperationDescription: CsmOperationDescription,
    CsmOperationDescriptionProperties: CsmOperationDescriptionProperties,
    CsmOperationDisplay: CsmOperationDisplay,
    CsmPublishingCredentialsPoliciesEntity: CsmPublishingCredentialsPoliciesEntity,
    CsmPublishingProfileOptions: CsmPublishingProfileOptions,
    CsmSlotEntity: CsmSlotEntity,
    CsmUsageQuota: CsmUsageQuota,
    CsmUsageQuotaCollection: CsmUsageQuotaCollection,
    CustomDnsSuffixConfiguration: CustomDnsSuffixConfiguration,
    CustomHostnameAnalysisResult: CustomHostnameAnalysisResult,
    CustomHostnameSites: CustomHostnameSites,
    CustomHostnameSitesCollection: CustomHostnameSitesCollection,
    CustomOpenIdConnectProvider: CustomOpenIdConnectProvider,
    CustomScaleRule: CustomScaleRule,
    Dapr: Dapr,
    DaprComponent: DaprComponent,
    DaprConfig: DaprConfig,
    DaprMetadata: DaprMetadata,
    DataProviderMetadata: DataProviderMetadata,
    DataSource: DataSource,
    DataTableResponseColumn: DataTableResponseColumn,
    DataTableResponseObject: DataTableResponseObject,
    DatabaseBackupSetting: DatabaseBackupSetting,
    DatabaseConnection: DatabaseConnection,
    DatabaseConnectionCollection: DatabaseConnectionCollection,
    DatabaseConnectionOverview: DatabaseConnectionOverview,
    DatabaseConnectionPatchRequest: DatabaseConnectionPatchRequest,
    DefaultAuthorizationPolicy: DefaultAuthorizationPolicy,
    DefaultErrorResponse: DefaultErrorResponse,
    DefaultErrorResponseError: DefaultErrorResponseError,
    DefaultErrorResponseErrorDetailsItem: DefaultErrorResponseErrorDetailsItem,
    DeletedAppRestoreRequest: DeletedAppRestoreRequest,
    DeletedSite: DeletedSite,
    DeletedWebAppCollection: DeletedWebAppCollection,
    Deployment: Deployment,
    DeploymentCollection: DeploymentCollection,
    DeploymentLocations: DeploymentLocations,
    DetectorAbnormalTimePeriod: DetectorAbnormalTimePeriod,
    DetectorDefinition: DetectorDefinition,
    DetectorDefinitionResource: DetectorDefinitionResource,
    DetectorInfo: DetectorInfo,
    DetectorResponse: DetectorResponse,
    DetectorResponseCollection: DetectorResponseCollection,
    DiagnosticAnalysis: DiagnosticAnalysis,
    DiagnosticAnalysisCollection: DiagnosticAnalysisCollection,
    DiagnosticCategory: DiagnosticCategory,
    DiagnosticCategoryCollection: DiagnosticCategoryCollection,
    DiagnosticData: DiagnosticData,
    DiagnosticDetectorCollection: DiagnosticDetectorCollection,
    DiagnosticDetectorResponse: DiagnosticDetectorResponse,
    DiagnosticMetricSample: DiagnosticMetricSample,
    DiagnosticMetricSet: DiagnosticMetricSet,
    Dimension: Dimension,
    Domain: Domain,
    DomainAvailabilityCheckResult: DomainAvailabilityCheckResult,
    DomainCollection: DomainCollection,
    DomainControlCenterSsoRequest: DomainControlCenterSsoRequest,
    DomainOwnershipIdentifier: DomainOwnershipIdentifier,
    DomainOwnershipIdentifierCollection: DomainOwnershipIdentifierCollection,
    DomainPatchResource: DomainPatchResource,
    DomainPurchaseConsent: DomainPurchaseConsent,
    DomainRecommendationSearchParameters: DomainRecommendationSearchParameters,
    EnabledConfig: EnabledConfig,
    EndpointDependency: EndpointDependency,
    EndpointDetail: EndpointDetail,
    EnvironmentVar: EnvironmentVar,
    EnvironmentVariable: EnvironmentVariable,
    ErrorEntity: ErrorEntity,
    ErrorInfo: ErrorInfo,
    ErrorProperties: ErrorProperties,
    ErrorResponse: ErrorResponse,
    Experiments: Experiments,
    Expression: Expression,
    ExpressionRoot: ExpressionRoot,
    ExpressionTraces: ExpressionTraces,
    ExtendedLocation: ExtendedLocation,
    Facebook: Facebook,
    FileSystemApplicationLogsConfig: FileSystemApplicationLogsConfig,
    FileSystemHttpLogsConfig: FileSystemHttpLogsConfig,
    FileSystemTokenStore: FileSystemTokenStore,
    FlowAccessControlConfiguration: FlowAccessControlConfiguration,
    FlowAccessControlConfigurationPolicy: FlowAccessControlConfigurationPolicy,
    FlowEndpoints: FlowEndpoints,
    FlowEndpointsConfiguration: FlowEndpointsConfiguration,
    ForwardProxy: ForwardProxy,
    FrontEndConfiguration: FrontEndConfiguration,
    FunctionAppConfig: FunctionAppConfig,
    FunctionAppMajorVersion: FunctionAppMajorVersion,
    FunctionAppMinorVersion: FunctionAppMinorVersion,
    FunctionAppRuntimeSettings: FunctionAppRuntimeSettings,
    FunctionAppRuntimes: FunctionAppRuntimes,
    FunctionAppStack: FunctionAppStack,
    FunctionAppStackCollection: FunctionAppStackCollection,
    FunctionEnvelope: FunctionEnvelope,
    FunctionEnvelopeCollection: FunctionEnvelopeCollection,
    FunctionSecrets: FunctionSecrets,
    FunctionsAlwaysReadyConfig: FunctionsAlwaysReadyConfig,
    FunctionsDeployment: FunctionsDeployment,
    FunctionsDeploymentStorage: FunctionsDeploymentStorage,
    FunctionsDeploymentStorageAuthentication: FunctionsDeploymentStorageAuthentication,
    FunctionsRuntime: FunctionsRuntime,
    FunctionsScaleAndConcurrency: FunctionsScaleAndConcurrency,
    FunctionsScaleAndConcurrencyTriggers: FunctionsScaleAndConcurrencyTriggers,
    FunctionsScaleAndConcurrencyTriggersHttp: FunctionsScaleAndConcurrencyTriggersHttp,
    GeoRegion: GeoRegion,
    GeoRegionCollection: GeoRegionCollection,
    GitHub: GitHub,
    GitHubActionCodeConfiguration: GitHubActionCodeConfiguration,
    GitHubActionConfiguration: GitHubActionConfiguration,
    GitHubActionContainerConfiguration: GitHubActionContainerConfiguration,
    GitHubActionWebAppStackSettings: GitHubActionWebAppStackSettings,
    GlobalCsmSkuDescription: GlobalCsmSkuDescription,
    GlobalValidation: GlobalValidation,
    Google: Google,
    HandlerMapping: HandlerMapping,
    HostKeys: HostKeys,
    HostName: HostName,
    HostNameBinding: HostNameBinding,
    HostNameBindingCollection: HostNameBindingCollection,
    HostNameSslState: HostNameSslState,
    HostingEnvironmentDeploymentInfo: HostingEnvironmentDeploymentInfo,
    HostingEnvironmentDiagnostics: HostingEnvironmentDiagnostics,
    HostingEnvironmentProfile: HostingEnvironmentProfile,
    HttpLogsConfig: HttpLogsConfig,
    HttpScaleRule: HttpScaleRule,
    HttpSettings: HttpSettings,
    HttpSettingsRoutes: HttpSettingsRoutes,
    HybridConnection: HybridConnection,
    HybridConnectionCollection: HybridConnectionCollection,
    HybridConnectionKey: HybridConnectionKey,
    HybridConnectionLimits: HybridConnectionLimits,
    Identifier: Identifier,
    IdentifierCollection: IdentifierCollection,
    IdentityProviders: IdentityProviders,
    InboundEnvironmentEndpoint: InboundEnvironmentEndpoint,
    InboundEnvironmentEndpointCollection: InboundEnvironmentEndpointCollection,
    Ingress: Ingress,
    IpAddress: IpAddress,
    IpAddressRange: IpAddressRange,
    IpSecurityRestriction: IpSecurityRestriction,
    JsonSchema: JsonSchema,
    JwtClaimChecks: JwtClaimChecks,
    KeyInfo: KeyInfo,
    KeyValuePairStringObject: KeyValuePairStringObject,
    KubeEnvironment: KubeEnvironment,
    KubeEnvironmentCollection: KubeEnvironmentCollection,
    KubeEnvironmentPatchResource: KubeEnvironmentPatchResource,
    KubeEnvironmentProfile: KubeEnvironmentProfile,
    LegacyMicrosoftAccount: LegacyMicrosoftAccount,
    LinuxJavaContainerSettings: LinuxJavaContainerSettings,
    LocalizableString: LocalizableString,
    LogAnalyticsConfiguration: LogAnalyticsConfiguration,
    LogSpecification: LogSpecification,
    Login: Login,
    LoginRoutes: LoginRoutes,
    LoginScopes: LoginScopes,
    MSDeploy: MSDeploy,
    MSDeployLog: MSDeployLog,
    MSDeployLogEntry: MSDeployLogEntry,
    MSDeployStatus: MSDeployStatus,
    ManagedServiceIdentity: ManagedServiceIdentity,
    MetricAvailability: MetricAvailability,
    MetricSpecification: MetricSpecification,
    MigrateMySqlRequest: MigrateMySqlRequest,
    MigrateMySqlStatus: MigrateMySqlStatus,
    NameIdentifier: NameIdentifier,
    NameIdentifierCollection: NameIdentifierCollection,
    NameValuePair: NameValuePair,
    NetworkFeatures: NetworkFeatures,
    NetworkTrace: NetworkTrace,
    Nonce: Nonce,
    OpenAuthenticationAccessPolicies: OpenAuthenticationAccessPolicies,
    OpenAuthenticationAccessPolicy: OpenAuthenticationAccessPolicy,
    OpenAuthenticationPolicyClaim: OpenAuthenticationPolicyClaim,
    OpenIdConnectClientCredential: OpenIdConnectClientCredential,
    OpenIdConnectConfig: OpenIdConnectConfig,
    OpenIdConnectLogin: OpenIdConnectLogin,
    OpenIdConnectRegistration: OpenIdConnectRegistration,
    Operation: Operation,
    OperationResult: OperationResult,
    OperationResultProperties: OperationResultProperties,
    OutboundEnvironmentEndpoint: OutboundEnvironmentEndpoint,
    OutboundEnvironmentEndpointCollection: OutboundEnvironmentEndpointCollection,
    PerfMonCounterCollection: PerfMonCounterCollection,
    PerfMonResponse: PerfMonResponse,
    PerfMonSample: PerfMonSample,
    PerfMonSet: PerfMonSet,
    PremierAddOn: PremierAddOn,
    PremierAddOnOffer: PremierAddOnOffer,
    PremierAddOnOfferCollection: PremierAddOnOfferCollection,
    PremierAddOnPatchResource: PremierAddOnPatchResource,
    PrivateAccess: PrivateAccess,
    PrivateAccessSubnet: PrivateAccessSubnet,
    PrivateAccessVirtualNetwork: PrivateAccessVirtualNetwork,
    PrivateEndpointConnectionCollection: PrivateEndpointConnectionCollection,
    PrivateLinkConnectionApprovalRequestResource: PrivateLinkConnectionApprovalRequestResource,
    PrivateLinkConnectionState: PrivateLinkConnectionState,
    PrivateLinkResource: PrivateLinkResource,
    PrivateLinkResourceProperties: PrivateLinkResourceProperties,
    PrivateLinkResourcesWrapper: PrivateLinkResourcesWrapper,
    ProcessInfo: ProcessInfo,
    ProcessInfoCollection: ProcessInfoCollection,
    ProcessModuleInfo: ProcessModuleInfo,
    ProcessModuleInfoCollection: ProcessModuleInfoCollection,
    ProcessThreadInfo: ProcessThreadInfo,
    ProcessThreadInfoCollection: ProcessThreadInfoCollection,
    ProxyOnlyResource: ProxyOnlyResource,
    PublicCertificate: PublicCertificate,
    PublicCertificateCollection: PublicCertificateCollection,
    PublishingCredentialsPoliciesCollection: PublishingCredentialsPoliciesCollection,
    PushSettings: PushSettings,
    QueryUtterancesResult: QueryUtterancesResult,
    QueryUtterancesResults: QueryUtterancesResults,
    QueueScaleRule: QueueScaleRule,
    RampUpRule: RampUpRule,
    Recommendation: Recommendation,
    RecommendationCollection: RecommendationCollection,
    RecommendationRule: RecommendationRule,
    RecurrenceSchedule: RecurrenceSchedule,
    RecurrenceScheduleOccurrence: RecurrenceScheduleOccurrence,
    RegenerateActionParameter: RegenerateActionParameter,
    RegistryCredentials: RegistryCredentials,
    ReissueCertificateOrderRequest: ReissueCertificateOrderRequest,
    RelayServiceConnectionEntity: RelayServiceConnectionEntity,
    RemotePrivateEndpointConnection: RemotePrivateEndpointConnection,
    RemotePrivateEndpointConnectionARMResource: RemotePrivateEndpointConnectionARMResource,
    Rendering: Rendering,
    RenewCertificateOrderRequest: RenewCertificateOrderRequest,
    RepetitionIndex: RepetitionIndex,
    Request: Request,
    RequestHistory: RequestHistory,
    RequestHistoryListResult: RequestHistoryListResult,
    RequestHistoryProperties: RequestHistoryProperties,
    RequestsBasedTrigger: RequestsBasedTrigger,
    Resource: Resource,
    ResourceCollection: ResourceCollection,
    ResourceConfig: ResourceConfig,
    ResourceHealthMetadata: ResourceHealthMetadata,
    ResourceHealthMetadataCollection: ResourceHealthMetadataCollection,
    ResourceMetricAvailability: ResourceMetricAvailability,
    ResourceMetricDefinition: ResourceMetricDefinition,
    ResourceMetricDefinitionCollection: ResourceMetricDefinitionCollection,
    ResourceNameAvailability: ResourceNameAvailability,
    ResourceNameAvailabilityRequest: ResourceNameAvailabilityRequest,
    ResourceReference: ResourceReference,
    Response: Response,
    ResponseMessageEnvelopeRemotePrivateEndpointConnection: ResponseMessageEnvelopeRemotePrivateEndpointConnection,
    ResponseMetaData: ResponseMetaData,
    RestoreRequest: RestoreRequest,
    RetryHistory: RetryHistory,
    Revision: Revision,
    RevisionCollection: RevisionCollection,
    RunActionCorrelation: RunActionCorrelation,
    RunCorrelation: RunCorrelation,
    SampleUtterance: SampleUtterance,
    Scale: Scale,
    ScaleRule: ScaleRule,
    ScaleRuleAuth: ScaleRuleAuth,
    Secret: Secret,
    SecretsCollection: SecretsCollection,
    ServiceSpecification: ServiceSpecification,
    Site: Site,
    SiteAuthSettings: SiteAuthSettings,
    SiteAuthSettingsV2: SiteAuthSettingsV2,
    SiteCloneability: SiteCloneability,
    SiteCloneabilityCriterion: SiteCloneabilityCriterion,
    SiteConfig: SiteConfig,
    SiteConfigPropertiesDictionary: SiteConfigPropertiesDictionary,
    SiteConfigResource: SiteConfigResource,
    SiteConfigResourceCollection: SiteConfigResourceCollection,
    SiteConfigurationSnapshotInfo: SiteConfigurationSnapshotInfo,
    SiteConfigurationSnapshotInfoCollection: SiteConfigurationSnapshotInfoCollection,
    SiteContainer: SiteContainer,
    SiteContainerCollection: SiteContainerCollection,
    SiteDnsConfig: SiteDnsConfig,
    SiteExtensionInfo: SiteExtensionInfo,
    SiteExtensionInfoCollection: SiteExtensionInfoCollection,
    SiteLimits: SiteLimits,
    SiteLogsConfig: SiteLogsConfig,
    SiteMachineKey: SiteMachineKey,
    SitePatchResource: SitePatchResource,
    SitePhpErrorLogFlag: SitePhpErrorLogFlag,
    SiteSeal: SiteSeal,
    SiteSealRequest: SiteSealRequest,
    SiteSourceControl: SiteSourceControl,
    SkuCapacity: SkuCapacity,
    SkuDescription: SkuDescription,
    SkuInfo: SkuInfo,
    SkuInfoCollection: SkuInfoCollection,
    SkuInfos: SkuInfos,
    SlotConfigNamesResource: SlotConfigNamesResource,
    SlotDifference: SlotDifference,
    SlotDifferenceCollection: SlotDifferenceCollection,
    SlotSwapStatus: SlotSwapStatus,
    SlowRequestsBasedTrigger: SlowRequestsBasedTrigger,
    Snapshot: Snapshot,
    SnapshotCollection: SnapshotCollection,
    SnapshotRecoverySource: SnapshotRecoverySource,
    SnapshotRestoreRequest: SnapshotRestoreRequest,
    Solution: Solution,
    SourceControl: SourceControl,
    SourceControlCollection: SourceControlCollection,
    StackMajorVersion: StackMajorVersion,
    StackMinorVersion: StackMinorVersion,
    StampCapacity: StampCapacity,
    StampCapacityCollection: StampCapacityCollection,
    StaticSiteARMResource: StaticSiteARMResource,
    StaticSiteBasicAuthPropertiesARMResource: StaticSiteBasicAuthPropertiesARMResource,
    StaticSiteBasicAuthPropertiesCollection: StaticSiteBasicAuthPropertiesCollection,
    StaticSiteBuildARMResource: StaticSiteBuildARMResource,
    StaticSiteBuildCollection: StaticSiteBuildCollection,
    StaticSiteBuildProperties: StaticSiteBuildProperties,
    StaticSiteCollection: StaticSiteCollection,
    StaticSiteCustomDomainOverviewARMResource: StaticSiteCustomDomainOverviewARMResource,
    StaticSiteCustomDomainOverviewCollection: StaticSiteCustomDomainOverviewCollection,
    StaticSiteCustomDomainRequestPropertiesARMResource: StaticSiteCustomDomainRequestPropertiesARMResource,
    StaticSiteDatabaseConnectionConfigurationFileOverview: StaticSiteDatabaseConnectionConfigurationFileOverview,
    StaticSiteFunctionOverviewARMResource: StaticSiteFunctionOverviewARMResource,
    StaticSiteFunctionOverviewCollection: StaticSiteFunctionOverviewCollection,
    StaticSiteLinkedBackend: StaticSiteLinkedBackend,
    StaticSiteLinkedBackendARMResource: StaticSiteLinkedBackendARMResource,
    StaticSiteLinkedBackendsCollection: StaticSiteLinkedBackendsCollection,
    StaticSitePatchResource: StaticSitePatchResource,
    StaticSiteResetPropertiesARMResource: StaticSiteResetPropertiesARMResource,
    StaticSiteTemplateOptions: StaticSiteTemplateOptions,
    StaticSiteUserARMResource: StaticSiteUserARMResource,
    StaticSiteUserCollection: StaticSiteUserCollection,
    StaticSiteUserInvitationRequestResource: StaticSiteUserInvitationRequestResource,
    StaticSiteUserInvitationResponseResource: StaticSiteUserInvitationResponseResource,
    StaticSiteUserProvidedFunctionApp: StaticSiteUserProvidedFunctionApp,
    StaticSiteUserProvidedFunctionAppARMResource: StaticSiteUserProvidedFunctionAppARMResource,
    StaticSiteUserProvidedFunctionAppsCollection: StaticSiteUserProvidedFunctionAppsCollection,
    StaticSiteZipDeploymentARMResource: StaticSiteZipDeploymentARMResource,
    StaticSitesWorkflowPreview: StaticSitesWorkflowPreview,
    StaticSitesWorkflowPreviewRequest: StaticSitesWorkflowPreviewRequest,
    Status: Status,
    StatusCodesBasedTrigger: StatusCodesBasedTrigger,
    StatusCodesRangeBasedTrigger: StatusCodesRangeBasedTrigger,
    StorageMigrationOptions: StorageMigrationOptions,
    StorageMigrationResponse: StorageMigrationResponse,
    StringDictionary: StringDictionary,
    StringList: StringList,
    SubResource: SubResource,
    SupportTopic: SupportTopic,
    SwiftVirtualNetwork: SwiftVirtualNetwork,
    Template: Template,
    TldLegalAgreement: TldLegalAgreement,
    TldLegalAgreementCollection: TldLegalAgreementCollection,
    TokenStore: TokenStore,
    TopLevelDomain: TopLevelDomain,
    TopLevelDomainAgreementOption: TopLevelDomainAgreementOption,
    TopLevelDomainCollection: TopLevelDomainCollection,
    TrafficWeight: TrafficWeight,
    TriggeredJobHistory: TriggeredJobHistory,
    TriggeredJobHistoryCollection: TriggeredJobHistoryCollection,
    TriggeredJobRun: TriggeredJobRun,
    TriggeredWebJob: TriggeredWebJob,
    TriggeredWebJobCollection: TriggeredWebJobCollection,
    Twitter: Twitter,
    TwitterRegistration: TwitterRegistration,
    Usage: Usage,
    UsageCollection: UsageCollection,
    User: User,
    UserAssignedIdentity: UserAssignedIdentity,
    ValidateRequest: ValidateRequest,
    ValidateResponse: ValidateResponse,
    ValidateResponseError: ValidateResponseError,
    VirtualApplication: VirtualApplication,
    VirtualDirectory: VirtualDirectory,
    VirtualIPMapping: VirtualIPMapping,
    VirtualNetworkProfile: VirtualNetworkProfile,
    VnetGateway: VnetGateway,
    VnetInfo: VnetInfo,
    VnetInfoResource: VnetInfoResource,
    VnetParameters: VnetParameters,
    VnetRoute: VnetRoute,
    VnetValidationFailureDetails: VnetValidationFailureDetails,
    VnetValidationTestFailure: VnetValidationTestFailure,
    VolumeMount: VolumeMount,
    WebAppCollection: WebAppCollection,
    WebAppInstanceStatusCollection: WebAppInstanceStatusCollection,
    WebAppMajorVersion: WebAppMajorVersion,
    WebAppMinorVersion: WebAppMinorVersion,
    WebAppRuntimeSettings: WebAppRuntimeSettings,
    WebAppRuntimes: WebAppRuntimes,
    WebAppStack: WebAppStack,
    WebAppStackCollection: WebAppStackCollection,
    WebJob: WebJob,
    WebJobCollection: WebJobCollection,
    WebSiteInstanceStatus: WebSiteInstanceStatus,
    WindowsJavaContainerSettings: WindowsJavaContainerSettings,
    WorkerPoolCollection: WorkerPoolCollection,
    WorkerPoolResource: WorkerPoolResource,
    Workflow: Workflow,
    WorkflowArtifacts: WorkflowArtifacts,
    WorkflowEnvelope: WorkflowEnvelope,
    WorkflowEnvelopeCollection: WorkflowEnvelopeCollection,
    WorkflowEnvelopeProperties: WorkflowEnvelopeProperties,
    WorkflowFilter: WorkflowFilter,
    WorkflowHealth: WorkflowHealth,
    WorkflowListResult: WorkflowListResult,
    WorkflowOutputParameter: WorkflowOutputParameter,
    WorkflowParameter: WorkflowParameter,
    WorkflowResource: WorkflowResource,
    WorkflowRun: WorkflowRun,
    WorkflowRunAction: WorkflowRunAction,
    WorkflowRunActionFilter: WorkflowRunActionFilter,
    WorkflowRunActionListResult: WorkflowRunActionListResult,
    WorkflowRunActionRepetitionDefinition: WorkflowRunActionRepetitionDefinition,
    WorkflowRunActionRepetitionDefinitionCollection: WorkflowRunActionRepetitionDefinitionCollection,
    WorkflowRunActionRepetitionProperties: WorkflowRunActionRepetitionProperties,
    WorkflowRunFilter: WorkflowRunFilter,
    WorkflowRunListResult: WorkflowRunListResult,
    WorkflowRunTrigger: WorkflowRunTrigger,
    WorkflowSku: WorkflowSku,
    WorkflowTrigger: WorkflowTrigger,
    WorkflowTriggerCallbackUrl: WorkflowTriggerCallbackUrl,
    WorkflowTriggerFilter: WorkflowTriggerFilter,
    WorkflowTriggerHistory: WorkflowTriggerHistory,
    WorkflowTriggerHistoryFilter: WorkflowTriggerHistoryFilter,
    WorkflowTriggerHistoryListResult: WorkflowTriggerHistoryListResult,
    WorkflowTriggerListCallbackUrlQueries: WorkflowTriggerListCallbackUrlQueries,
    WorkflowTriggerListResult: WorkflowTriggerListResult,
    WorkflowTriggerRecurrence: WorkflowTriggerRecurrence,
    WorkflowVersion: WorkflowVersion,
    WorkflowVersionListResult: WorkflowVersionListResult
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        xmlName: "$host",
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        xmlName: "subscriptionId",
        type: {
            name: "String",
        },
    },
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-12-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String",
        },
    },
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String",
        },
    },
};
const appServiceCertificateOrder = {
    parameterPath: "appServiceCertificateOrder",
    mapper: AppServiceCertificateOrder,
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+[^\\.]$"),
            MaxLength: 90,
            MinLength: 1,
        },
        serializedName: "resourceGroupName",
        required: true,
        xmlName: "resourceGroupName",
        type: {
            name: "String",
        },
    },
};
const certificateOrderName = {
    parameterPath: "certificateOrderName",
    mapper: {
        serializedName: "certificateOrderName",
        required: true,
        xmlName: "certificateOrderName",
        type: {
            name: "String",
        },
    },
};
const certificateDistinguishedName = {
    parameterPath: "certificateDistinguishedName",
    mapper: AppServiceCertificateOrder,
};
const certificateDistinguishedName1 = {
    parameterPath: "certificateDistinguishedName",
    mapper: AppServiceCertificateOrderPatchResource,
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        xmlName: "name",
        type: {
            name: "String",
        },
    },
};
const keyVaultCertificate = {
    parameterPath: "keyVaultCertificate",
    mapper: AppServiceCertificateResource,
};
const keyVaultCertificate1 = {
    parameterPath: "keyVaultCertificate",
    mapper: AppServiceCertificatePatchResource,
};
const reissueCertificateOrderRequest = {
    parameterPath: "reissueCertificateOrderRequest",
    mapper: ReissueCertificateOrderRequest,
};
const renewCertificateOrderRequest = {
    parameterPath: "renewCertificateOrderRequest",
    mapper: RenewCertificateOrderRequest,
};
const nameIdentifier = {
    parameterPath: "nameIdentifier",
    mapper: NameIdentifier,
};
const siteSealRequest = {
    parameterPath: "siteSealRequest",
    mapper: SiteSealRequest,
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        xmlName: "nextLink",
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const detectorName = {
    parameterPath: "detectorName",
    mapper: {
        serializedName: "detectorName",
        required: true,
        xmlName: "detectorName",
        type: {
            name: "String",
        },
    },
};
const startTime = {
    parameterPath: ["options", "startTime"],
    mapper: {
        serializedName: "startTime",
        xmlName: "startTime",
        type: {
            name: "DateTime",
        },
    },
};
const endTime = {
    parameterPath: ["options", "endTime"],
    mapper: {
        serializedName: "endTime",
        xmlName: "endTime",
        type: {
            name: "DateTime",
        },
    },
};
const timeGrain = {
    parameterPath: ["options", "timeGrain"],
    mapper: {
        constraints: {
            Pattern: new RegExp("PT[1-9][0-9]+[SMH]"),
        },
        serializedName: "timeGrain",
        xmlName: "timeGrain",
        type: {
            name: "String",
        },
    },
};
const identifier = {
    parameterPath: "identifier",
    mapper: NameIdentifier,
};
const parameters = {
    parameterPath: "parameters",
    mapper: DomainRecommendationSearchParameters,
};
const domainName = {
    parameterPath: "domainName",
    mapper: {
        serializedName: "domainName",
        required: true,
        xmlName: "domainName",
        type: {
            name: "String",
        },
    },
};
const domain = {
    parameterPath: "domain",
    mapper: Domain,
};
const domainName1 = {
    parameterPath: "domainName",
    mapper: {
        constraints: {
            Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9\\.-]+"),
        },
        serializedName: "domainName",
        required: true,
        xmlName: "domainName",
        type: {
            name: "String",
        },
    },
};
const forceHardDeleteDomain = {
    parameterPath: ["options", "forceHardDeleteDomain"],
    mapper: {
        serializedName: "forceHardDeleteDomain",
        xmlName: "forceHardDeleteDomain",
        type: {
            name: "Boolean",
        },
    },
};
const domain1 = {
    parameterPath: "domain",
    mapper: DomainPatchResource,
};
const domainOwnershipIdentifier = {
    parameterPath: "domainOwnershipIdentifier",
    mapper: DomainOwnershipIdentifier,
};
const agreementOption = {
    parameterPath: "agreementOption",
    mapper: TopLevelDomainAgreementOption,
};
const hostingEnvironmentEnvelope = {
    parameterPath: "hostingEnvironmentEnvelope",
    mapper: AppServiceEnvironmentResource,
};
const forceDelete = {
    parameterPath: ["options", "forceDelete"],
    mapper: {
        serializedName: "forceDelete",
        xmlName: "forceDelete",
        type: {
            name: "Boolean",
        },
    },
};
const hostingEnvironmentEnvelope1 = {
    parameterPath: "hostingEnvironmentEnvelope",
    mapper: AppServiceEnvironmentPatchResource,
};
const vnetInfo = {
    parameterPath: "vnetInfo",
    mapper: VirtualNetworkProfile,
};
const customDnsSuffixConfiguration = {
    parameterPath: "customDnsSuffixConfiguration",
    mapper: CustomDnsSuffixConfiguration,
};
const aseNetworkingConfiguration = {
    parameterPath: "aseNetworkingConfiguration",
    mapper: AseV3NetworkingConfiguration,
};
const diagnosticsName = {
    parameterPath: "diagnosticsName",
    mapper: {
        serializedName: "diagnosticsName",
        required: true,
        xmlName: "diagnosticsName",
        type: {
            name: "String",
        },
    },
};
const multiRolePoolEnvelope = {
    parameterPath: "multiRolePoolEnvelope",
    mapper: WorkerPoolResource,
};
const instance = {
    parameterPath: "instance",
    mapper: {
        serializedName: "instance",
        required: true,
        xmlName: "instance",
        type: {
            name: "String",
        },
    },
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        xmlName: "privateEndpointConnectionName",
        type: {
            name: "String",
        },
    },
};
const privateEndpointWrapper = {
    parameterPath: "privateEndpointWrapper",
    mapper: RemotePrivateEndpointConnectionARMResource,
};
const propertiesToInclude = {
    parameterPath: ["options", "propertiesToInclude"],
    mapper: {
        serializedName: "propertiesToInclude",
        xmlName: "propertiesToInclude",
        type: {
            name: "String",
        },
    },
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        xmlName: "$filter",
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const workerPoolName = {
    parameterPath: "workerPoolName",
    mapper: {
        serializedName: "workerPoolName",
        required: true,
        xmlName: "workerPoolName",
        type: {
            name: "String",
        },
    },
};
const workerPoolEnvelope = {
    parameterPath: "workerPoolEnvelope",
    mapper: WorkerPoolResource,
};
const detailed = {
    parameterPath: ["options", "detailed"],
    mapper: {
        serializedName: "detailed",
        xmlName: "detailed",
        type: {
            name: "Boolean",
        },
    },
};
const appServicePlan = {
    parameterPath: "appServicePlan",
    mapper: AppServicePlan,
};
const appServicePlan1 = {
    parameterPath: "appServicePlan",
    mapper: AppServicePlanPatchResource,
};
const namespaceName = {
    parameterPath: "namespaceName",
    mapper: {
        serializedName: "namespaceName",
        required: true,
        xmlName: "namespaceName",
        type: {
            name: "String",
        },
    },
};
const relayName = {
    parameterPath: "relayName",
    mapper: {
        serializedName: "relayName",
        required: true,
        xmlName: "relayName",
        type: {
            name: "String",
        },
    },
};
const softRestart = {
    parameterPath: ["options", "softRestart"],
    mapper: {
        serializedName: "softRestart",
        xmlName: "softRestart",
        type: {
            name: "Boolean",
        },
    },
};
const skipToken = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "$skipToken",
        xmlName: "$skipToken",
        type: {
            name: "String",
        },
    },
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        xmlName: "$top",
        type: {
            name: "String",
        },
    },
};
const vnetName = {
    parameterPath: "vnetName",
    mapper: {
        serializedName: "vnetName",
        required: true,
        xmlName: "vnetName",
        type: {
            name: "String",
        },
    },
};
const gatewayName = {
    parameterPath: "gatewayName",
    mapper: {
        serializedName: "gatewayName",
        required: true,
        xmlName: "gatewayName",
        type: {
            name: "String",
        },
    },
};
const connectionEnvelope = {
    parameterPath: "connectionEnvelope",
    mapper: VnetGateway,
};
const routeName = {
    parameterPath: "routeName",
    mapper: {
        serializedName: "routeName",
        required: true,
        xmlName: "routeName",
        type: {
            name: "String",
        },
    },
};
const route = {
    parameterPath: "route",
    mapper: VnetRoute,
};
const workerName = {
    parameterPath: "workerName",
    mapper: {
        serializedName: "workerName",
        required: true,
        xmlName: "workerName",
        type: {
            name: "String",
        },
    },
};
const certificateEnvelope = {
    parameterPath: "certificateEnvelope",
    mapper: Certificate,
};
const certificateEnvelope1 = {
    parameterPath: "certificateEnvelope",
    mapper: CertificatePatchResource,
};
const containerAppEnvelope = {
    parameterPath: "containerAppEnvelope",
    mapper: ContainerApp,
};
const containerAppName = {
    parameterPath: "containerAppName",
    mapper: {
        serializedName: "containerAppName",
        required: true,
        xmlName: "containerAppName",
        type: {
            name: "String",
        },
    },
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        xmlName: "location",
        type: {
            name: "String",
        },
    },
};
const deletedSiteId = {
    parameterPath: "deletedSiteId",
    mapper: {
        serializedName: "deletedSiteId",
        required: true,
        xmlName: "deletedSiteId",
        type: {
            name: "String",
        },
    },
};
const siteName = {
    parameterPath: "siteName",
    mapper: {
        serializedName: "siteName",
        required: true,
        xmlName: "siteName",
        type: {
            name: "String",
        },
    },
};
const diagnosticCategory = {
    parameterPath: "diagnosticCategory",
    mapper: {
        serializedName: "diagnosticCategory",
        required: true,
        xmlName: "diagnosticCategory",
        type: {
            name: "String",
        },
    },
};
const analysisName = {
    parameterPath: "analysisName",
    mapper: {
        serializedName: "analysisName",
        required: true,
        xmlName: "analysisName",
        type: {
            name: "String",
        },
    },
};
const slot = {
    parameterPath: "slot",
    mapper: {
        serializedName: "slot",
        required: true,
        xmlName: "slot",
        type: {
            name: "String",
        },
    },
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        xmlName: "operationId",
        type: {
            name: "String",
        },
    },
};
const kubeEnvironmentEnvelope = {
    parameterPath: "kubeEnvironmentEnvelope",
    mapper: KubeEnvironment,
};
const kubeEnvironmentEnvelope1 = {
    parameterPath: "kubeEnvironmentEnvelope",
    mapper: KubeEnvironmentPatchResource,
};
const osTypeSelected = {
    parameterPath: ["options", "osTypeSelected"],
    mapper: {
        serializedName: "osTypeSelected",
        xmlName: "osTypeSelected",
        type: {
            name: "String",
        },
    },
};
const stackOsType = {
    parameterPath: ["options", "stackOsType"],
    mapper: {
        serializedName: "stackOsType",
        xmlName: "stackOsType",
        type: {
            name: "String",
        },
    },
};
const featured = {
    parameterPath: ["options", "featured"],
    mapper: {
        serializedName: "featured",
        xmlName: "featured",
        type: {
            name: "Boolean",
        },
    },
};
const hostingEnvironmentName = {
    parameterPath: "hostingEnvironmentName",
    mapper: {
        serializedName: "hostingEnvironmentName",
        required: true,
        xmlName: "hostingEnvironmentName",
        type: {
            name: "String",
        },
    },
};
const expiredOnly = {
    parameterPath: ["options", "expiredOnly"],
    mapper: {
        serializedName: "expiredOnly",
        xmlName: "expiredOnly",
        type: {
            name: "Boolean",
        },
    },
};
const environmentName = {
    parameterPath: "environmentName",
    mapper: {
        serializedName: "environmentName",
        required: true,
        xmlName: "environmentName",
        type: {
            name: "String",
        },
    },
};
const updateSeen = {
    parameterPath: ["options", "updateSeen"],
    mapper: {
        serializedName: "updateSeen",
        xmlName: "updateSeen",
        type: {
            name: "Boolean",
        },
    },
};
const recommendationId = {
    parameterPath: ["options", "recommendationId"],
    mapper: {
        serializedName: "recommendationId",
        xmlName: "recommendationId",
        type: {
            name: "String",
        },
    },
};
const userDetails = {
    parameterPath: "userDetails",
    mapper: User,
};
const sourceControlType = {
    parameterPath: "sourceControlType",
    mapper: {
        serializedName: "sourceControlType",
        required: true,
        xmlName: "sourceControlType",
        type: {
            name: "String",
        },
    },
};
const requestMessage = {
    parameterPath: "requestMessage",
    mapper: SourceControl,
};
const billingLocation = {
    parameterPath: ["options", "billingLocation"],
    mapper: {
        serializedName: "billingLocation",
        xmlName: "billingLocation",
        type: {
            name: "String",
        },
    },
};
const osType = {
    parameterPath: ["options", "osType"],
    mapper: {
        serializedName: "osType",
        xmlName: "osType",
        type: {
            name: "String",
        },
    },
};
const hostname = {
    parameterPath: ["options", "hostname"],
    mapper: {
        serializedName: "hostname",
        xmlName: "hostname",
        type: {
            name: "String",
        },
    },
};
const sku = {
    parameterPath: ["options", "sku"],
    mapper: {
        serializedName: "sku",
        xmlName: "sku",
        type: {
            name: "String",
        },
    },
};
const linuxWorkersEnabled = {
    parameterPath: ["options", "linuxWorkersEnabled"],
    mapper: {
        serializedName: "linuxWorkersEnabled",
        xmlName: "linuxWorkersEnabled",
        type: {
            name: "Boolean",
        },
    },
};
const xenonWorkersEnabled = {
    parameterPath: ["options", "xenonWorkersEnabled"],
    mapper: {
        serializedName: "xenonWorkersEnabled",
        xmlName: "xenonWorkersEnabled",
        type: {
            name: "Boolean",
        },
    },
};
const linuxDynamicWorkersEnabled = {
    parameterPath: ["options", "linuxDynamicWorkersEnabled"],
    mapper: {
        serializedName: "linuxDynamicWorkersEnabled",
        xmlName: "linuxDynamicWorkersEnabled",
        type: {
            name: "Boolean",
        },
    },
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: VnetParameters,
};
const moveResourceEnvelope = {
    parameterPath: "moveResourceEnvelope",
    mapper: CsmMoveResourceEnvelope,
};
const validateRequest = {
    parameterPath: "validateRequest",
    mapper: ValidateRequest,
};
const location1 = {
    parameterPath: "location",
    mapper: {
        constraints: {
            MinLength: 1,
        },
        serializedName: "location",
        required: true,
        xmlName: "location",
        type: {
            name: "String",
        },
    },
};
const staticSitesWorkflowPreviewRequest = {
    parameterPath: "staticSitesWorkflowPreviewRequest",
    mapper: StaticSitesWorkflowPreviewRequest,
};
const staticSiteEnvelope = {
    parameterPath: "staticSiteEnvelope",
    mapper: StaticSiteARMResource,
};
const staticSiteEnvelope1 = {
    parameterPath: "staticSiteEnvelope",
    mapper: StaticSitePatchResource,
};
const authprovider = {
    parameterPath: "authprovider",
    mapper: {
        serializedName: "authprovider",
        required: true,
        xmlName: "authprovider",
        type: {
            name: "String",
        },
    },
};
const userid = {
    parameterPath: "userid",
    mapper: {
        serializedName: "userid",
        required: true,
        xmlName: "userid",
        type: {
            name: "String",
        },
    },
};
const staticSiteUserEnvelope = {
    parameterPath: "staticSiteUserEnvelope",
    mapper: StaticSiteUserARMResource,
};
const environmentName1 = {
    parameterPath: "environmentName",
    mapper: {
        serializedName: "environmentName",
        required: true,
        xmlName: "environmentName",
        type: {
            name: "String",
        },
    },
};
const appSettings = {
    parameterPath: "appSettings",
    mapper: StringDictionary,
};
const environmentName2 = {
    parameterPath: "environmentName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]+$"),
        },
        serializedName: "environmentName",
        required: true,
        xmlName: "environmentName",
        type: {
            name: "String",
        },
    },
};
const databaseConnectionName = {
    parameterPath: "databaseConnectionName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]+$"),
        },
        serializedName: "databaseConnectionName",
        required: true,
        xmlName: "databaseConnectionName",
        type: {
            name: "String",
        },
    },
};
const databaseConnectionRequestEnvelope = {
    parameterPath: "databaseConnectionRequestEnvelope",
    mapper: DatabaseConnection,
};
const databaseConnectionRequestEnvelope1 = {
    parameterPath: "databaseConnectionRequestEnvelope",
    mapper: DatabaseConnectionPatchRequest,
};
const functionAppName = {
    parameterPath: "functionAppName",
    mapper: {
        serializedName: "functionAppName",
        required: true,
        xmlName: "functionAppName",
        type: {
            name: "String",
        },
    },
};
const staticSiteUserProvidedFunctionEnvelope = {
    parameterPath: "staticSiteUserProvidedFunctionEnvelope",
    mapper: StaticSiteUserProvidedFunctionAppARMResource,
};
const isForced = {
    parameterPath: ["options", "isForced"],
    mapper: {
        serializedName: "isForced",
        xmlName: "isForced",
        type: {
            name: "Boolean",
        },
    },
};
const staticSiteZipDeploymentEnvelope = {
    parameterPath: "staticSiteZipDeploymentEnvelope",
    mapper: StaticSiteZipDeploymentARMResource,
};
const basicAuthName = {
    parameterPath: "basicAuthName",
    mapper: {
        serializedName: "basicAuthName",
        required: true,
        xmlName: "basicAuthName",
        type: {
            name: "String",
        },
    },
};
const basicAuthEnvelope = {
    parameterPath: "basicAuthEnvelope",
    mapper: StaticSiteBasicAuthPropertiesARMResource,
};
const staticSiteUserRolesInvitationEnvelope = {
    parameterPath: "staticSiteUserRolesInvitationEnvelope",
    mapper: StaticSiteUserInvitationRequestResource,
};
const staticSiteCustomDomainRequestPropertiesEnvelope = {
    parameterPath: "staticSiteCustomDomainRequestPropertiesEnvelope",
    mapper: StaticSiteCustomDomainRequestPropertiesARMResource,
};
const resetPropertiesEnvelope = {
    parameterPath: "resetPropertiesEnvelope",
    mapper: StaticSiteResetPropertiesARMResource,
};
const staticSiteLinkedBackendEnvelope = {
    parameterPath: "staticSiteLinkedBackendEnvelope",
    mapper: StaticSiteLinkedBackendARMResource,
};
const linkedBackendName = {
    parameterPath: "linkedBackendName",
    mapper: {
        serializedName: "linkedBackendName",
        required: true,
        xmlName: "linkedBackendName",
        type: {
            name: "String",
        },
    },
};
const isCleaningAuthConfig = {
    parameterPath: ["options", "isCleaningAuthConfig"],
    mapper: {
        serializedName: "isCleaningAuthConfig",
        xmlName: "isCleaningAuthConfig",
        type: {
            name: "Boolean",
        },
    },
};
const includeSlots = {
    parameterPath: ["options", "includeSlots"],
    mapper: {
        serializedName: "includeSlots",
        xmlName: "includeSlots",
        type: {
            name: "Boolean",
        },
    },
};
const siteEnvelope = {
    parameterPath: "siteEnvelope",
    mapper: Site,
};
const deleteMetrics = {
    parameterPath: ["options", "deleteMetrics"],
    mapper: {
        serializedName: "deleteMetrics",
        xmlName: "deleteMetrics",
        type: {
            name: "Boolean",
        },
    },
};
const deleteEmptyServerFarm = {
    parameterPath: ["options", "deleteEmptyServerFarm"],
    mapper: {
        serializedName: "deleteEmptyServerFarm",
        xmlName: "deleteEmptyServerFarm",
        type: {
            name: "Boolean",
        },
    },
};
const siteEnvelope1 = {
    parameterPath: "siteEnvelope",
    mapper: SitePatchResource,
};
const hostName = {
    parameterPath: ["options", "hostName"],
    mapper: {
        serializedName: "hostName",
        xmlName: "hostName",
        type: {
            name: "String",
        },
    },
};
const slotSwapEntity = {
    parameterPath: "slotSwapEntity",
    mapper: CsmSlotEntity,
};
const request1 = {
    parameterPath: "request",
    mapper: BackupRequest,
};
const backupId = {
    parameterPath: "backupId",
    mapper: {
        serializedName: "backupId",
        required: true,
        xmlName: "backupId",
        type: {
            name: "String",
        },
    },
};
const request2 = {
    parameterPath: "request",
    mapper: RestoreRequest,
};
const csmPublishingAccessPoliciesEntity = {
    parameterPath: "csmPublishingAccessPoliciesEntity",
    mapper: CsmPublishingCredentialsPoliciesEntity,
};
const siteAuthSettings = {
    parameterPath: "siteAuthSettings",
    mapper: SiteAuthSettings,
};
const siteAuthSettingsV2 = {
    parameterPath: "siteAuthSettingsV2",
    mapper: SiteAuthSettingsV2,
};
const azureStorageAccounts = {
    parameterPath: "azureStorageAccounts",
    mapper: AzureStoragePropertyDictionaryResource,
};
const appSettingKey = {
    parameterPath: "appSettingKey",
    mapper: {
        serializedName: "appSettingKey",
        required: true,
        xmlName: "appSettingKey",
        type: {
            name: "String",
        },
    },
};
const connectionStringKey = {
    parameterPath: "connectionStringKey",
    mapper: {
        serializedName: "connectionStringKey",
        required: true,
        xmlName: "connectionStringKey",
        type: {
            name: "String",
        },
    },
};
const connectionStrings = {
    parameterPath: "connectionStrings",
    mapper: ConnectionStringDictionary,
};
const siteLogsConfig = {
    parameterPath: "siteLogsConfig",
    mapper: SiteLogsConfig,
};
const metadata = {
    parameterPath: "metadata",
    mapper: StringDictionary,
};
const pushSettings = {
    parameterPath: "pushSettings",
    mapper: PushSettings,
};
const slotConfigNames = {
    parameterPath: "slotConfigNames",
    mapper: SlotConfigNamesResource,
};
const siteConfig = {
    parameterPath: "siteConfig",
    mapper: SiteConfigResource,
};
const snapshotId = {
    parameterPath: "snapshotId",
    mapper: {
        serializedName: "snapshotId",
        required: true,
        xmlName: "snapshotId",
        type: {
            name: "String",
        },
    },
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/zip",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const webJobName = {
    parameterPath: "webJobName",
    mapper: {
        serializedName: "webJobName",
        required: true,
        xmlName: "webJobName",
        type: {
            name: "String",
        },
    },
};
const deploymentStatusId = {
    parameterPath: "deploymentStatusId",
    mapper: {
        serializedName: "deploymentStatusId",
        required: true,
        xmlName: "deploymentStatusId",
        type: {
            name: "String",
        },
    },
};
const id = {
    parameterPath: "id",
    mapper: {
        serializedName: "id",
        required: true,
        xmlName: "id",
        type: {
            name: "String",
        },
    },
};
const deployment = {
    parameterPath: "deployment",
    mapper: Deployment,
};
const domainOwnershipIdentifierName = {
    parameterPath: "domainOwnershipIdentifierName",
    mapper: {
        serializedName: "domainOwnershipIdentifierName",
        required: true,
        xmlName: "domainOwnershipIdentifierName",
        type: {
            name: "String",
        },
    },
};
const domainOwnershipIdentifier1 = {
    parameterPath: "domainOwnershipIdentifier",
    mapper: Identifier,
};
const mSDeploy = {
    parameterPath: "mSDeploy",
    mapper: MSDeploy,
};
const functionName = {
    parameterPath: "functionName",
    mapper: {
        serializedName: "functionName",
        required: true,
        xmlName: "functionName",
        type: {
            name: "String",
        },
    },
};
const functionEnvelope = {
    parameterPath: "functionEnvelope",
    mapper: FunctionEnvelope,
};
const key = {
    parameterPath: "key",
    mapper: KeyInfo,
};
const keyName = {
    parameterPath: "keyName",
    mapper: {
        serializedName: "keyName",
        required: true,
        xmlName: "keyName",
        type: {
            name: "String",
        },
    },
};
const keyType = {
    parameterPath: "keyType",
    mapper: {
        serializedName: "keyType",
        required: true,
        xmlName: "keyType",
        type: {
            name: "String",
        },
    },
};
const hostName1 = {
    parameterPath: "hostName",
    mapper: {
        serializedName: "hostName",
        required: true,
        xmlName: "hostName",
        type: {
            name: "String",
        },
    },
};
const hostNameBinding = {
    parameterPath: "hostNameBinding",
    mapper: HostNameBinding,
};
const connectionEnvelope1 = {
    parameterPath: "connectionEnvelope",
    mapper: HybridConnection,
};
const entityName = {
    parameterPath: "entityName",
    mapper: {
        serializedName: "entityName",
        required: true,
        xmlName: "entityName",
        type: {
            name: "String",
        },
    },
};
const connectionEnvelope2 = {
    parameterPath: "connectionEnvelope",
    mapper: RelayServiceConnectionEntity,
};
const instanceId = {
    parameterPath: "instanceId",
    mapper: {
        serializedName: "instanceId",
        required: true,
        xmlName: "instanceId",
        type: {
            name: "String",
        },
    },
};
const processId = {
    parameterPath: "processId",
    mapper: {
        serializedName: "processId",
        required: true,
        xmlName: "processId",
        type: {
            name: "String",
        },
    },
};
const baseAddress = {
    parameterPath: "baseAddress",
    mapper: {
        serializedName: "baseAddress",
        required: true,
        xmlName: "baseAddress",
        type: {
            name: "String",
        },
    },
};
const migrationOptions = {
    parameterPath: "migrationOptions",
    mapper: StorageMigrationOptions,
};
const subscriptionName = {
    parameterPath: "subscriptionName",
    mapper: {
        serializedName: "subscriptionName",
        required: true,
        xmlName: "subscriptionName",
        type: {
            name: "String",
        },
    },
};
const migrationRequestEnvelope = {
    parameterPath: "migrationRequestEnvelope",
    mapper: MigrateMySqlRequest,
};
const connectionEnvelope3 = {
    parameterPath: "connectionEnvelope",
    mapper: SwiftVirtualNetwork,
};
const view = {
    parameterPath: "view",
    mapper: {
        serializedName: "view",
        required: true,
        xmlName: "view",
        type: {
            name: "String",
        },
    },
};
const durationInSeconds = {
    parameterPath: ["options", "durationInSeconds"],
    mapper: {
        serializedName: "durationInSeconds",
        xmlName: "durationInSeconds",
        type: {
            name: "Number",
        },
    },
};
const maxFrameLength = {
    parameterPath: ["options", "maxFrameLength"],
    mapper: {
        serializedName: "maxFrameLength",
        xmlName: "maxFrameLength",
        type: {
            name: "Number",
        },
    },
};
const sasUrl = {
    parameterPath: ["options", "sasUrl"],
    mapper: {
        serializedName: "sasUrl",
        xmlName: "sasUrl",
        type: {
            name: "String",
        },
    },
};
const premierAddOnName = {
    parameterPath: "premierAddOnName",
    mapper: {
        serializedName: "premierAddOnName",
        required: true,
        xmlName: "premierAddOnName",
        type: {
            name: "String",
        },
    },
};
const premierAddOn = {
    parameterPath: "premierAddOn",
    mapper: PremierAddOn,
};
const premierAddOn1 = {
    parameterPath: "premierAddOn",
    mapper: PremierAddOnPatchResource,
};
const access = {
    parameterPath: "access",
    mapper: PrivateAccess,
};
const publicCertificateName = {
    parameterPath: "publicCertificateName",
    mapper: {
        serializedName: "publicCertificateName",
        required: true,
        xmlName: "publicCertificateName",
        type: {
            name: "String",
        },
    },
};
const publicCertificate = {
    parameterPath: "publicCertificate",
    mapper: PublicCertificate,
};
const publishingProfileOptions = {
    parameterPath: "publishingProfileOptions",
    mapper: CsmPublishingProfileOptions,
};
const accept3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const synchronous = {
    parameterPath: ["options", "synchronous"],
    mapper: {
        serializedName: "synchronous",
        xmlName: "synchronous",
        type: {
            name: "Boolean",
        },
    },
};
const restoreRequest = {
    parameterPath: "restoreRequest",
    mapper: DeletedAppRestoreRequest,
};
const restoreRequest1 = {
    parameterPath: "restoreRequest",
    mapper: SnapshotRestoreRequest,
};
const containerName = {
    parameterPath: "containerName",
    mapper: {
        constraints: {
            Pattern: new RegExp("(^[a-zA-Z0-9]$)|(^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$)"),
        },
        serializedName: "containerName",
        required: true,
        xmlName: "containerName",
        type: {
            name: "String",
        },
    },
};
const request3 = {
    parameterPath: "request",
    mapper: SiteContainer,
};
const siteExtensionId = {
    parameterPath: "siteExtensionId",
    mapper: {
        serializedName: "siteExtensionId",
        required: true,
        xmlName: "siteExtensionId",
        type: {
            name: "String",
        },
    },
};
const siteSourceControl = {
    parameterPath: "siteSourceControl",
    mapper: SiteSourceControl,
};
const additionalFlags = {
    parameterPath: ["options", "additionalFlags"],
    mapper: {
        serializedName: "additionalFlags",
        xmlName: "additionalFlags",
        type: {
            name: "String",
        },
    },
};
const connectionEnvelope4 = {
    parameterPath: "connectionEnvelope",
    mapper: VnetInfoResource,
};
const workflowArtifacts = {
    parameterPath: ["options", "workflowArtifacts"],
    mapper: WorkflowArtifacts,
};
const workflowName = {
    parameterPath: "workflowName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-z][a-z0-9]*$"),
            MaxLength: 63,
            MinLength: 3,
        },
        serializedName: "workflowName",
        required: true,
        xmlName: "workflowName",
        type: {
            name: "String",
        },
    },
};
const keyType1 = {
    parameterPath: "keyType",
    mapper: RegenerateActionParameter,
};
const workflowName1 = {
    parameterPath: "workflowName",
    mapper: {
        serializedName: "workflowName",
        required: true,
        xmlName: "workflowName",
        type: {
            name: "String",
        },
    },
};
const validate = {
    parameterPath: "validate",
    mapper: Workflow,
};
const top1 = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        xmlName: "$top",
        type: {
            name: "Number",
        },
    },
};
const filter1 = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        xmlName: "$filter",
        type: {
            name: "String",
        },
    },
};
const runName = {
    parameterPath: "runName",
    mapper: {
        serializedName: "runName",
        required: true,
        xmlName: "runName",
        type: {
            name: "String",
        },
    },
};
const actionName = {
    parameterPath: "actionName",
    mapper: {
        serializedName: "actionName",
        required: true,
        xmlName: "actionName",
        type: {
            name: "String",
        },
    },
};
const repetitionName = {
    parameterPath: "repetitionName",
    mapper: {
        serializedName: "repetitionName",
        required: true,
        xmlName: "repetitionName",
        type: {
            name: "String",
        },
    },
};
const requestHistoryName = {
    parameterPath: "requestHistoryName",
    mapper: {
        serializedName: "requestHistoryName",
        required: true,
        xmlName: "requestHistoryName",
        type: {
            name: "String",
        },
    },
};
const triggerName = {
    parameterPath: "triggerName",
    mapper: {
        serializedName: "triggerName",
        required: true,
        xmlName: "triggerName",
        type: {
            name: "String",
        },
    },
};
const historyName = {
    parameterPath: "historyName",
    mapper: {
        serializedName: "historyName",
        required: true,
        xmlName: "historyName",
        type: {
            name: "String",
        },
    },
};
const versionId = {
    parameterPath: "versionId",
    mapper: {
        serializedName: "versionId",
        required: true,
        xmlName: "versionId",
        type: {
            name: "String",
        },
    },
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        },
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AppServiceCertificateOrders operations. */
class AppServiceCertificateOrdersImpl {
    /**
     * Initialize a new instance of the class AppServiceCertificateOrders class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for List all certificate orders in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get certificate orders in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for List all certificates associated with a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    listCertificates(resourceGroupName, certificateOrderName, options) {
        const iter = this.listCertificatesPagingAll(resourceGroupName, certificateOrderName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCertificatesPagingPage(resourceGroupName, certificateOrderName, options, settings);
            },
        };
    }
    listCertificatesPagingPage(resourceGroupName, certificateOrderName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listCertificatesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listCertificates(resourceGroupName, certificateOrderName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listCertificatesNext(resourceGroupName, certificateOrderName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listCertificatesPagingAll(resourceGroupName, certificateOrderName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCertificatesPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listCertificatesPagingPage(resourceGroupName, certificateOrderName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for List all certificate orders in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$j);
    }
    /**
     * Description for Validate information for a certificate order.
     * @param appServiceCertificateOrder Information for a certificate order.
     * @param options The options parameters.
     */
    validatePurchaseInformation(appServiceCertificateOrder, options) {
        return this.client.sendOperationRequest({ appServiceCertificateOrder, options }, validatePurchaseInformationOperationSpec);
    }
    /**
     * Description for Get certificate orders in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$8);
    }
    /**
     * Description for Get a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order..
     * @param options The options parameters.
     */
    get(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, getOperationSpec$g);
    }
    /**
     * Description for Create or update a certificate purchase order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param certificateDistinguishedName Distinguished name to use for the certificate order.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, certificateOrderName, certificateDistinguishedName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    certificateOrderName,
                    certificateDistinguishedName,
                    options,
                },
                spec: createOrUpdateOperationSpec$7,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update a certificate purchase order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param certificateDistinguishedName Distinguished name to use for the certificate order.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, certificateOrderName, certificateDistinguishedName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, certificateOrderName, certificateDistinguishedName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete an existing certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    delete(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, deleteOperationSpec$7);
    }
    /**
     * Description for Create or update a certificate purchase order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param certificateDistinguishedName Distinguished name to use for the certificate order.
     * @param options The options parameters.
     */
    update(resourceGroupName, certificateOrderName, certificateDistinguishedName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            certificateOrderName,
            certificateDistinguishedName,
            options,
        }, updateOperationSpec$6);
    }
    /**
     * Description for List all certificates associated with a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    _listCertificates(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, listCertificatesOperationSpec);
    }
    /**
     * Description for Get the certificate associated with a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param options The options parameters.
     */
    getCertificate(resourceGroupName, certificateOrderName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, name, options }, getCertificateOperationSpec);
    }
    /**
     * Description for Creates or updates a certificate and associates with key vault secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param keyVaultCertificate Key vault certificate resource Id.
     * @param options The options parameters.
     */
    beginCreateOrUpdateCertificate(resourceGroupName, certificateOrderName, name, keyVaultCertificate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    certificateOrderName,
                    name,
                    keyVaultCertificate,
                    options,
                },
                spec: createOrUpdateCertificateOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates or updates a certificate and associates with key vault secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param keyVaultCertificate Key vault certificate resource Id.
     * @param options The options parameters.
     */
    beginCreateOrUpdateCertificateAndWait(resourceGroupName, certificateOrderName, name, keyVaultCertificate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateCertificate(resourceGroupName, certificateOrderName, name, keyVaultCertificate, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete the certificate associated with a certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param options The options parameters.
     */
    deleteCertificate(resourceGroupName, certificateOrderName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, name, options }, deleteCertificateOperationSpec);
    }
    /**
     * Description for Creates or updates a certificate and associates with key vault secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param name Name of the certificate.
     * @param keyVaultCertificate Key vault certificate resource Id.
     * @param options The options parameters.
     */
    updateCertificate(resourceGroupName, certificateOrderName, name, keyVaultCertificate, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            certificateOrderName,
            name,
            keyVaultCertificate,
            options,
        }, updateCertificateOperationSpec);
    }
    /**
     * Description for Reissue an existing certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param reissueCertificateOrderRequest Parameters for the reissue.
     * @param options The options parameters.
     */
    reissue(resourceGroupName, certificateOrderName, reissueCertificateOrderRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            certificateOrderName,
            reissueCertificateOrderRequest,
            options,
        }, reissueOperationSpec);
    }
    /**
     * Description for Renew an existing certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param renewCertificateOrderRequest Renew parameters
     * @param options The options parameters.
     */
    renew(resourceGroupName, certificateOrderName, renewCertificateOrderRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            certificateOrderName,
            renewCertificateOrderRequest,
            options,
        }, renewOperationSpec$1);
    }
    /**
     * Description for Resend certificate email.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    resendEmail(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, resendEmailOperationSpec);
    }
    /**
     * Resend domain verification ownership email containing steps on how to verify a domain for a given
     * certificate order
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param nameIdentifier Email address
     * @param options The options parameters.
     */
    resendRequestEmails(resourceGroupName, certificateOrderName, nameIdentifier, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, nameIdentifier, options }, resendRequestEmailsOperationSpec);
    }
    /**
     * This method is used to obtain the site seal information for an issued certificate. A site seal is a
     * graphic that the certificate purchaser can embed on their web site to show their visitors
     * information about their SSL certificate. If a web site visitor clicks on the site seal image, a
     * pop-up page is displayed that contains detailed information about the SSL certificate. The site seal
     * token is used to link the site seal graphic image to the appropriate certificate details pop-up page
     * display when a user clicks on the site seal. The site seal images are expected to be static images
     * and hosted by the reseller, to minimize delays for customer page load times.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param siteSealRequest Site seal request.
     * @param options The options parameters.
     */
    retrieveSiteSeal(resourceGroupName, certificateOrderName, siteSealRequest, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, siteSealRequest, options }, retrieveSiteSealOperationSpec);
    }
    /**
     * Description for Verify domain ownership for this certificate order.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param options The options parameters.
     */
    verifyDomainOwnership(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, verifyDomainOwnershipOperationSpec);
    }
    /**
     * Description for Retrieve the list of certificate actions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate order.
     * @param options The options parameters.
     */
    retrieveCertificateActions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, retrieveCertificateActionsOperationSpec);
    }
    /**
     * Description for Retrieve email history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate order.
     * @param options The options parameters.
     */
    retrieveCertificateEmailHistory(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, retrieveCertificateEmailHistoryOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$j);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$8);
    }
    /**
     * ListCertificatesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName Name of the certificate order.
     * @param nextLink The nextLink from the previous successful call to the ListCertificates method.
     * @param options The options parameters.
     */
    _listCertificatesNext(resourceGroupName, certificateOrderName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, nextLink, options }, listCertificatesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$u = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.CertificateRegistration/certificateOrders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrderCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$u,
};
const validatePurchaseInformationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.CertificateRegistration/validateCertificateRegistrationInformation",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: appServiceCertificateOrder,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u,
};
const listByResourceGroupOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrderCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrder,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrder,
        },
        201: {
            bodyMapper: AppServiceCertificateOrder,
        },
        202: {
            bodyMapper: AppServiceCertificateOrder,
        },
        204: {
            bodyMapper: AppServiceCertificateOrder,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: certificateDistinguishedName,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u,
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrder,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: certificateDistinguishedName1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u,
};
const listCertificatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const getCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const createOrUpdateCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateResource,
        },
        201: {
            bodyMapper: AppServiceCertificateResource,
        },
        202: {
            bodyMapper: AppServiceCertificateResource,
        },
        204: {
            bodyMapper: AppServiceCertificateResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: keyVaultCertificate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u,
};
const deleteCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const updateCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/certificates/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: keyVaultCertificate1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u,
};
const reissueOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/reissue",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: reissueCertificateOrderRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u,
};
const renewOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/renew",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: renewCertificateOrderRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u,
};
const resendEmailOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/resendEmail",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const resendRequestEmailsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/resendRequestEmails",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: nameIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u,
};
const retrieveSiteSealOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/retrieveSiteSeal",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteSeal,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteSealRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u,
};
const verifyDomainOwnershipOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/verifyDomainOwnership",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const retrieveCertificateActionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/retrieveCertificateActions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "CertificateOrderAction" },
                    },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const retrieveCertificateEmailHistoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{name}/retrieveEmailHistory",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "CertificateEmail" },
                    },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const listNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrderCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const listByResourceGroupNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateOrderCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};
const listCertificatesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceCertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$u,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CertificateOrdersDiagnostics operations. */
class CertificateOrdersDiagnosticsImpl {
    /**
     * Initialize a new instance of the class CertificateOrdersDiagnostics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Microsoft.CertificateRegistration to get the list of detectors for this RP.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName The certificate order name for which the response is needed.
     * @param options The options parameters.
     */
    listAppServiceCertificateOrderDetectorResponse(resourceGroupName, certificateOrderName, options) {
        const iter = this.listAppServiceCertificateOrderDetectorResponsePagingAll(resourceGroupName, certificateOrderName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAppServiceCertificateOrderDetectorResponsePagingPage(resourceGroupName, certificateOrderName, options, settings);
            },
        };
    }
    listAppServiceCertificateOrderDetectorResponsePagingPage(resourceGroupName, certificateOrderName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAppServiceCertificateOrderDetectorResponsePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAppServiceCertificateOrderDetectorResponse(resourceGroupName, certificateOrderName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAppServiceCertificateOrderDetectorResponseNext(resourceGroupName, certificateOrderName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAppServiceCertificateOrderDetectorResponsePagingAll(resourceGroupName, certificateOrderName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAppServiceCertificateOrderDetectorResponsePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listAppServiceCertificateOrderDetectorResponsePagingPage(resourceGroupName, certificateOrderName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Microsoft.CertificateRegistration to get the list of detectors for this RP.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName The certificate order name for which the response is needed.
     * @param options The options parameters.
     */
    _listAppServiceCertificateOrderDetectorResponse(resourceGroupName, certificateOrderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, options }, listAppServiceCertificateOrderDetectorResponseOperationSpec);
    }
    /**
     * Description for Microsoft.CertificateRegistration call to get a detector response from App Lens.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName The certificate order name for which the response is needed.
     * @param detectorName The detector name which needs to be run.
     * @param options The options parameters.
     */
    getAppServiceCertificateOrderDetectorResponse(resourceGroupName, certificateOrderName, detectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, detectorName, options }, getAppServiceCertificateOrderDetectorResponseOperationSpec);
    }
    /**
     * ListAppServiceCertificateOrderDetectorResponseNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param certificateOrderName The certificate order name for which the response is needed.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListAppServiceCertificateOrderDetectorResponse method.
     * @param options The options parameters.
     */
    _listAppServiceCertificateOrderDetectorResponseNext(resourceGroupName, certificateOrderName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, certificateOrderName, nextLink, options }, listAppServiceCertificateOrderDetectorResponseNextOperationSpec);
    }
}
// Operation Specifications
const serializer$t = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listAppServiceCertificateOrderDetectorResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
    ],
    headerParameters: [accept],
    serializer: serializer$t,
};
const getAppServiceCertificateOrderDetectorResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CertificateRegistration/certificateOrders/{certificateOrderName}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponse,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        detectorName,
    ],
    headerParameters: [accept],
    serializer: serializer$t,
};
const listAppServiceCertificateOrderDetectorResponseNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateOrderName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$t,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CertificateRegistrationProvider operations. */
class CertificateRegistrationProviderImpl {
    /**
     * Initialize a new instance of the class CertificateRegistrationProvider class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Implements Csm operations Api to exposes the list of available Csm Apis under the
     * resource provider
     * @param options The options parameters.
     */
    listOperations(options) {
        const iter = this.listOperationsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listOperationsPagingPage(options, settings);
            },
        };
    }
    listOperationsPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listOperations(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listOperationsNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listOperationsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listOperationsPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Implements Csm operations Api to exposes the list of available Csm Apis under the
     * resource provider
     * @param options The options parameters.
     */
    _listOperations(options) {
        return this.client.sendOperationRequest({ options }, listOperationsOperationSpec$3);
    }
    /**
     * ListOperationsNext
     * @param nextLink The nextLink from the previous successful call to the ListOperations method.
     * @param options The options parameters.
     */
    _listOperationsNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listOperationsNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$s = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationsOperationSpec$3 = {
    path: "/providers/Microsoft.CertificateRegistration/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$s,
};
const listOperationsNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$s,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Domains operations. */
class DomainsImpl {
    /**
     * Initialize a new instance of the class Domains class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all domains in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get domain name recommendations based on keywords.
     * @param parameters Search parameters for domain name recommendations.
     * @param options The options parameters.
     */
    listRecommendations(parameters, options) {
        const iter = this.listRecommendationsPagingAll(parameters, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRecommendationsPagingPage(parameters, options, settings);
            },
        };
    }
    listRecommendationsPagingPage(parameters, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendationsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRecommendations(parameters, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRecommendationsNext(parameters, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRecommendationsPagingAll(parameters, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendationsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listRecommendationsPagingPage(parameters, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all domains in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Lists domain ownership identifiers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param options The options parameters.
     */
    listOwnershipIdentifiers(resourceGroupName, domainName, options) {
        const iter = this.listOwnershipIdentifiersPagingAll(resourceGroupName, domainName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listOwnershipIdentifiersPagingPage(resourceGroupName, domainName, options, settings);
            },
        };
    }
    listOwnershipIdentifiersPagingPage(resourceGroupName, domainName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listOwnershipIdentifiersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listOwnershipIdentifiers(resourceGroupName, domainName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listOwnershipIdentifiersNext(resourceGroupName, domainName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listOwnershipIdentifiersPagingAll(resourceGroupName, domainName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listOwnershipIdentifiersPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listOwnershipIdentifiersPagingPage(resourceGroupName, domainName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Check if a domain is available for registration.
     * @param identifier Name of the domain.
     * @param options The options parameters.
     */
    checkAvailability(identifier, options) {
        return this.client.sendOperationRequest({ identifier, options }, checkAvailabilityOperationSpec);
    }
    /**
     * Description for Get all domains in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$i);
    }
    /**
     * Description for Generate a single sign-on request for the domain management portal.
     * @param options The options parameters.
     */
    getControlCenterSsoRequest(options) {
        return this.client.sendOperationRequest({ options }, getControlCenterSsoRequestOperationSpec);
    }
    /**
     * Description for Get domain name recommendations based on keywords.
     * @param parameters Search parameters for domain name recommendations.
     * @param options The options parameters.
     */
    _listRecommendations(parameters, options) {
        return this.client.sendOperationRequest({ parameters, options }, listRecommendationsOperationSpec);
    }
    /**
     * Description for Get all domains in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$7);
    }
    /**
     * Description for Get a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    get(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, getOperationSpec$f);
    }
    /**
     * Description for Creates or updates a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param domain Domain registration information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, domainName, domain, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, domainName, domain, options },
                spec: createOrUpdateOperationSpec$6,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates or updates a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param domain Domain registration information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, domainName, domain, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, domainName, domain, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    delete(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, deleteOperationSpec$6);
    }
    /**
     * Description for Creates or updates a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param domain Domain registration information.
     * @param options The options parameters.
     */
    update(resourceGroupName, domainName, domain, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, domain, options }, updateOperationSpec$5);
    }
    /**
     * Description for Lists domain ownership identifiers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param options The options parameters.
     */
    _listOwnershipIdentifiers(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, listOwnershipIdentifiersOperationSpec);
    }
    /**
     * Description for Get ownership identifier for domain
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param name Name of identifier.
     * @param options The options parameters.
     */
    getOwnershipIdentifier(resourceGroupName, domainName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, name, options }, getOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Creates an ownership identifier for a domain or updates identifier details for an
     * existing identifier
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param name Name of identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    createOrUpdateOwnershipIdentifier(resourceGroupName, domainName, name, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            domainName,
            name,
            domainOwnershipIdentifier,
            options,
        }, createOrUpdateOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Delete ownership identifier for domain
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param name Name of identifier.
     * @param options The options parameters.
     */
    deleteOwnershipIdentifier(resourceGroupName, domainName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, name, options }, deleteOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Creates an ownership identifier for a domain or updates identifier details for an
     * existing identifier
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param name Name of identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    updateOwnershipIdentifier(resourceGroupName, domainName, name, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            domainName,
            name,
            domainOwnershipIdentifier,
            options,
        }, updateOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Renew a domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    renew(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, renewOperationSpec);
    }
    /**
     * Transfer out domain to another registrar
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param options The options parameters.
     */
    transferOut(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, transferOutOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$i);
    }
    /**
     * ListRecommendationsNext
     * @param parameters Search parameters for domain name recommendations.
     * @param nextLink The nextLink from the previous successful call to the ListRecommendations method.
     * @param options The options parameters.
     */
    _listRecommendationsNext(parameters, nextLink, options) {
        return this.client.sendOperationRequest({ parameters, nextLink, options }, listRecommendationsNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$7);
    }
    /**
     * ListOwnershipIdentifiersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param domainName Name of domain.
     * @param nextLink The nextLink from the previous successful call to the ListOwnershipIdentifiers
     *                 method.
     * @param options The options parameters.
     */
    _listOwnershipIdentifiersNext(resourceGroupName, domainName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, nextLink, options }, listOwnershipIdentifiersNextOperationSpec);
    }
}
// Operation Specifications
const serializer$r = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/checkDomainAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DomainAvailabilityCheckResult,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: identifier,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r,
};
const listOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/domains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$r,
};
const getControlCenterSsoRequestOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/generateSsoRequest",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DomainControlCenterSsoRequest,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$r,
};
const listRecommendationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/listDomainRecommendations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NameIdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r,
};
const listByResourceGroupOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Domain,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Domain,
        },
        201: {
            bodyMapper: Domain,
        },
        202: {
            bodyMapper: Domain,
        },
        204: {
            bodyMapper: Domain,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: domain,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName1,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r,
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, forceHardDeleteDomain],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Domain,
        },
        202: {
            bodyMapper: Domain,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: domain1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName1,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r,
};
const listOwnershipIdentifiersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const getOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifier,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const createOrUpdateOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifier,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: domainOwnershipIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r,
};
const deleteOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const updateOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/domainOwnershipIdentifiers/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifier,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: domainOwnershipIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r,
};
const renewOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/renew",
    httpMethod: "POST",
    responses: {
        200: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const transferOutOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DomainRegistration/domains/{domainName}/transferOut",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Domain,
        },
        400: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const listNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const listRecommendationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NameIdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r,
};
const listByResourceGroupNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};
const listOwnershipIdentifiersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainOwnershipIdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$r,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TopLevelDomains operations. */
class TopLevelDomainsImpl {
    /**
     * Initialize a new instance of the class TopLevelDomains class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all top-level domains supported for registration.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Gets all legal agreements that user needs to accept before purchasing a domain.
     * @param name Name of the top-level domain.
     * @param agreementOption Domain agreement options.
     * @param options The options parameters.
     */
    listAgreements(name, agreementOption, options) {
        const iter = this.listAgreementsPagingAll(name, agreementOption, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAgreementsPagingPage(name, agreementOption, options, settings);
            },
        };
    }
    listAgreementsPagingPage(name, agreementOption, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAgreementsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAgreements(name, agreementOption, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAgreementsNext(name, agreementOption, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAgreementsPagingAll(name, agreementOption, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAgreementsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listAgreementsPagingPage(name, agreementOption, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all top-level domains supported for registration.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$h);
    }
    /**
     * Description for Get details of a top-level domain.
     * @param name Name of the top-level domain.
     * @param options The options parameters.
     */
    get(name, options) {
        return this.client.sendOperationRequest({ name, options }, getOperationSpec$e);
    }
    /**
     * Description for Gets all legal agreements that user needs to accept before purchasing a domain.
     * @param name Name of the top-level domain.
     * @param agreementOption Domain agreement options.
     * @param options The options parameters.
     */
    _listAgreements(name, agreementOption, options) {
        return this.client.sendOperationRequest({ name, agreementOption, options }, listAgreementsOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$h);
    }
    /**
     * ListAgreementsNext
     * @param name Name of the top-level domain.
     * @param agreementOption Domain agreement options.
     * @param nextLink The nextLink from the previous successful call to the ListAgreements method.
     * @param options The options parameters.
     */
    _listAgreementsNext(name, agreementOption, nextLink, options) {
        return this.client.sendOperationRequest({ name, agreementOption, nextLink, options }, listAgreementsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/topLevelDomains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopLevelDomainCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$q,
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/topLevelDomains/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopLevelDomain,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId, name],
    headerParameters: [accept],
    serializer: serializer$q,
};
const listAgreementsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DomainRegistration/topLevelDomains/{name}/listAgreements",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TldLegalAgreementCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: agreementOption,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId, name],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q,
};
const listNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopLevelDomainCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$q,
};
const listAgreementsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TldLegalAgreementCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        name,
        nextLink,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DomainRegistrationProvider operations. */
class DomainRegistrationProviderImpl {
    /**
     * Initialize a new instance of the class DomainRegistrationProvider class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Implements Csm operations Api to exposes the list of available Csm Apis under the
     * resource provider
     * @param options The options parameters.
     */
    listOperations(options) {
        const iter = this.listOperationsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listOperationsPagingPage(options, settings);
            },
        };
    }
    listOperationsPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listOperations(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listOperationsNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listOperationsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listOperationsPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Implements Csm operations Api to exposes the list of available Csm Apis under the
     * resource provider
     * @param options The options parameters.
     */
    _listOperations(options) {
        return this.client.sendOperationRequest({ options }, listOperationsOperationSpec$2);
    }
    /**
     * ListOperationsNext
     * @param nextLink The nextLink from the previous successful call to the ListOperations method.
     * @param options The options parameters.
     */
    _listOperationsNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listOperationsNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationsOperationSpec$2 = {
    path: "/providers/Microsoft.DomainRegistration/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$p,
};
const listOperationsNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$p,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AppServiceEnvironments operations. */
class AppServiceEnvironmentsImpl {
    /**
     * Initialize a new instance of the class AppServiceEnvironments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all App Service Environments for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all App Service Environments in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get the used, available, and total worker capacity an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listCapacities(resourceGroupName, name, options) {
        const iter = this.listCapacitiesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCapacitiesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listCapacitiesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listCapacitiesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listCapacities(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listCapacitiesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listCapacitiesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCapacitiesPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listCapacitiesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Move an App Service Environment to a different VNET.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param vnetInfo Details for the new virtual network.
     * @param options The options parameters.
     */
    beginListChangeVnetAndWait(resourceGroupName, name, vnetInfo, options) {
        const iter = this.changeVnetPagingAll(resourceGroupName, name, vnetInfo, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.changeVnetPagingPage(resourceGroupName, name, vnetInfo, options, settings);
            },
        };
    }
    changeVnetPagingPage(resourceGroupName, name, vnetInfo, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* changeVnetPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield tslib.__await(this._changeVnet(resourceGroupName, name, vnetInfo, options));
                result = yield tslib.__await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._changeVnetNext(resourceGroupName, name, vnetInfo, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    changeVnetPagingAll(resourceGroupName, name, vnetInfo, options) {
        return tslib.__asyncGenerator(this, arguments, function* changeVnetPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.changeVnetPagingPage(resourceGroupName, name, vnetInfo, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get the network endpoints of all inbound dependencies of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listInboundNetworkDependenciesEndpoints(resourceGroupName, name, options) {
        const iter = this.getInboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getInboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getInboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getInboundNetworkDependenciesEndpointsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getInboundNetworkDependenciesEndpoints(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getInboundNetworkDependenciesEndpointsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getInboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getInboundNetworkDependenciesEndpointsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getInboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Get all multi-role pools.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listMultiRolePools(resourceGroupName, name, options) {
        const iter = this.listMultiRolePoolsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMultiRolePoolsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listMultiRolePoolsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listMultiRolePools(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRolePoolsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listMultiRolePoolsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolsPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMultiRolePoolsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Get metric definitions for a specific instance of a multi-role pool of an App
     * Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param instance Name of the instance in the multi-role pool.
     * @param options The options parameters.
     */
    listMultiRolePoolInstanceMetricDefinitions(resourceGroupName, name, instance, options) {
        const iter = this.listMultiRolePoolInstanceMetricDefinitionsPagingAll(resourceGroupName, name, instance, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMultiRolePoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, instance, options, settings);
            },
        };
    }
    listMultiRolePoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, instance, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolInstanceMetricDefinitionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listMultiRolePoolInstanceMetricDefinitions(resourceGroupName, name, instance, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRolePoolInstanceMetricDefinitionsNext(resourceGroupName, name, instance, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listMultiRolePoolInstanceMetricDefinitionsPagingAll(resourceGroupName, name, instance, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolInstanceMetricDefinitionsPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMultiRolePoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, instance, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Get metric definitions for a multi-role pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listMultiRoleMetricDefinitions(resourceGroupName, name, options) {
        const iter = this.listMultiRoleMetricDefinitionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMultiRoleMetricDefinitionsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listMultiRoleMetricDefinitionsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRoleMetricDefinitionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listMultiRoleMetricDefinitions(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRoleMetricDefinitionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listMultiRoleMetricDefinitionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRoleMetricDefinitionsPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMultiRoleMetricDefinitionsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Description for Get available SKUs for scaling a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listMultiRolePoolSkus(resourceGroupName, name, options) {
        const iter = this.listMultiRolePoolSkusPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMultiRolePoolSkusPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listMultiRolePoolSkusPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolSkusPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listMultiRolePoolSkus(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRolePoolSkusNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listMultiRolePoolSkusPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRolePoolSkusPagingAll_1() {
            var _a, e_9, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMultiRolePoolSkusPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * Description for Get usage metrics for a multi-role pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listMultiRoleUsages(resourceGroupName, name, options) {
        const iter = this.listMultiRoleUsagesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMultiRoleUsagesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listMultiRoleUsagesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRoleUsagesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listMultiRoleUsages(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listMultiRoleUsagesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listMultiRoleUsagesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultiRoleUsagesPagingAll_1() {
            var _a, e_10, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMultiRoleUsagesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
    }
    /**
     * Description for Get the network endpoints of all outbound dependencies of an App Service
     * Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listOutboundNetworkDependenciesEndpoints(resourceGroupName, name, options) {
        const iter = this.getOutboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getOutboundNetworkDependenciesEndpointsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getOutboundNetworkDependenciesEndpoints(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getOutboundNetworkDependenciesEndpointsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getOutboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getOutboundNetworkDependenciesEndpointsPagingAll_1() {
            var _a, e_11, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_11) throw e_11.error; }
            }
        });
    }
    /**
     * Description for Gets the list of private endpoints associated with a hosting environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listPrivateEndpointConnectionList(resourceGroupName, name, options) {
        const iter = this.getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionList(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionListNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingAll_1() {
            var _a, e_12, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_12) throw e_12.error; }
            }
        });
    }
    /**
     * Description for Resume an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginListResumeAndWait(resourceGroupName, name, options) {
        const iter = this.resumePagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.resumePagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    resumePagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* resumePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield tslib.__await(this._resume(resourceGroupName, name, options));
                result = yield tslib.__await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._resumeNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    resumePagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* resumePagingAll_1() {
            var _a, e_13, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.resumePagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_13) throw e_13.error; }
            }
        });
    }
    /**
     * Description for Get all App Service plans in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listAppServicePlans(resourceGroupName, name, options) {
        const iter = this.listAppServicePlansPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAppServicePlansPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listAppServicePlansPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAppServicePlansPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAppServicePlans(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAppServicePlansNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAppServicePlansPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAppServicePlansPagingAll_1() {
            var _a, e_14, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listAppServicePlansPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_14) throw e_14.error; }
            }
        });
    }
    /**
     * Description for Get all apps in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listWebApps(resourceGroupName, name, options) {
        const iter = this.listWebAppsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWebAppsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listWebAppsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWebApps(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWebAppsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWebAppsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsPagingAll_1() {
            var _a, e_15, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWebAppsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_15) throw e_15.error; }
            }
        });
    }
    /**
     * Description for Suspend an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginListSuspendAndWait(resourceGroupName, name, options) {
        const iter = this.suspendPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.suspendPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    suspendPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* suspendPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield tslib.__await(this._suspend(resourceGroupName, name, options));
                result = yield tslib.__await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._suspendNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    suspendPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* suspendPagingAll_1() {
            var _a, e_16, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.suspendPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_16) throw e_16.error; }
            }
        });
    }
    /**
     * Description for Get global usage metrics of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, name, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listUsagesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listUsagesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listUsages(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listUsagesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listUsagesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var _a, e_17, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_17) throw e_17.error; }
            }
        });
    }
    /**
     * Description for Get all worker pools of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listWorkerPools(resourceGroupName, name, options) {
        const iter = this.listWorkerPoolsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWorkerPoolsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listWorkerPoolsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWorkerPools(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWorkerPoolsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWorkerPoolsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolsPagingAll_1() {
            var _a, e_18, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWorkerPoolsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_18) throw e_18.error; }
            }
        });
    }
    /**
     * Description for Get metric definitions for a specific instance of a worker pool of an App Service
     * Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param instance Name of the instance in the worker pool.
     * @param options The options parameters.
     */
    listWorkerPoolInstanceMetricDefinitions(resourceGroupName, name, workerPoolName, instance, options) {
        const iter = this.listWorkerPoolInstanceMetricDefinitionsPagingAll(resourceGroupName, name, workerPoolName, instance, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWorkerPoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, instance, options, settings);
            },
        };
    }
    listWorkerPoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, instance, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolInstanceMetricDefinitionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWorkerPoolInstanceMetricDefinitions(resourceGroupName, name, workerPoolName, instance, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWorkerPoolInstanceMetricDefinitionsNext(resourceGroupName, name, workerPoolName, instance, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWorkerPoolInstanceMetricDefinitionsPagingAll(resourceGroupName, name, workerPoolName, instance, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolInstanceMetricDefinitionsPagingAll_1() {
            var _a, e_19, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWorkerPoolInstanceMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, instance, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_19_1) { e_19 = { error: e_19_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_19) throw e_19.error; }
            }
        });
    }
    /**
     * Description for Get metric definitions for a worker pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    listWebWorkerMetricDefinitions(resourceGroupName, name, workerPoolName, options) {
        const iter = this.listWebWorkerMetricDefinitionsPagingAll(resourceGroupName, name, workerPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWebWorkerMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, options, settings);
            },
        };
    }
    listWebWorkerMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWebWorkerMetricDefinitionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWebWorkerMetricDefinitions(resourceGroupName, name, workerPoolName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWebWorkerMetricDefinitionsNext(resourceGroupName, name, workerPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWebWorkerMetricDefinitionsPagingAll(resourceGroupName, name, workerPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebWorkerMetricDefinitionsPagingAll_1() {
            var _a, e_20, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWebWorkerMetricDefinitionsPagingPage(resourceGroupName, name, workerPoolName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_20_1) { e_20 = { error: e_20_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_20) throw e_20.error; }
            }
        });
    }
    /**
     * Description for Get available SKUs for scaling a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    listWorkerPoolSkus(resourceGroupName, name, workerPoolName, options) {
        const iter = this.listWorkerPoolSkusPagingAll(resourceGroupName, name, workerPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWorkerPoolSkusPagingPage(resourceGroupName, name, workerPoolName, options, settings);
            },
        };
    }
    listWorkerPoolSkusPagingPage(resourceGroupName, name, workerPoolName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolSkusPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWorkerPoolSkus(resourceGroupName, name, workerPoolName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWorkerPoolSkusNext(resourceGroupName, name, workerPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWorkerPoolSkusPagingAll(resourceGroupName, name, workerPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkerPoolSkusPagingAll_1() {
            var _a, e_21, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWorkerPoolSkusPagingPage(resourceGroupName, name, workerPoolName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_21_1) { e_21 = { error: e_21_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_21) throw e_21.error; }
            }
        });
    }
    /**
     * Description for Get usage metrics for a worker pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    listWebWorkerUsages(resourceGroupName, name, workerPoolName, options) {
        const iter = this.listWebWorkerUsagesPagingAll(resourceGroupName, name, workerPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWebWorkerUsagesPagingPage(resourceGroupName, name, workerPoolName, options, settings);
            },
        };
    }
    listWebWorkerUsagesPagingPage(resourceGroupName, name, workerPoolName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWebWorkerUsagesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWebWorkerUsages(resourceGroupName, name, workerPoolName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWebWorkerUsagesNext(resourceGroupName, name, workerPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWebWorkerUsagesPagingAll(resourceGroupName, name, workerPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebWorkerUsagesPagingAll_1() {
            var _a, e_22, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWebWorkerUsagesPagingPage(resourceGroupName, name, workerPoolName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_22_1) { e_22 = { error: e_22_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_22) throw e_22.error; }
            }
        });
    }
    /**
     * Description for Get all App Service Environments for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$g);
    }
    /**
     * Description for Get all App Service Environments in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$6);
    }
    /**
     * Description for Get the properties of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$d);
    }
    /**
     * Description for Create or update an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param hostingEnvironmentEnvelope Configuration details of the App Service Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, hostingEnvironmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, hostingEnvironmentEnvelope, options },
                spec: createOrUpdateOperationSpec$5,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param hostingEnvironmentEnvelope Configuration details of the App Service Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, hostingEnvironmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, hostingEnvironmentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: deleteOperationSpec$5,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Delete an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Create or update an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param hostingEnvironmentEnvelope Configuration details of the App Service Environment.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, hostingEnvironmentEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostingEnvironmentEnvelope, options }, updateOperationSpec$4);
    }
    /**
     * Description for Get the used, available, and total worker capacity an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listCapacities(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listCapacitiesOperationSpec);
    }
    /**
     * Description for Get IP addresses assigned to an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getVipInfo(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getVipInfoOperationSpec);
    }
    /**
     * Description for Move an App Service Environment to a different VNET.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param vnetInfo Details for the new virtual network.
     * @param options The options parameters.
     */
    _changeVnet(resourceGroupName, name, vnetInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, vnetInfo, options },
                spec: changeVnetOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Get Custom Dns Suffix configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getAseCustomDnsSuffixConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAseCustomDnsSuffixConfigurationOperationSpec);
    }
    /**
     * Update Custom Dns Suffix configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param customDnsSuffixConfiguration Full view of the custom domain suffix configuration for ASEv3.
     * @param options The options parameters.
     */
    updateAseCustomDnsSuffixConfiguration(resourceGroupName, name, customDnsSuffixConfiguration, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, customDnsSuffixConfiguration, options }, updateAseCustomDnsSuffixConfigurationOperationSpec);
    }
    /**
     * Delete Custom Dns Suffix configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    deleteAseCustomDnsSuffixConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteAseCustomDnsSuffixConfigurationOperationSpec);
    }
    /**
     * Description for Get networking configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getAseV3NetworkingConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAseV3NetworkingConfigurationOperationSpec);
    }
    /**
     * Description for Update networking configuration of an App Service Environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param aseNetworkingConfiguration Full view of networking configuration for an ASE.
     * @param options The options parameters.
     */
    updateAseNetworkingConfiguration(resourceGroupName, name, aseNetworkingConfiguration, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, aseNetworkingConfiguration, options }, updateAseNetworkingConfigurationOperationSpec);
    }
    /**
     * Description for Get diagnostic information for an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listDiagnostics(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listDiagnosticsOperationSpec);
    }
    /**
     * Description for Get a diagnostics item for an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param diagnosticsName Name of the diagnostics item.
     * @param options The options parameters.
     */
    getDiagnosticsItem(resourceGroupName, name, diagnosticsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, diagnosticsName, options }, getDiagnosticsItemOperationSpec);
    }
    /**
     * Description for Get the network endpoints of all inbound dependencies of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _getInboundNetworkDependenciesEndpoints(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getInboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * Description for Get all multi-role pools.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listMultiRolePools(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMultiRolePoolsOperationSpec);
    }
    /**
     * Description for Get properties of a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getMultiRolePool(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getMultiRolePoolOperationSpec);
    }
    /**
     * Description for Create or update a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param multiRolePoolEnvelope Properties of the multi-role pool.
     * @param options The options parameters.
     */
    beginCreateOrUpdateMultiRolePool(resourceGroupName, name, multiRolePoolEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, multiRolePoolEnvelope, options },
                spec: createOrUpdateMultiRolePoolOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param multiRolePoolEnvelope Properties of the multi-role pool.
     * @param options The options parameters.
     */
    beginCreateOrUpdateMultiRolePoolAndWait(resourceGroupName, name, multiRolePoolEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateMultiRolePool(resourceGroupName, name, multiRolePoolEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Create or update a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param multiRolePoolEnvelope Properties of the multi-role pool.
     * @param options The options parameters.
     */
    updateMultiRolePool(resourceGroupName, name, multiRolePoolEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, multiRolePoolEnvelope, options }, updateMultiRolePoolOperationSpec);
    }
    /**
     * Description for Get metric definitions for a specific instance of a multi-role pool of an App
     * Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param instance Name of the instance in the multi-role pool.
     * @param options The options parameters.
     */
    _listMultiRolePoolInstanceMetricDefinitions(resourceGroupName, name, instance, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instance, options }, listMultiRolePoolInstanceMetricDefinitionsOperationSpec);
    }
    /**
     * Description for Get metric definitions for a multi-role pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listMultiRoleMetricDefinitions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMultiRoleMetricDefinitionsOperationSpec);
    }
    /**
     * Description for Get available SKUs for scaling a multi-role pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listMultiRolePoolSkus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMultiRolePoolSkusOperationSpec);
    }
    /**
     * Send a test notification that an upgrade is available for this App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    testUpgradeAvailableNotification(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, testUpgradeAvailableNotificationOperationSpec);
    }
    /**
     * Description for Initiate an upgrade of an App Service Environment if one is available.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginUpgrade(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: upgradeOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Initiate an upgrade of an App Service Environment if one is available.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    beginUpgradeAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpgrade(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get usage metrics for a multi-role pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listMultiRoleUsages(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMultiRoleUsagesOperationSpec);
    }
    /**
     * Description for List all currently running operations on the App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    listOperations(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listOperationsOperationSpec$1);
    }
    /**
     * Description for Get the network endpoints of all outbound dependencies of an App Service
     * Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _getOutboundNetworkDependenciesEndpoints(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOutboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * Description for Gets the list of private endpoints associated with a hosting environment
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionList(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateEndpointConnectionListOperationSpec$2);
    }
    /**
     * Description for Gets a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    getPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, options }, getPrivateEndpointConnectionOperationSpec$2);
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName
     * @param privateEndpointWrapper Remote Private Endpoint Connection ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    privateEndpointConnectionName,
                    privateEndpointWrapper,
                    options,
                },
                spec: approveOrRejectPrivateEndpointConnectionOperationSpec$2,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName
     * @param privateEndpointWrapper Remote Private Endpoint Connection ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, privateEndpointConnectionName, options },
                spec: deletePrivateEndpointConnectionOperationSpec$2,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    getPrivateLinkResources(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateLinkResourcesOperationSpec$2);
    }
    /**
     * Description for Reboot all machines in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    reboot(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, rebootOperationSpec);
    }
    /**
     * Description for Resume an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _resume(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: resumeOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Get all App Service plans in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listAppServicePlans(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listAppServicePlansOperationSpec);
    }
    /**
     * Description for Get all apps in an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listWebApps(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWebAppsOperationSpec$1);
    }
    /**
     * Description for Suspend an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _suspend(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: suspendOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Get global usage metrics of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listUsagesOperationSpec$2);
    }
    /**
     * Description for Get all worker pools of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param options The options parameters.
     */
    _listWorkerPools(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWorkerPoolsOperationSpec);
    }
    /**
     * Description for Get properties of a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    getWorkerPool(resourceGroupName, name, workerPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, options }, getWorkerPoolOperationSpec);
    }
    /**
     * Description for Create or update a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param workerPoolEnvelope Properties of the worker pool.
     * @param options The options parameters.
     */
    beginCreateOrUpdateWorkerPool(resourceGroupName, name, workerPoolName, workerPoolEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    workerPoolName,
                    workerPoolEnvelope,
                    options,
                },
                spec: createOrUpdateWorkerPoolOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param workerPoolEnvelope Properties of the worker pool.
     * @param options The options parameters.
     */
    beginCreateOrUpdateWorkerPoolAndWait(resourceGroupName, name, workerPoolName, workerPoolEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateWorkerPool(resourceGroupName, name, workerPoolName, workerPoolEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Create or update a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param workerPoolEnvelope Properties of the worker pool.
     * @param options The options parameters.
     */
    updateWorkerPool(resourceGroupName, name, workerPoolName, workerPoolEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, workerPoolEnvelope, options }, updateWorkerPoolOperationSpec);
    }
    /**
     * Description for Get metric definitions for a specific instance of a worker pool of an App Service
     * Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param instance Name of the instance in the worker pool.
     * @param options The options parameters.
     */
    _listWorkerPoolInstanceMetricDefinitions(resourceGroupName, name, workerPoolName, instance, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, instance, options }, listWorkerPoolInstanceMetricDefinitionsOperationSpec);
    }
    /**
     * Description for Get metric definitions for a worker pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    _listWebWorkerMetricDefinitions(resourceGroupName, name, workerPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, options }, listWebWorkerMetricDefinitionsOperationSpec);
    }
    /**
     * Description for Get available SKUs for scaling a worker pool.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    _listWorkerPoolSkus(resourceGroupName, name, workerPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, options }, listWorkerPoolSkusOperationSpec);
    }
    /**
     * Description for Get usage metrics for a worker pool of an App Service Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param options The options parameters.
     */
    _listWebWorkerUsages(resourceGroupName, name, workerPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, options }, listWebWorkerUsagesOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$g);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$6);
    }
    /**
     * ListCapacitiesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListCapacities method.
     * @param options The options parameters.
     */
    _listCapacitiesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listCapacitiesNextOperationSpec);
    }
    /**
     * ChangeVnetNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param vnetInfo Details for the new virtual network.
     * @param nextLink The nextLink from the previous successful call to the ChangeVnet method.
     * @param options The options parameters.
     */
    _changeVnetNext(resourceGroupName, name, vnetInfo, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetInfo, nextLink, options }, changeVnetNextOperationSpec);
    }
    /**
     * GetInboundNetworkDependenciesEndpointsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetInboundNetworkDependenciesEndpoints method.
     * @param options The options parameters.
     */
    _getInboundNetworkDependenciesEndpointsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getInboundNetworkDependenciesEndpointsNextOperationSpec);
    }
    /**
     * ListMultiRolePoolsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListMultiRolePools method.
     * @param options The options parameters.
     */
    _listMultiRolePoolsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listMultiRolePoolsNextOperationSpec);
    }
    /**
     * ListMultiRolePoolInstanceMetricDefinitionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param instance Name of the instance in the multi-role pool.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListMultiRolePoolInstanceMetricDefinitions method.
     * @param options The options parameters.
     */
    _listMultiRolePoolInstanceMetricDefinitionsNext(resourceGroupName, name, instance, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instance, nextLink, options }, listMultiRolePoolInstanceMetricDefinitionsNextOperationSpec);
    }
    /**
     * ListMultiRoleMetricDefinitionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListMultiRoleMetricDefinitions
     *                 method.
     * @param options The options parameters.
     */
    _listMultiRoleMetricDefinitionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listMultiRoleMetricDefinitionsNextOperationSpec);
    }
    /**
     * ListMultiRolePoolSkusNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListMultiRolePoolSkus method.
     * @param options The options parameters.
     */
    _listMultiRolePoolSkusNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listMultiRolePoolSkusNextOperationSpec);
    }
    /**
     * ListMultiRoleUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListMultiRoleUsages method.
     * @param options The options parameters.
     */
    _listMultiRoleUsagesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listMultiRoleUsagesNextOperationSpec);
    }
    /**
     * GetOutboundNetworkDependenciesEndpointsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetOutboundNetworkDependenciesEndpoints method.
     * @param options The options parameters.
     */
    _getOutboundNetworkDependenciesEndpointsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getOutboundNetworkDependenciesEndpointsNextOperationSpec);
    }
    /**
     * GetPrivateEndpointConnectionListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetPrivateEndpointConnectionList method.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getPrivateEndpointConnectionListNextOperationSpec$2);
    }
    /**
     * ResumeNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the Resume method.
     * @param options The options parameters.
     */
    _resumeNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, resumeNextOperationSpec);
    }
    /**
     * ListAppServicePlansNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListAppServicePlans method.
     * @param options The options parameters.
     */
    _listAppServicePlansNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listAppServicePlansNextOperationSpec);
    }
    /**
     * ListWebAppsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListWebApps method.
     * @param options The options parameters.
     */
    _listWebAppsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listWebAppsNextOperationSpec$1);
    }
    /**
     * SuspendNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the Suspend method.
     * @param options The options parameters.
     */
    _suspendNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, suspendNextOperationSpec);
    }
    /**
     * ListUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListUsages method.
     * @param options The options parameters.
     */
    _listUsagesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listUsagesNextOperationSpec$2);
    }
    /**
     * ListWorkerPoolsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param nextLink The nextLink from the previous successful call to the ListWorkerPools method.
     * @param options The options parameters.
     */
    _listWorkerPoolsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listWorkerPoolsNextOperationSpec);
    }
    /**
     * ListWorkerPoolInstanceMetricDefinitionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param instance Name of the instance in the worker pool.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListWorkerPoolInstanceMetricDefinitions method.
     * @param options The options parameters.
     */
    _listWorkerPoolInstanceMetricDefinitionsNext(resourceGroupName, name, workerPoolName, instance, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, instance, nextLink, options }, listWorkerPoolInstanceMetricDefinitionsNextOperationSpec);
    }
    /**
     * ListWebWorkerMetricDefinitionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param nextLink The nextLink from the previous successful call to the ListWebWorkerMetricDefinitions
     *                 method.
     * @param options The options parameters.
     */
    _listWebWorkerMetricDefinitionsNext(resourceGroupName, name, workerPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, nextLink, options }, listWebWorkerMetricDefinitionsNextOperationSpec);
    }
    /**
     * ListWorkerPoolSkusNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param nextLink The nextLink from the previous successful call to the ListWorkerPoolSkus method.
     * @param options The options parameters.
     */
    _listWorkerPoolSkusNext(resourceGroupName, name, workerPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, nextLink, options }, listWorkerPoolSkusNextOperationSpec);
    }
    /**
     * ListWebWorkerUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service Environment.
     * @param workerPoolName Name of the worker pool.
     * @param nextLink The nextLink from the previous successful call to the ListWebWorkerUsages method.
     * @param options The options parameters.
     */
    _listWebWorkerUsagesNext(resourceGroupName, name, workerPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerPoolName, nextLink, options }, listWebWorkerUsagesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/hostingEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listByResourceGroupOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentResource,
        },
        201: {
            bodyMapper: AppServiceEnvironmentResource,
        },
        202: {
            bodyMapper: AppServiceEnvironmentResource,
        },
        204: {
            bodyMapper: AppServiceEnvironmentResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: hostingEnvironmentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, forceDelete],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentResource,
        },
        201: {
            bodyMapper: AppServiceEnvironmentResource,
        },
        202: {
            bodyMapper: AppServiceEnvironmentResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: hostingEnvironmentEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const listCapacitiesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/capacities/compute",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StampCapacityCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getVipInfoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/capacities/virtualip",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AddressResponse,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const changeVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/changeVirtualNetwork",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        201: {
            bodyMapper: WebAppCollection,
        },
        202: {
            bodyMapper: WebAppCollection,
        },
        204: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: vnetInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const getAseCustomDnsSuffixConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/customdnssuffix",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomDnsSuffixConfiguration,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const updateAseCustomDnsSuffixConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/customdnssuffix",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CustomDnsSuffixConfiguration,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: customDnsSuffixConfiguration,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const deleteAseCustomDnsSuffixConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/customdnssuffix",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getAseV3NetworkingConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/networking",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AseV3NetworkingConfiguration,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const updateAseNetworkingConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/configurations/networking",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AseV3NetworkingConfiguration,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: aseNetworkingConfiguration,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const listDiagnosticsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/diagnostics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HostingEnvironmentDiagnostics",
                        },
                    },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getDiagnosticsItemOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/diagnostics/{diagnosticsName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostingEnvironmentDiagnostics,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        diagnosticsName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getInboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/inboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundEnvironmentEndpointCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listMultiRolePoolsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getMultiRolePoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const createOrUpdateMultiRolePoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource,
        },
        201: {
            bodyMapper: WorkerPoolResource,
        },
        202: {
            bodyMapper: WorkerPoolResource,
        },
        204: {
            bodyMapper: WorkerPoolResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: multiRolePoolEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const updateMultiRolePoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource,
        },
        202: {
            bodyMapper: WorkerPoolResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: multiRolePoolEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const listMultiRolePoolInstanceMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/instances/{instance}/metricdefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instance,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listMultiRoleMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/metricdefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listMultiRolePoolSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfoCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const testUpgradeAvailableNotificationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/testUpgradeAvailableNotification",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const upgradeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/upgrade",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listMultiRoleUsagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/multiRolePools/default/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listOperationsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Operation" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getOutboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundEnvironmentEndpointCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getPrivateEndpointConnectionListOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getPrivateEndpointConnectionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const approveOrRejectPrivateEndpointConnectionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        201: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        202: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        204: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: privateEndpointWrapper,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const deletePrivateEndpointConnectionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getPrivateLinkResourcesOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesWrapper,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const rebootOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/reboot",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const resumeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/resume",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        201: {
            bodyMapper: WebAppCollection,
        },
        202: {
            bodyMapper: WebAppCollection,
        },
        204: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listAppServicePlansOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/serverfarms",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWebAppsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, propertiesToInclude],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const suspendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/suspend",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        201: {
            bodyMapper: WebAppCollection,
        },
        202: {
            bodyMapper: WebAppCollection,
        },
        204: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listUsagesOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWorkerPoolsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getWorkerPoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const createOrUpdateWorkerPoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource,
        },
        201: {
            bodyMapper: WorkerPoolResource,
        },
        202: {
            bodyMapper: WorkerPoolResource,
        },
        204: {
            bodyMapper: WorkerPoolResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: workerPoolEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const updateWorkerPoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkerPoolResource,
        },
        202: {
            bodyMapper: WorkerPoolResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: workerPoolEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const listWorkerPoolInstanceMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/instances/{instance}/metricdefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instance,
        workerPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWebWorkerMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/metricdefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWorkerPoolSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfoCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWebWorkerUsagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/workerPools/{workerPoolName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listByResourceGroupNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServiceEnvironmentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listCapacitiesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StampCapacityCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const changeVnetNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        202: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o,
};
const getInboundNetworkDependenciesEndpointsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundEnvironmentEndpointCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listMultiRolePoolsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listMultiRolePoolInstanceMetricDefinitionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instance,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listMultiRoleMetricDefinitionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listMultiRolePoolSkusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfoCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listMultiRoleUsagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getOutboundNetworkDependenciesEndpointsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundEnvironmentEndpointCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const getPrivateEndpointConnectionListNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const resumeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        202: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listAppServicePlansNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWebAppsNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const suspendNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        202: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listUsagesNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWorkerPoolsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkerPoolCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWorkerPoolInstanceMetricDefinitionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instance,
        workerPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWebWorkerMetricDefinitionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceMetricDefinitionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workerPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWorkerPoolSkusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfoCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workerPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};
const listWebWorkerUsagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workerPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$o,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AppServicePlans operations. */
class AppServicePlansImpl {
    /**
     * Initialize a new instance of the class AppServicePlans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all App Service plans for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all App Service plans in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all apps that use a Hybrid Connection in an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Hybrid Connection namespace.
     * @param relayName Name of the Hybrid Connection relay.
     * @param options The options parameters.
     */
    listWebAppsByHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        const iter = this.listWebAppsByHybridConnectionPagingAll(resourceGroupName, name, namespaceName, relayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWebAppsByHybridConnectionPagingPage(resourceGroupName, name, namespaceName, relayName, options, settings);
            },
        };
    }
    listWebAppsByHybridConnectionPagingPage(resourceGroupName, name, namespaceName, relayName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsByHybridConnectionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWebAppsByHybridConnection(resourceGroupName, name, namespaceName, relayName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWebAppsByHybridConnectionNext(resourceGroupName, name, namespaceName, relayName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWebAppsByHybridConnectionPagingAll(resourceGroupName, name, namespaceName, relayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsByHybridConnectionPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWebAppsByHybridConnectionPagingPage(resourceGroupName, name, namespaceName, relayName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Retrieve all Hybrid Connections in use in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    listHybridConnections(resourceGroupName, name, options) {
        const iter = this.listHybridConnectionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listHybridConnectionsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listHybridConnectionsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listHybridConnectionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listHybridConnections(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listHybridConnectionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listHybridConnectionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHybridConnectionsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listHybridConnectionsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get all apps associated with an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    listWebApps(resourceGroupName, name, options) {
        const iter = this.listWebAppsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWebAppsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listWebAppsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWebApps(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWebAppsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWebAppsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebAppsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWebAppsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Gets server farm usage information
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of App Service Plan
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, name, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listUsagesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listUsagesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listUsages(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listUsagesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listUsagesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Get all App Service plans for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$f);
    }
    /**
     * Description for Get all App Service plans in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$5);
    }
    /**
     * Description for Get an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$c);
    }
    /**
     * Description for Creates or updates an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param appServicePlan Details of the App Service plan.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, appServicePlan, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, appServicePlan, options },
                spec: createOrUpdateOperationSpec$4,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates or updates an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param appServicePlan Details of the App Service plan.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, appServicePlan, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, appServicePlan, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    delete(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteOperationSpec$4);
    }
    /**
     * Description for Creates or updates an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param appServicePlan Details of the App Service plan.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, appServicePlan, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appServicePlan, options }, updateOperationSpec$3);
    }
    /**
     * Description for List all capabilities of an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    listCapabilities(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listCapabilitiesOperationSpec);
    }
    /**
     * Description for Retrieve a Hybrid Connection in use in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Service Bus namespace.
     * @param relayName Name of the Service Bus relay.
     * @param options The options parameters.
     */
    getHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, getHybridConnectionOperationSpec$1);
    }
    /**
     * Description for Delete a Hybrid Connection in use in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Service Bus namespace.
     * @param relayName Name of the Service Bus relay.
     * @param options The options parameters.
     */
    deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, deleteHybridConnectionOperationSpec$1);
    }
    /**
     * Description for Get the send key name and value of a Hybrid Connection.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName The name of the Service Bus namespace.
     * @param relayName The name of the Service Bus relay.
     * @param options The options parameters.
     */
    listHybridConnectionKeys(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, listHybridConnectionKeysOperationSpec);
    }
    /**
     * Description for Get all apps that use a Hybrid Connection in an App Service Plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Hybrid Connection namespace.
     * @param relayName Name of the Hybrid Connection relay.
     * @param options The options parameters.
     */
    _listWebAppsByHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, listWebAppsByHybridConnectionOperationSpec);
    }
    /**
     * Description for Get the maximum number of Hybrid Connections allowed in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    getHybridConnectionPlanLimit(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getHybridConnectionPlanLimitOperationSpec);
    }
    /**
     * Description for Retrieve all Hybrid Connections in use in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    _listHybridConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHybridConnectionsOperationSpec$1);
    }
    /**
     * Description for Restart all apps in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    restartWebApps(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, restartWebAppsOperationSpec);
    }
    /**
     * Description for Get all apps associated with an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    _listWebApps(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWebAppsOperationSpec);
    }
    /**
     * Description for Gets all selectable SKUs for a given App Service Plan
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of App Service Plan
     * @param options The options parameters.
     */
    getServerFarmSkus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getServerFarmSkusOperationSpec);
    }
    /**
     * Description for Gets server farm usage information
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of App Service Plan
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listUsagesOperationSpec$1);
    }
    /**
     * Description for Get all Virtual Networks associated with an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param options The options parameters.
     */
    listVnets(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listVnetsOperationSpec);
    }
    /**
     * Description for Get a Virtual Network associated with an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param options The options parameters.
     */
    getVnetFromServerFarm(resourceGroupName, name, vnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, options }, getVnetFromServerFarmOperationSpec);
    }
    /**
     * Description for Get a Virtual Network gateway.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Only the 'primary' gateway is supported.
     * @param options The options parameters.
     */
    getVnetGateway(resourceGroupName, name, vnetName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, gatewayName, options }, getVnetGatewayOperationSpec);
    }
    /**
     * Description for Update a Virtual Network gateway.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Only the 'primary' gateway is supported.
     * @param connectionEnvelope Definition of the gateway.
     * @param options The options parameters.
     */
    updateVnetGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            connectionEnvelope,
            options,
        }, updateVnetGatewayOperationSpec);
    }
    /**
     * Description for Get all routes that are associated with a Virtual Network in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param options The options parameters.
     */
    listRoutesForVnet(resourceGroupName, name, vnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, options }, listRoutesForVnetOperationSpec);
    }
    /**
     * Description for Get a Virtual Network route in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param routeName Name of the Virtual Network route.
     * @param options The options parameters.
     */
    getRouteForVnet(resourceGroupName, name, vnetName, routeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, routeName, options }, getRouteForVnetOperationSpec);
    }
    /**
     * Description for Create or update a Virtual Network route in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param routeName Name of the Virtual Network route.
     * @param route Definition of the Virtual Network route.
     * @param options The options parameters.
     */
    createOrUpdateVnetRoute(resourceGroupName, name, vnetName, routeName, route, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, routeName, route, options }, createOrUpdateVnetRouteOperationSpec);
    }
    /**
     * Description for Delete a Virtual Network route in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param routeName Name of the Virtual Network route.
     * @param options The options parameters.
     */
    deleteVnetRoute(resourceGroupName, name, vnetName, routeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, routeName, options }, deleteVnetRouteOperationSpec);
    }
    /**
     * Description for Create or update a Virtual Network route in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param vnetName Name of the Virtual Network.
     * @param routeName Name of the Virtual Network route.
     * @param route Definition of the Virtual Network route.
     * @param options The options parameters.
     */
    updateVnetRoute(resourceGroupName, name, vnetName, routeName, route, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, routeName, route, options }, updateVnetRouteOperationSpec);
    }
    /**
     * Description for Reboot a worker machine in an App Service plan.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param workerName Name of worker machine, which typically starts with RD.
     * @param options The options parameters.
     */
    rebootWorker(resourceGroupName, name, workerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workerName, options }, rebootWorkerOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$f);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$5);
    }
    /**
     * ListWebAppsByHybridConnectionNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param namespaceName Name of the Hybrid Connection namespace.
     * @param relayName Name of the Hybrid Connection relay.
     * @param nextLink The nextLink from the previous successful call to the ListWebAppsByHybridConnection
     *                 method.
     * @param options The options parameters.
     */
    _listWebAppsByHybridConnectionNext(resourceGroupName, name, namespaceName, relayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, nextLink, options }, listWebAppsByHybridConnectionNextOperationSpec);
    }
    /**
     * ListHybridConnectionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param nextLink The nextLink from the previous successful call to the ListHybridConnections method.
     * @param options The options parameters.
     */
    _listHybridConnectionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listHybridConnectionsNextOperationSpec);
    }
    /**
     * ListWebAppsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the App Service plan.
     * @param nextLink The nextLink from the previous successful call to the ListWebApps method.
     * @param options The options parameters.
     */
    _listWebAppsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listWebAppsNextOperationSpec);
    }
    /**
     * ListUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of App Service Plan
     * @param nextLink The nextLink from the previous successful call to the ListUsages method.
     * @param options The options parameters.
     */
    _listUsagesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listUsagesNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/serverfarms",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, detailed],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listByResourceGroupOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlan,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AppServicePlan,
        },
        201: {
            bodyMapper: AppServicePlan,
        },
        202: {
            bodyMapper: AppServicePlan,
        },
        204: {
            bodyMapper: AppServicePlan,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: appServicePlan,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n,
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AppServicePlan,
        },
        202: {
            bodyMapper: AppServicePlan,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: appServicePlan1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n,
};
const listCapabilitiesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/capabilities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Capability" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const getHybridConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const deleteHybridConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listHybridConnectionKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: HybridConnectionKey,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listWebAppsByHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const getHybridConnectionPlanLimitOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionPlanLimits/limit",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnectionLimits,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listHybridConnectionsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/hybridConnectionRelays",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const restartWebAppsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/restartSites",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, softRestart],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listWebAppsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        filter,
        skipToken,
        top,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const getServerFarmSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listUsagesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listVnetsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "VnetInfoResource" },
                    },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const getVnetFromServerFarmOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetInfoResource,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const getVnetGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetGateway,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const updateVnetGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetGateway,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n,
};
const listRoutesForVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "VnetRoute" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const getRouteForVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "VnetRoute" } },
                },
            },
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        routeName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const createOrUpdateVnetRouteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetRoute,
        },
        400: {
            isError: true,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: route,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        routeName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n,
};
const deleteVnetRouteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        routeName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const updateVnetRouteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/virtualNetworkConnections/{vnetName}/routes/{routeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetRoute,
        },
        400: {
            isError: true,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: route,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        routeName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n,
};
const rebootWorkerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/serverfarms/{name}/workers/{workerName}/reboot",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workerName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listByResourceGroupNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AppServicePlanCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listWebAppsByHybridConnectionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        namespaceName,
        relayName,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listHybridConnectionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listWebAppsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};
const listUsagesNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$n,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Certificates operations. */
class CertificatesImpl {
    /**
     * Initialize a new instance of the class Certificates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all certificates for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all certificates in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all certificates for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$e);
    }
    /**
     * Description for Get all certificates in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$4);
    }
    /**
     * Description for Get a certificate.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$b);
    }
    /**
     * Description for Create or update a certificate.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate.
     * @param certificateEnvelope Details of certificate, if it exists already.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, name, certificateEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, certificateEnvelope, options }, createOrUpdateOperationSpec$3);
    }
    /**
     * Description for Delete a certificate.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate.
     * @param options The options parameters.
     */
    delete(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteOperationSpec$3);
    }
    /**
     * Description for Create or update a certificate.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the certificate.
     * @param certificateEnvelope Details of certificate, if it exists already.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, certificateEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, certificateEnvelope, options }, updateOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$e);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$m,
};
const listByResourceGroupOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$m,
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Certificate,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$m,
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Certificate,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: certificateEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m,
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$m,
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/certificates/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Certificate,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: certificateEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m,
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$m,
};
const listByResourceGroupNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$m,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerApps operations. */
class ContainerAppsImpl {
    /**
     * Initialize a new instance of the class ContainerApps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Container Apps in a given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            },
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Container Apps in a given resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get the Container Apps in a given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Get the Container Apps in a given resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * Get the properties of a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$a);
    }
    /**
     * Description for Create or update a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param containerAppEnvelope Container App.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, containerAppEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, containerAppEnvelope, options },
                spec: createOrUpdateOperationSpec$2,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create or update a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param containerAppEnvelope Container App.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, containerAppEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, containerAppEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: deleteOperationSpec$2,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Delete a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Container App.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List secrets for a container app
     * @param name Name of the Container App.
     * @param options The options parameters.
     */
    listSecrets(name, options) {
        return this.client.sendOperationRequest({ name, options }, listSecretsOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/containerApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$l,
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$l,
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerApp,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$l,
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ContainerApp,
        },
        201: {
            bodyMapper: ContainerApp,
        },
        202: {
            bodyMapper: ContainerApp,
        },
        204: {
            bodyMapper: ContainerApp,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: containerAppEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l,
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$l,
};
const listSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/containerApps/{name}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SecretsCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId, name],
    headerParameters: [accept],
    serializer: serializer$l,
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$l,
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$l,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerAppsRevisions operations. */
class ContainerAppsRevisionsImpl {
    /**
     * Initialize a new instance of the class ContainerAppsRevisions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Revisions for a given Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param options The options parameters.
     */
    listRevisions(resourceGroupName, containerAppName, options) {
        const iter = this.listRevisionsPagingAll(resourceGroupName, containerAppName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRevisionsPagingPage(resourceGroupName, containerAppName, options, settings);
            },
        };
    }
    listRevisionsPagingPage(resourceGroupName, containerAppName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRevisions(resourceGroupName, containerAppName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRevisionsNext(resourceGroupName, containerAppName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRevisionsPagingAll(resourceGroupName, containerAppName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listRevisionsPagingPage(resourceGroupName, containerAppName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Revisions for a given Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param options The options parameters.
     */
    _listRevisions(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, listRevisionsOperationSpec);
    }
    /**
     * Get a revision of a Container App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App.
     * @param name Name of the Container App Revision.
     * @param options The options parameters.
     */
    getRevision(resourceGroupName, containerAppName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, name, options }, getRevisionOperationSpec);
    }
    /**
     * Activates a revision for a Container App
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App.
     * @param name Name of the Container App Revision to activate
     * @param options The options parameters.
     */
    activateRevision(resourceGroupName, containerAppName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, name, options }, activateRevisionOperationSpec);
    }
    /**
     * Deactivates a revision for a Container App
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App.
     * @param name Name of the Container App Revision to deactivate
     * @param options The options parameters.
     */
    deactivateRevision(resourceGroupName, containerAppName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, name, options }, deactivateRevisionOperationSpec);
    }
    /**
     * Restarts a revision for a Container App
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App.
     * @param name Name of the Container App Revision to restart
     * @param options The options parameters.
     */
    restartRevision(resourceGroupName, containerAppName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, name, options }, restartRevisionOperationSpec);
    }
    /**
     * ListRevisionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param nextLink The nextLink from the previous successful call to the ListRevisions method.
     * @param options The options parameters.
     */
    _listRevisionsNext(resourceGroupName, containerAppName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, nextLink, options }, listRevisionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listRevisionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RevisionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$k,
};
const getRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Revision,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$k,
};
const activateRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions/{name}/activate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$k,
};
const deactivateRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions/{name}/deactivate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$k,
};
const restartRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/containerApps/{containerAppName}/revisions/{name}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$k,
};
const listRevisionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RevisionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        containerAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$k,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DeletedWebApps operations. */
class DeletedWebAppsImpl {
    /**
     * Initialize a new instance of the class DeletedWebApps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all deleted apps for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all deleted apps for a subscription at location
     * @param location
     * @param options The options parameters.
     */
    listByLocation(location, options) {
        const iter = this.listByLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByLocationPagingPage(location, options, settings);
            },
        };
    }
    listByLocationPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByLocation(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByLocationPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all deleted apps for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$d);
    }
    /**
     * Description for Get all deleted apps for a subscription at location
     * @param location
     * @param options The options parameters.
     */
    _listByLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, listByLocationOperationSpec);
    }
    /**
     * Description for Get deleted app for a subscription at location.
     * @param location
     * @param deletedSiteId The numeric ID of the deleted app, e.g. 12345
     * @param options The options parameters.
     */
    getDeletedWebAppByLocation(location, deletedSiteId, options) {
        return this.client.sendOperationRequest({ location, deletedSiteId, options }, getDeletedWebAppByLocationOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$d);
    }
    /**
     * ListByLocationNext
     * @param location
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listByLocationNextOperationSpec);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deletedSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedWebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$j,
};
const listByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/deletedSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedWebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
    ],
    headerParameters: [accept],
    serializer: serializer$j,
};
const getDeletedWebAppByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/deletedSites/{deletedSiteId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedSite,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        deletedSiteId,
    ],
    headerParameters: [accept],
    serializer: serializer$j,
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedWebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$j,
};
const listByLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedWebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location,
    ],
    headerParameters: [accept],
    serializer: serializer$j,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Diagnostics operations. */
class DiagnosticsImpl {
    /**
     * Initialize a new instance of the class Diagnostics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for List Hosting Environment Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name
     * @param options The options parameters.
     */
    listHostingEnvironmentDetectorResponses(resourceGroupName, name, options) {
        const iter = this.listHostingEnvironmentDetectorResponsesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listHostingEnvironmentDetectorResponsesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listHostingEnvironmentDetectorResponsesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listHostingEnvironmentDetectorResponsesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listHostingEnvironmentDetectorResponses(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listHostingEnvironmentDetectorResponsesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listHostingEnvironmentDetectorResponsesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHostingEnvironmentDetectorResponsesPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listHostingEnvironmentDetectorResponsesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for List Site Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param options The options parameters.
     */
    listSiteDetectorResponses(resourceGroupName, siteName, options) {
        const iter = this.listSiteDetectorResponsesPagingAll(resourceGroupName, siteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteDetectorResponsesPagingPage(resourceGroupName, siteName, options, settings);
            },
        };
    }
    listSiteDetectorResponsesPagingPage(resourceGroupName, siteName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorResponsesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorResponses(resourceGroupName, siteName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorResponsesNext(resourceGroupName, siteName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteDetectorResponsesPagingAll(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorResponsesPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteDetectorResponsesPagingPage(resourceGroupName, siteName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get Diagnostics Categories
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param options The options parameters.
     */
    listSiteDiagnosticCategories(resourceGroupName, siteName, options) {
        const iter = this.listSiteDiagnosticCategoriesPagingAll(resourceGroupName, siteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteDiagnosticCategoriesPagingPage(resourceGroupName, siteName, options, settings);
            },
        };
    }
    listSiteDiagnosticCategoriesPagingPage(resourceGroupName, siteName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDiagnosticCategoriesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteDiagnosticCategories(resourceGroupName, siteName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDiagnosticCategoriesNext(resourceGroupName, siteName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteDiagnosticCategoriesPagingAll(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDiagnosticCategoriesPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteDiagnosticCategoriesPagingPage(resourceGroupName, siteName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Get Site Analyses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    listSiteAnalyses(resourceGroupName, siteName, diagnosticCategory, options) {
        const iter = this.listSiteAnalysesPagingAll(resourceGroupName, siteName, diagnosticCategory, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteAnalysesPagingPage(resourceGroupName, siteName, diagnosticCategory, options, settings);
            },
        };
    }
    listSiteAnalysesPagingPage(resourceGroupName, siteName, diagnosticCategory, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteAnalysesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteAnalyses(resourceGroupName, siteName, diagnosticCategory, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteAnalysesNext(resourceGroupName, siteName, diagnosticCategory, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteAnalysesPagingAll(resourceGroupName, siteName, diagnosticCategory, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteAnalysesPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteAnalysesPagingPage(resourceGroupName, siteName, diagnosticCategory, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get Detectors
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    listSiteDetectors(resourceGroupName, siteName, diagnosticCategory, options) {
        const iter = this.listSiteDetectorsPagingAll(resourceGroupName, siteName, diagnosticCategory, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteDetectorsPagingPage(resourceGroupName, siteName, diagnosticCategory, options, settings);
            },
        };
    }
    listSiteDetectorsPagingPage(resourceGroupName, siteName, diagnosticCategory, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteDetectors(resourceGroupName, siteName, diagnosticCategory, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorsNext(resourceGroupName, siteName, diagnosticCategory, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteDetectorsPagingAll(resourceGroupName, siteName, diagnosticCategory, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteDetectorsPagingPage(resourceGroupName, siteName, diagnosticCategory, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for List Site Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    listSiteDetectorResponsesSlot(resourceGroupName, siteName, slot, options) {
        const iter = this.listSiteDetectorResponsesSlotPagingAll(resourceGroupName, siteName, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteDetectorResponsesSlotPagingPage(resourceGroupName, siteName, slot, options, settings);
            },
        };
    }
    listSiteDetectorResponsesSlotPagingPage(resourceGroupName, siteName, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorResponsesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorResponsesSlot(resourceGroupName, siteName, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorResponsesSlotNext(resourceGroupName, siteName, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteDetectorResponsesSlotPagingAll(resourceGroupName, siteName, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorResponsesSlotPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteDetectorResponsesSlotPagingPage(resourceGroupName, siteName, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Get Diagnostics Categories
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    listSiteDiagnosticCategoriesSlot(resourceGroupName, siteName, slot, options) {
        const iter = this.listSiteDiagnosticCategoriesSlotPagingAll(resourceGroupName, siteName, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteDiagnosticCategoriesSlotPagingPage(resourceGroupName, siteName, slot, options, settings);
            },
        };
    }
    listSiteDiagnosticCategoriesSlotPagingPage(resourceGroupName, siteName, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDiagnosticCategoriesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteDiagnosticCategoriesSlot(resourceGroupName, siteName, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDiagnosticCategoriesSlotNext(resourceGroupName, siteName, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteDiagnosticCategoriesSlotPagingAll(resourceGroupName, siteName, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDiagnosticCategoriesSlotPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteDiagnosticCategoriesSlotPagingPage(resourceGroupName, siteName, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Get Site Analyses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    listSiteAnalysesSlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        const iter = this.listSiteAnalysesSlotPagingAll(resourceGroupName, siteName, diagnosticCategory, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteAnalysesSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options, settings);
            },
        };
    }
    listSiteAnalysesSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteAnalysesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteAnalysesSlot(resourceGroupName, siteName, diagnosticCategory, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteAnalysesSlotNext(resourceGroupName, siteName, diagnosticCategory, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteAnalysesSlotPagingAll(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteAnalysesSlotPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteAnalysesSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Description for Get Detectors
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    listSiteDetectorsSlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        const iter = this.listSiteDetectorsSlotPagingAll(resourceGroupName, siteName, diagnosticCategory, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteDetectorsSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options, settings);
            },
        };
    }
    listSiteDetectorsSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorsSlot(resourceGroupName, siteName, diagnosticCategory, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteDetectorsSlotNext(resourceGroupName, siteName, diagnosticCategory, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteDetectorsSlotPagingAll(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteDetectorsSlotPagingAll_1() {
            var _a, e_9, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteDetectorsSlotPagingPage(resourceGroupName, siteName, diagnosticCategory, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * Description for List Hosting Environment Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name
     * @param options The options parameters.
     */
    _listHostingEnvironmentDetectorResponses(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHostingEnvironmentDetectorResponsesOperationSpec);
    }
    /**
     * Description for Get Hosting Environment Detector Response
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name App Service Environment Name
     * @param detectorName Detector Resource Name
     * @param options The options parameters.
     */
    getHostingEnvironmentDetectorResponse(resourceGroupName, name, detectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, detectorName, options }, getHostingEnvironmentDetectorResponseOperationSpec);
    }
    /**
     * Description for List Site Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param options The options parameters.
     */
    _listSiteDetectorResponses(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, listSiteDetectorResponsesOperationSpec);
    }
    /**
     * Description for Get site detector response
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param detectorName Detector Resource Name
     * @param options The options parameters.
     */
    getSiteDetectorResponse(resourceGroupName, siteName, detectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, detectorName, options }, getSiteDetectorResponseOperationSpec);
    }
    /**
     * Description for Get Diagnostics Categories
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param options The options parameters.
     */
    _listSiteDiagnosticCategories(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, listSiteDiagnosticCategoriesOperationSpec);
    }
    /**
     * Description for Get Diagnostics Category
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    getSiteDiagnosticCategory(resourceGroupName, siteName, diagnosticCategory, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, options }, getSiteDiagnosticCategoryOperationSpec);
    }
    /**
     * Description for Get Site Analyses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    _listSiteAnalyses(resourceGroupName, siteName, diagnosticCategory, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, options }, listSiteAnalysesOperationSpec);
    }
    /**
     * Description for Get Site Analysis
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param analysisName Analysis Name
     * @param options The options parameters.
     */
    getSiteAnalysis(resourceGroupName, siteName, diagnosticCategory, analysisName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            analysisName,
            options,
        }, getSiteAnalysisOperationSpec);
    }
    /**
     * Description for Execute Analysis
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Category Name
     * @param analysisName Analysis Resource Name
     * @param options The options parameters.
     */
    executeSiteAnalysis(resourceGroupName, siteName, diagnosticCategory, analysisName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            analysisName,
            options,
        }, executeSiteAnalysisOperationSpec);
    }
    /**
     * Description for Get Detectors
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param options The options parameters.
     */
    _listSiteDetectors(resourceGroupName, siteName, diagnosticCategory, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, options }, listSiteDetectorsOperationSpec);
    }
    /**
     * Description for Get Detector
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param detectorName Detector Name
     * @param options The options parameters.
     */
    getSiteDetector(resourceGroupName, siteName, diagnosticCategory, detectorName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            detectorName,
            options,
        }, getSiteDetectorOperationSpec);
    }
    /**
     * Description for Execute Detector
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param detectorName Detector Resource Name
     * @param diagnosticCategory Category Name
     * @param options The options parameters.
     */
    executeSiteDetector(resourceGroupName, siteName, detectorName, diagnosticCategory, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            detectorName,
            diagnosticCategory,
            options,
        }, executeSiteDetectorOperationSpec);
    }
    /**
     * Description for List Site Detector Responses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    _listSiteDetectorResponsesSlot(resourceGroupName, siteName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, slot, options }, listSiteDetectorResponsesSlotOperationSpec);
    }
    /**
     * Description for Get site detector response
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param detectorName Detector Resource Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    getSiteDetectorResponseSlot(resourceGroupName, siteName, detectorName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, detectorName, slot, options }, getSiteDetectorResponseSlotOperationSpec);
    }
    /**
     * Description for Get Diagnostics Categories
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    _listSiteDiagnosticCategoriesSlot(resourceGroupName, siteName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, slot, options }, listSiteDiagnosticCategoriesSlotOperationSpec);
    }
    /**
     * Description for Get Diagnostics Category
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    getSiteDiagnosticCategorySlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, slot, options }, getSiteDiagnosticCategorySlotOperationSpec);
    }
    /**
     * Description for Get Site Analyses
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    _listSiteAnalysesSlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, slot, options }, listSiteAnalysesSlotOperationSpec);
    }
    /**
     * Description for Get Site Analysis
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param analysisName Analysis Name
     * @param slot Slot - optional
     * @param options The options parameters.
     */
    getSiteAnalysisSlot(resourceGroupName, siteName, diagnosticCategory, analysisName, slot, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            analysisName,
            slot,
            options,
        }, getSiteAnalysisSlotOperationSpec);
    }
    /**
     * Description for Execute Analysis
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Category Name
     * @param analysisName Analysis Resource Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    executeSiteAnalysisSlot(resourceGroupName, siteName, diagnosticCategory, analysisName, slot, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            analysisName,
            slot,
            options,
        }, executeSiteAnalysisSlotOperationSpec);
    }
    /**
     * Description for Get Detectors
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param options The options parameters.
     */
    _listSiteDetectorsSlot(resourceGroupName, siteName, diagnosticCategory, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, slot, options }, listSiteDetectorsSlotOperationSpec);
    }
    /**
     * Description for Get Detector
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param detectorName Detector Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    getSiteDetectorSlot(resourceGroupName, siteName, diagnosticCategory, detectorName, slot, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            detectorName,
            slot,
            options,
        }, getSiteDetectorSlotOperationSpec);
    }
    /**
     * Description for Execute Detector
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param detectorName Detector Resource Name
     * @param diagnosticCategory Category Name
     * @param slot Slot Name
     * @param options The options parameters.
     */
    executeSiteDetectorSlot(resourceGroupName, siteName, detectorName, diagnosticCategory, slot, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            detectorName,
            diagnosticCategory,
            slot,
            options,
        }, executeSiteDetectorSlotOperationSpec);
    }
    /**
     * ListHostingEnvironmentDetectorResponsesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site Name
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListHostingEnvironmentDetectorResponses method.
     * @param options The options parameters.
     */
    _listHostingEnvironmentDetectorResponsesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listHostingEnvironmentDetectorResponsesNextOperationSpec);
    }
    /**
     * ListSiteDetectorResponsesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteDetectorResponses
     *                 method.
     * @param options The options parameters.
     */
    _listSiteDetectorResponsesNext(resourceGroupName, siteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, nextLink, options }, listSiteDetectorResponsesNextOperationSpec);
    }
    /**
     * ListSiteDiagnosticCategoriesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteDiagnosticCategories
     *                 method.
     * @param options The options parameters.
     */
    _listSiteDiagnosticCategoriesNext(resourceGroupName, siteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, nextLink, options }, listSiteDiagnosticCategoriesNextOperationSpec);
    }
    /**
     * ListSiteAnalysesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param nextLink The nextLink from the previous successful call to the ListSiteAnalyses method.
     * @param options The options parameters.
     */
    _listSiteAnalysesNext(resourceGroupName, siteName, diagnosticCategory, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, nextLink, options }, listSiteAnalysesNextOperationSpec);
    }
    /**
     * ListSiteDetectorsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param nextLink The nextLink from the previous successful call to the ListSiteDetectors method.
     * @param options The options parameters.
     */
    _listSiteDetectorsNext(resourceGroupName, siteName, diagnosticCategory, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, diagnosticCategory, nextLink, options }, listSiteDetectorsNextOperationSpec);
    }
    /**
     * ListSiteDetectorResponsesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteDetectorResponsesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listSiteDetectorResponsesSlotNext(resourceGroupName, siteName, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, slot, nextLink, options }, listSiteDetectorResponsesSlotNextOperationSpec);
    }
    /**
     * ListSiteDiagnosticCategoriesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param slot Slot Name
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSiteDiagnosticCategoriesSlot method.
     * @param options The options parameters.
     */
    _listSiteDiagnosticCategoriesSlotNext(resourceGroupName, siteName, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, slot, nextLink, options }, listSiteDiagnosticCategoriesSlotNextOperationSpec);
    }
    /**
     * ListSiteAnalysesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteAnalysesSlot method.
     * @param options The options parameters.
     */
    _listSiteAnalysesSlotNext(resourceGroupName, siteName, diagnosticCategory, slot, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            slot,
            nextLink,
            options,
        }, listSiteAnalysesSlotNextOperationSpec);
    }
    /**
     * ListSiteDetectorsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site Name
     * @param diagnosticCategory Diagnostic Category
     * @param slot Slot Name
     * @param nextLink The nextLink from the previous successful call to the ListSiteDetectorsSlot method.
     * @param options The options parameters.
     */
    _listSiteDetectorsSlotNext(resourceGroupName, siteName, diagnosticCategory, slot, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            siteName,
            diagnosticCategory,
            slot,
            nextLink,
            options,
        }, listSiteDetectorsSlotNextOperationSpec);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listHostingEnvironmentDetectorResponsesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const getHostingEnvironmentDetectorResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{name}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponse,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        detectorName,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDetectorResponsesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const getSiteDetectorResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponse,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDiagnosticCategoriesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategoryCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const getSiteDiagnosticCategoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategory,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteAnalysesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysisCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const getSiteAnalysisOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalysisDefinition,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        analysisName,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const executeSiteAnalysisOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysis,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        analysisName,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDetectorsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const getSiteDetectorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorDefinitionResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        diagnosticCategory,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const executeSiteDetectorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorResponse,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        diagnosticCategory,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDetectorResponsesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const getSiteDetectorResponseSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponse,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDiagnosticCategoriesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategoryCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const getSiteDiagnosticCategorySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategory,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteAnalysesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysisCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const getSiteAnalysisSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalysisDefinition,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        analysisName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const executeSiteAnalysisSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/analyses/{analysisName}/execute",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysis,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        analysisName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDetectorsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
        diagnosticCategory,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const getSiteDetectorSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorDefinitionResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        diagnosticCategory,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const executeSiteDetectorSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slot}/diagnostics/{diagnosticCategory}/detectors/{detectorName}/execute",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorResponse,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        timeGrain,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        siteName,
        diagnosticCategory,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listHostingEnvironmentDetectorResponsesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDetectorResponsesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDiagnosticCategoriesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategoryCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteAnalysesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysisCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        diagnosticCategory,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDetectorsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        diagnosticCategory,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDetectorResponsesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponseCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDiagnosticCategoriesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticCategoryCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteAnalysesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticAnalysisCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        diagnosticCategory,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};
const listSiteDetectorsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticDetectorCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
        diagnosticCategory,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$i,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Global operations. */
class GlobalImpl {
    /**
     * Initialize a new instance of the class Global class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get deleted app for a subscription.
     * @param deletedSiteId The numeric ID of the deleted app, e.g. 12345
     * @param options The options parameters.
     */
    getDeletedWebApp(deletedSiteId, options) {
        return this.client.sendOperationRequest({ deletedSiteId, options }, getDeletedWebAppOperationSpec);
    }
    /**
     * Description for Get all deleted apps for a subscription.
     * @param deletedSiteId The numeric ID of the deleted app, e.g. 12345
     * @param options The options parameters.
     */
    getDeletedWebAppSnapshots(deletedSiteId, options) {
        return this.client.sendOperationRequest({ deletedSiteId, options }, getDeletedWebAppSnapshotsOperationSpec);
    }
    /**
     * Description for Gets an operation in a subscription and given region
     * @param location Location name
     * @param operationId Operation Id
     * @param options The options parameters.
     */
    getSubscriptionOperationWithAsyncResponse(location, operationId, options) {
        return this.client.sendOperationRequest({ location, operationId, options }, getSubscriptionOperationWithAsyncResponseOperationSpec);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getDeletedWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deletedSites/{deletedSiteId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedSite,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        deletedSiteId,
    ],
    headerParameters: [accept],
    serializer: serializer$h,
};
const getDeletedWebAppSnapshotsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deletedSites/{deletedSiteId}/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Snapshot" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        deletedSiteId,
    ],
    headerParameters: [accept],
    serializer: serializer$h,
};
const getSubscriptionOperationWithAsyncResponseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        operationId,
    ],
    headerParameters: [accept],
    serializer: serializer$h,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing KubeEnvironments operations. */
class KubeEnvironmentsImpl {
    /**
     * Initialize a new instance of the class KubeEnvironments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all Kubernetes Environments for a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            },
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get all the Kubernetes Environments in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all Kubernetes Environments for a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Description for Get all the Kubernetes Environments in a resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * Description for Get the properties of a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$9);
    }
    /**
     * Description for Creates or updates a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param kubeEnvironmentEnvelope Configuration details of the Kubernetes Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, kubeEnvironmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, kubeEnvironmentEnvelope, options },
                spec: createOrUpdateOperationSpec$1,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates or updates a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param kubeEnvironmentEnvelope Configuration details of the Kubernetes Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, kubeEnvironmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, kubeEnvironmentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: deleteOperationSpec$1,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Delete a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Creates or updates a Kubernetes Environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the Kubernetes Environment.
     * @param kubeEnvironmentEnvelope Configuration details of the Kubernetes Environment.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, kubeEnvironmentEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, kubeEnvironmentEnvelope, options }, updateOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/kubeEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironmentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$g,
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironmentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$g,
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironment,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$g,
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KubeEnvironment,
        },
        201: {
            bodyMapper: KubeEnvironment,
        },
        202: {
            bodyMapper: KubeEnvironment,
        },
        204: {
            bodyMapper: KubeEnvironment,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: kubeEnvironmentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g,
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$g,
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/kubeEnvironments/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: KubeEnvironment,
        },
        201: {
            bodyMapper: KubeEnvironment,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: kubeEnvironmentEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g,
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironmentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$g,
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubeEnvironmentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$g,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Provider operations. */
class ProviderImpl {
    /**
     * Initialize a new instance of the class Provider class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get available application frameworks and their versions
     * @param options The options parameters.
     */
    listAvailableStacks(options) {
        const iter = this.getAvailableStacksPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getAvailableStacksPagingPage(options, settings);
            },
        };
    }
    getAvailableStacksPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getAvailableStacksPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getAvailableStacks(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getAvailableStacksNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getAvailableStacksPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getAvailableStacksPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getAvailableStacksPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get available Function app frameworks and their versions
     * @param options The options parameters.
     */
    listFunctionAppStacks(options) {
        const iter = this.getFunctionAppStacksPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getFunctionAppStacksPagingPage(options, settings);
            },
        };
    }
    getFunctionAppStacksPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getFunctionAppStacksPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getFunctionAppStacks(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getFunctionAppStacksNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getFunctionAppStacksPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getFunctionAppStacksPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getFunctionAppStacksPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get available Function app frameworks and their versions for location
     * @param location Function App stack location.
     * @param options The options parameters.
     */
    listFunctionAppStacksForLocation(location, options) {
        const iter = this.getFunctionAppStacksForLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getFunctionAppStacksForLocationPagingPage(location, options, settings);
            },
        };
    }
    getFunctionAppStacksForLocationPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getFunctionAppStacksForLocationPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getFunctionAppStacksForLocation(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getFunctionAppStacksForLocationNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getFunctionAppStacksForLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* getFunctionAppStacksForLocationPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getFunctionAppStacksForLocationPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Get available Web app frameworks and their versions for location
     * @param location Web App stack location.
     * @param options The options parameters.
     */
    listWebAppStacksForLocation(location, options) {
        const iter = this.getWebAppStacksForLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getWebAppStacksForLocationPagingPage(location, options, settings);
            },
        };
    }
    getWebAppStacksForLocationPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getWebAppStacksForLocationPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getWebAppStacksForLocation(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getWebAppStacksForLocationNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getWebAppStacksForLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* getWebAppStacksForLocationPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getWebAppStacksForLocationPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Gets all available operations for the Microsoft.Web resource provider. Also exposes
     * resource metric definitions
     * @param options The options parameters.
     */
    listOperations(options) {
        const iter = this.listOperationsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listOperationsPagingPage(options, settings);
            },
        };
    }
    listOperationsPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listOperations(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listOperationsNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listOperationsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listOperationsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listOperationsPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Get available Web app frameworks and their versions
     * @param options The options parameters.
     */
    listWebAppStacks(options) {
        const iter = this.getWebAppStacksPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getWebAppStacksPagingPage(options, settings);
            },
        };
    }
    getWebAppStacksPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getWebAppStacksPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getWebAppStacks(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getWebAppStacksNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getWebAppStacksPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getWebAppStacksPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getWebAppStacksPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Get available application frameworks and their versions
     * @param options The options parameters.
     */
    listAvailableStacksOnPrem(options) {
        const iter = this.getAvailableStacksOnPremPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getAvailableStacksOnPremPagingPage(options, settings);
            },
        };
    }
    getAvailableStacksOnPremPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getAvailableStacksOnPremPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getAvailableStacksOnPrem(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getAvailableStacksOnPremNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getAvailableStacksOnPremPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getAvailableStacksOnPremPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getAvailableStacksOnPremPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Get available application frameworks and their versions
     * @param options The options parameters.
     */
    _getAvailableStacks(options) {
        return this.client.sendOperationRequest({ options }, getAvailableStacksOperationSpec);
    }
    /**
     * Description for Get available Function app frameworks and their versions
     * @param options The options parameters.
     */
    _getFunctionAppStacks(options) {
        return this.client.sendOperationRequest({ options }, getFunctionAppStacksOperationSpec);
    }
    /**
     * Description for Get available Function app frameworks and their versions for location
     * @param location Function App stack location.
     * @param options The options parameters.
     */
    _getFunctionAppStacksForLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, getFunctionAppStacksForLocationOperationSpec);
    }
    /**
     * Description for Get available Web app frameworks and their versions for location
     * @param location Web App stack location.
     * @param options The options parameters.
     */
    _getWebAppStacksForLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, getWebAppStacksForLocationOperationSpec);
    }
    /**
     * Description for Gets all available operations for the Microsoft.Web resource provider. Also exposes
     * resource metric definitions
     * @param options The options parameters.
     */
    _listOperations(options) {
        return this.client.sendOperationRequest({ options }, listOperationsOperationSpec);
    }
    /**
     * Description for Get available Web app frameworks and their versions
     * @param options The options parameters.
     */
    _getWebAppStacks(options) {
        return this.client.sendOperationRequest({ options }, getWebAppStacksOperationSpec);
    }
    /**
     * Description for Get available application frameworks and their versions
     * @param options The options parameters.
     */
    _getAvailableStacksOnPrem(options) {
        return this.client.sendOperationRequest({ options }, getAvailableStacksOnPremOperationSpec);
    }
    /**
     * GetAvailableStacksNext
     * @param nextLink The nextLink from the previous successful call to the GetAvailableStacks method.
     * @param options The options parameters.
     */
    _getAvailableStacksNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getAvailableStacksNextOperationSpec);
    }
    /**
     * GetFunctionAppStacksNext
     * @param nextLink The nextLink from the previous successful call to the GetFunctionAppStacks method.
     * @param options The options parameters.
     */
    _getFunctionAppStacksNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getFunctionAppStacksNextOperationSpec);
    }
    /**
     * GetFunctionAppStacksForLocationNext
     * @param location Function App stack location.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetFunctionAppStacksForLocation method.
     * @param options The options parameters.
     */
    _getFunctionAppStacksForLocationNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, getFunctionAppStacksForLocationNextOperationSpec);
    }
    /**
     * GetWebAppStacksForLocationNext
     * @param location Web App stack location.
     * @param nextLink The nextLink from the previous successful call to the GetWebAppStacksForLocation
     *                 method.
     * @param options The options parameters.
     */
    _getWebAppStacksForLocationNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, getWebAppStacksForLocationNextOperationSpec);
    }
    /**
     * ListOperationsNext
     * @param nextLink The nextLink from the previous successful call to the ListOperations method.
     * @param options The options parameters.
     */
    _listOperationsNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listOperationsNextOperationSpec);
    }
    /**
     * GetWebAppStacksNext
     * @param nextLink The nextLink from the previous successful call to the GetWebAppStacks method.
     * @param options The options parameters.
     */
    _getWebAppStacksNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getWebAppStacksNextOperationSpec);
    }
    /**
     * GetAvailableStacksOnPremNext
     * @param nextLink The nextLink from the previous successful call to the GetAvailableStacksOnPrem
     *                 method.
     * @param options The options parameters.
     */
    _getAvailableStacksOnPremNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getAvailableStacksOnPremNextOperationSpec);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getAvailableStacksOperationSpec = {
    path: "/providers/Microsoft.Web/availableStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, osTypeSelected],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getFunctionAppStacksOperationSpec = {
    path: "/providers/Microsoft.Web/functionAppStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionAppStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, stackOsType],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getFunctionAppStacksForLocationOperationSpec = {
    path: "/providers/Microsoft.Web/locations/{location}/functionAppStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionAppStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, stackOsType],
    urlParameters: [$host, location],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getWebAppStacksForLocationOperationSpec = {
    path: "/providers/Microsoft.Web/locations/{location}/webAppStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, stackOsType],
    urlParameters: [$host, location],
    headerParameters: [accept],
    serializer: serializer$f,
};
const listOperationsOperationSpec = {
    path: "/providers/Microsoft.Web/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getWebAppStacksOperationSpec = {
    path: "/providers/Microsoft.Web/webAppStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, stackOsType],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getAvailableStacksOnPremOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/availableStacks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, osTypeSelected],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getAvailableStacksNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getFunctionAppStacksNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionAppStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getFunctionAppStacksForLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionAppStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [$host, nextLink, location],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getWebAppStacksForLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [$host, nextLink, location],
    headerParameters: [accept],
    serializer: serializer$f,
};
const listOperationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmOperationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getWebAppStacksNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$f,
};
const getAvailableStacksOnPremNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationStackCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$f,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Recommendations operations. */
class RecommendationsImpl {
    /**
     * Initialize a new instance of the class Recommendations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for List all recommendations for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Get past recommendations for an app, optionally specified by the time range.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the hosting environment.
     * @param options The options parameters.
     */
    listHistoryForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options) {
        const iter = this.listHistoryForHostingEnvironmentPagingAll(resourceGroupName, hostingEnvironmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listHistoryForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options, settings);
            },
        };
    }
    listHistoryForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listHistoryForHostingEnvironmentPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listHistoryForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listHistoryForHostingEnvironmentNext(resourceGroupName, hostingEnvironmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listHistoryForHostingEnvironmentPagingAll(resourceGroupName, hostingEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHistoryForHostingEnvironmentPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listHistoryForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Get all recommendations for a hosting environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the app.
     * @param options The options parameters.
     */
    listRecommendedRulesForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options) {
        const iter = this.listRecommendedRulesForHostingEnvironmentPagingAll(resourceGroupName, hostingEnvironmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRecommendedRulesForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options, settings);
            },
        };
    }
    listRecommendedRulesForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedRulesForHostingEnvironmentPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRecommendedRulesForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRecommendedRulesForHostingEnvironmentNext(resourceGroupName, hostingEnvironmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRecommendedRulesForHostingEnvironmentPagingAll(resourceGroupName, hostingEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedRulesForHostingEnvironmentPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listRecommendedRulesForHostingEnvironmentPagingPage(resourceGroupName, hostingEnvironmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Get past recommendations for an app, optionally specified by the time range.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    listHistoryForWebApp(resourceGroupName, siteName, options) {
        const iter = this.listHistoryForWebAppPagingAll(resourceGroupName, siteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listHistoryForWebAppPagingPage(resourceGroupName, siteName, options, settings);
            },
        };
    }
    listHistoryForWebAppPagingPage(resourceGroupName, siteName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listHistoryForWebAppPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listHistoryForWebApp(resourceGroupName, siteName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listHistoryForWebAppNext(resourceGroupName, siteName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listHistoryForWebAppPagingAll(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHistoryForWebAppPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listHistoryForWebAppPagingPage(resourceGroupName, siteName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get all recommendations for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    listRecommendedRulesForWebApp(resourceGroupName, siteName, options) {
        const iter = this.listRecommendedRulesForWebAppPagingAll(resourceGroupName, siteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRecommendedRulesForWebAppPagingPage(resourceGroupName, siteName, options, settings);
            },
        };
    }
    listRecommendedRulesForWebAppPagingPage(resourceGroupName, siteName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedRulesForWebAppPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRecommendedRulesForWebApp(resourceGroupName, siteName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRecommendedRulesForWebAppNext(resourceGroupName, siteName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRecommendedRulesForWebAppPagingAll(resourceGroupName, siteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedRulesForWebAppPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listRecommendedRulesForWebAppPagingPage(resourceGroupName, siteName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for List all recommendations for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$c);
    }
    /**
     * Description for Reset all recommendation opt-out settings for a subscription.
     * @param options The options parameters.
     */
    resetAllFilters(options) {
        return this.client.sendOperationRequest({ options }, resetAllFiltersOperationSpec);
    }
    /**
     * Description for Disables the specified rule so it will not apply to a subscription in the future.
     * @param name Rule name
     * @param options The options parameters.
     */
    disableRecommendationForSubscription(name, options) {
        return this.client.sendOperationRequest({ name, options }, disableRecommendationForSubscriptionOperationSpec);
    }
    /**
     * Description for Get past recommendations for an app, optionally specified by the time range.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the hosting environment.
     * @param options The options parameters.
     */
    _listHistoryForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, options }, listHistoryForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Get all recommendations for a hosting environment.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the app.
     * @param options The options parameters.
     */
    _listRecommendedRulesForHostingEnvironment(resourceGroupName, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, options }, listRecommendedRulesForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Disable all recommendations for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param environmentName Name of the app.
     * @param hostingEnvironmentName
     * @param options The options parameters.
     */
    disableAllForHostingEnvironment(resourceGroupName, environmentName, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, hostingEnvironmentName, options }, disableAllForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Reset all recommendation opt-out settings for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param environmentName Name of the app.
     * @param hostingEnvironmentName
     * @param options The options parameters.
     */
    resetAllFiltersForHostingEnvironment(resourceGroupName, environmentName, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, hostingEnvironmentName, options }, resetAllFiltersForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Get a recommendation rule for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the hosting environment.
     * @param name Name of the recommendation.
     * @param options The options parameters.
     */
    getRuleDetailsByHostingEnvironment(resourceGroupName, hostingEnvironmentName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, name, options }, getRuleDetailsByHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Disables the specific rule for a web site permanently.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param environmentName Site name
     * @param name Rule name
     * @param hostingEnvironmentName
     * @param options The options parameters.
     */
    disableRecommendationForHostingEnvironment(resourceGroupName, environmentName, name, hostingEnvironmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            environmentName,
            name,
            hostingEnvironmentName,
            options,
        }, disableRecommendationForHostingEnvironmentOperationSpec);
    }
    /**
     * Description for Get past recommendations for an app, optionally specified by the time range.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    _listHistoryForWebApp(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, listHistoryForWebAppOperationSpec);
    }
    /**
     * Description for Get all recommendations for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    _listRecommendedRulesForWebApp(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, listRecommendedRulesForWebAppOperationSpec);
    }
    /**
     * Description for Disable all recommendations for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    disableAllForWebApp(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, disableAllForWebAppOperationSpec);
    }
    /**
     * Description for Reset all recommendation opt-out settings for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param options The options parameters.
     */
    resetAllFiltersForWebApp(resourceGroupName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, options }, resetAllFiltersForWebAppOperationSpec);
    }
    /**
     * Description for Get a recommendation rule for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param name Name of the recommendation.
     * @param options The options parameters.
     */
    getRuleDetailsByWebApp(resourceGroupName, siteName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, name, options }, getRuleDetailsByWebAppOperationSpec);
    }
    /**
     * Description for Disables the specific rule for a web site permanently.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Site name
     * @param name Rule name
     * @param options The options parameters.
     */
    disableRecommendationForSite(resourceGroupName, siteName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, name, options }, disableRecommendationForSiteOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$c);
    }
    /**
     * ListHistoryForHostingEnvironmentNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the hosting environment.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListHistoryForHostingEnvironment method.
     * @param options The options parameters.
     */
    _listHistoryForHostingEnvironmentNext(resourceGroupName, hostingEnvironmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, nextLink, options }, listHistoryForHostingEnvironmentNextOperationSpec);
    }
    /**
     * ListRecommendedRulesForHostingEnvironmentNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param hostingEnvironmentName Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListRecommendedRulesForHostingEnvironment method.
     * @param options The options parameters.
     */
    _listRecommendedRulesForHostingEnvironmentNext(resourceGroupName, hostingEnvironmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hostingEnvironmentName, nextLink, options }, listRecommendedRulesForHostingEnvironmentNextOperationSpec);
    }
    /**
     * ListHistoryForWebAppNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListHistoryForWebApp method.
     * @param options The options parameters.
     */
    _listHistoryForWebAppNext(resourceGroupName, siteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, nextLink, options }, listHistoryForWebAppNextOperationSpec);
    }
    /**
     * ListRecommendedRulesForWebAppNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param siteName Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListRecommendedRulesForWebApp
     *                 method.
     * @param options The options parameters.
     */
    _listRecommendedRulesForWebAppNext(resourceGroupName, siteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, siteName, nextLink, options }, listRecommendedRulesForWebAppNextOperationSpec);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/recommendations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        filter,
        featured,
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$e,
};
const resetAllFiltersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/recommendations/reset",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$e,
};
const disableRecommendationForSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/recommendations/{name}/disable",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const listHistoryForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendationHistory",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        filter,
        expiredOnly,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostingEnvironmentName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const listRecommendedRulesForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        filter,
        featured,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostingEnvironmentName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const disableAllForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/disable",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, environmentName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostingEnvironmentName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const resetAllFiltersForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/reset",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, environmentName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        hostingEnvironmentName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const getRuleDetailsByHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationRule,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        updateSeen,
        recommendationId,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostingEnvironmentName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const disableRecommendationForHostingEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/hostingEnvironments/{hostingEnvironmentName}/recommendations/{name}/disable",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, environmentName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostingEnvironmentName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const listHistoryForWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendationHistory",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        filter,
        expiredOnly,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const listRecommendedRulesForWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        filter,
        featured,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const disableAllForWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/disable",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const resetAllFiltersForWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/reset",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const getRuleDetailsByWebAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationRule,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        updateSeen,
        recommendationId,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const disableRecommendationForSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/recommendations/{name}/disable",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const listHistoryForHostingEnvironmentNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        hostingEnvironmentName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const listRecommendedRulesForHostingEnvironmentNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        hostingEnvironmentName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const listHistoryForWebAppNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};
const listRecommendedRulesForWebAppNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendationCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        siteName,
    ],
    headerParameters: [accept],
    serializer: serializer$e,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ResourceHealthMetadataOperations operations. */
class ResourceHealthMetadataOperationsImpl {
    /**
     * Initialize a new instance of the class ResourceHealthMetadataOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for List all ResourceHealthMetadata for all sites in the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for List all ResourceHealthMetadata for all sites in the resource group in the
     * subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site as a
     * collection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    listBySite(resourceGroupName, name, options) {
        const iter = this.listBySitePagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySitePagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listBySitePagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySitePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySite(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySiteNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySitePagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySitePagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySitePagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site as a
     * collection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    listBySiteSlot(resourceGroupName, name, slot, options) {
        const iter = this.listBySiteSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySiteSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listBySiteSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySiteSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySiteSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySiteSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySiteSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySiteSlotPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySiteSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for List all ResourceHealthMetadata for all sites in the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$b);
    }
    /**
     * Description for List all ResourceHealthMetadata for all sites in the resource group in the
     * subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site as a
     * collection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    _listBySite(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listBySiteOperationSpec);
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param options The options parameters.
     */
    getBySite(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getBySiteOperationSpec);
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site as a
     * collection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    _listBySiteSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listBySiteSlotOperationSpec);
    }
    /**
     * Description for Gets the category of ResourceHealthMetadata to use for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getBySiteSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getBySiteSlotOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$b);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListBySiteNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param nextLink The nextLink from the previous successful call to the ListBySite method.
     * @param options The options parameters.
     */
    _listBySiteNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listBySiteNextOperationSpec);
    }
    /**
     * ListBySiteSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param nextLink The nextLink from the previous successful call to the ListBySiteSlot method.
     * @param options The options parameters.
     */
    _listBySiteSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listBySiteSlotNextOperationSpec);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/resourceHealthMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$d,
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/resourceHealthMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$d,
};
const listBySiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resourceHealthMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$d,
};
const getBySiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resourceHealthMetadata/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadata,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$d,
};
const listBySiteSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resourceHealthMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$d,
};
const getBySiteSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resourceHealthMetadata/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadata,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$d,
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$d,
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$d,
};
const listBySiteNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$d,
};
const listBySiteSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceHealthMetadataCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$d,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GetUsagesInLocation operations. */
class GetUsagesInLocationImpl {
    /**
     * Initialize a new instance of the class GetUsagesInLocation class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List usages in cores for all skus used by a subscription in a given location, for a specific quota
     * type.
     * @param location The name of the Azure region.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            },
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List usages in cores for all skus used by a subscription in a given location, for a specific quota
     * type.
     * @param location The name of the Azure region.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$a);
    }
    /**
     * ListNext
     * @param location The name of the Azure region.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
    ],
    headerParameters: [accept],
    serializer: serializer$c,
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1,
    ],
    headerParameters: [accept],
    serializer: serializer$c,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing StaticSites operations. */
class StaticSitesImpl {
    /**
     * Initialize a new instance of the class StaticSites class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all Static Sites for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Gets all static sites in the specified resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listStaticSitesByResourceGroup(resourceGroupName, options) {
        const iter = this.getStaticSitesByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getStaticSitesByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    getStaticSitesByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getStaticSitesByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getStaticSitesByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getStaticSitesByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getStaticSitesByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getStaticSitesByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getStaticSitesByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Gets the list of users of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param authprovider The auth provider for the users.
     * @param options The options parameters.
     */
    listStaticSiteUsers(resourceGroupName, name, authprovider, options) {
        const iter = this.listStaticSiteUsersPagingAll(resourceGroupName, name, authprovider, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listStaticSiteUsersPagingPage(resourceGroupName, name, authprovider, options, settings);
            },
        };
    }
    listStaticSiteUsersPagingPage(resourceGroupName, name, authprovider, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteUsersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listStaticSiteUsers(resourceGroupName, name, authprovider, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listStaticSiteUsersNext(resourceGroupName, name, authprovider, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listStaticSiteUsersPagingAll(resourceGroupName, name, authprovider, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteUsersPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listStaticSiteUsersPagingPage(resourceGroupName, name, authprovider, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Gets all static site builds for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteBuilds(resourceGroupName, name, options) {
        const iter = this.getStaticSiteBuildsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getStaticSiteBuildsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getStaticSiteBuildsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getStaticSiteBuildsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getStaticSiteBuilds(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getStaticSiteBuildsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getStaticSiteBuildsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getStaticSiteBuildsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getStaticSiteBuildsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Returns overviews of database connections for a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listBuildDatabaseConnections(resourceGroupName, name, environmentName, options) {
        const iter = this.getBuildDatabaseConnectionsPagingAll(resourceGroupName, name, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getBuildDatabaseConnectionsPagingPage(resourceGroupName, name, environmentName, options, settings);
            },
        };
    }
    getBuildDatabaseConnectionsPagingPage(resourceGroupName, name, environmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getBuildDatabaseConnectionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getBuildDatabaseConnections(resourceGroupName, name, environmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getBuildDatabaseConnectionsNext(resourceGroupName, name, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getBuildDatabaseConnectionsPagingAll(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getBuildDatabaseConnectionsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getBuildDatabaseConnectionsPagingPage(resourceGroupName, name, environmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Gets the functions of a particular static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listStaticSiteBuildFunctions(resourceGroupName, name, environmentName, options) {
        const iter = this.listStaticSiteBuildFunctionsPagingAll(resourceGroupName, name, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listStaticSiteBuildFunctionsPagingPage(resourceGroupName, name, environmentName, options, settings);
            },
        };
    }
    listStaticSiteBuildFunctionsPagingPage(resourceGroupName, name, environmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteBuildFunctionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listStaticSiteBuildFunctions(resourceGroupName, name, environmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listStaticSiteBuildFunctionsNext(resourceGroupName, name, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listStaticSiteBuildFunctionsPagingAll(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteBuildFunctionsPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listStaticSiteBuildFunctionsPagingPage(resourceGroupName, name, environmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Returns details of database connections for a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listBuildDatabaseConnectionsWithDetails(resourceGroupName, name, environmentName, options) {
        const iter = this.getBuildDatabaseConnectionsWithDetailsPagingAll(resourceGroupName, name, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getBuildDatabaseConnectionsWithDetailsPagingPage(resourceGroupName, name, environmentName, options, settings);
            },
        };
    }
    getBuildDatabaseConnectionsWithDetailsPagingPage(resourceGroupName, name, environmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getBuildDatabaseConnectionsWithDetailsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getBuildDatabaseConnectionsWithDetails(resourceGroupName, name, environmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getBuildDatabaseConnectionsWithDetailsNext(resourceGroupName, name, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getBuildDatabaseConnectionsWithDetailsPagingAll(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getBuildDatabaseConnectionsWithDetailsPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getBuildDatabaseConnectionsWithDetailsPagingPage(resourceGroupName, name, environmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Gets the details of the user provided function apps registered with a static site
     * build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listUserProvidedFunctionAppsForStaticSiteBuild(resourceGroupName, name, environmentName, options) {
        const iter = this.getUserProvidedFunctionAppsForStaticSiteBuildPagingAll(resourceGroupName, name, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getUserProvidedFunctionAppsForStaticSiteBuildPagingPage(resourceGroupName, name, environmentName, options, settings);
            },
        };
    }
    getUserProvidedFunctionAppsForStaticSiteBuildPagingPage(resourceGroupName, name, environmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getUserProvidedFunctionAppsForStaticSiteBuildPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getUserProvidedFunctionAppsForStaticSiteBuild(resourceGroupName, name, environmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getUserProvidedFunctionAppsForStaticSiteBuildNext(resourceGroupName, name, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getUserProvidedFunctionAppsForStaticSiteBuildPagingAll(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getUserProvidedFunctionAppsForStaticSiteBuildPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getUserProvidedFunctionAppsForStaticSiteBuildPagingPage(resourceGroupName, name, environmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Description for Gets the basic auth properties for a static site as a collection.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listBasicAuth(resourceGroupName, name, options) {
        const iter = this.listBasicAuthPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBasicAuthPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listBasicAuthPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicAuthPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBasicAuth(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBasicAuthNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBasicAuthPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicAuthPagingAll_1() {
            var _a, e_9, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBasicAuthPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * Description for Gets all static site custom domains for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site resource to search in.
     * @param options The options parameters.
     */
    listStaticSiteCustomDomains(resourceGroupName, name, options) {
        const iter = this.listStaticSiteCustomDomainsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listStaticSiteCustomDomainsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listStaticSiteCustomDomainsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteCustomDomainsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listStaticSiteCustomDomains(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listStaticSiteCustomDomainsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listStaticSiteCustomDomainsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteCustomDomainsPagingAll_1() {
            var _a, e_10, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listStaticSiteCustomDomainsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
    }
    /**
     * Returns overviews of database connections for a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param options The options parameters.
     */
    listDatabaseConnections(resourceGroupName, name, options) {
        const iter = this.getDatabaseConnectionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getDatabaseConnectionsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getDatabaseConnectionsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getDatabaseConnectionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getDatabaseConnections(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getDatabaseConnectionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getDatabaseConnectionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getDatabaseConnectionsPagingAll_1() {
            var _a, e_11, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getDatabaseConnectionsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_11) throw e_11.error; }
            }
        });
    }
    /**
     * Description for Gets the functions of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteFunctions(resourceGroupName, name, options) {
        const iter = this.listStaticSiteFunctionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listStaticSiteFunctionsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listStaticSiteFunctionsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteFunctionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listStaticSiteFunctions(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listStaticSiteFunctionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listStaticSiteFunctionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listStaticSiteFunctionsPagingAll_1() {
            var _a, e_12, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listStaticSiteFunctionsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_12) throw e_12.error; }
            }
        });
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listPrivateEndpointConnectionList(resourceGroupName, name, options) {
        const iter = this.getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionList(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionListNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingAll_1() {
            var _a, e_13, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_13) throw e_13.error; }
            }
        });
    }
    /**
     * Returns details of database connections for a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param options The options parameters.
     */
    listDatabaseConnectionsWithDetails(resourceGroupName, name, options) {
        const iter = this.getDatabaseConnectionsWithDetailsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getDatabaseConnectionsWithDetailsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getDatabaseConnectionsWithDetailsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getDatabaseConnectionsWithDetailsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getDatabaseConnectionsWithDetails(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getDatabaseConnectionsWithDetailsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getDatabaseConnectionsWithDetailsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getDatabaseConnectionsWithDetailsPagingAll_1() {
            var _a, e_14, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getDatabaseConnectionsWithDetailsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_14) throw e_14.error; }
            }
        });
    }
    /**
     * Description for Gets the details of the user provided function apps registered with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listUserProvidedFunctionAppsForStaticSite(resourceGroupName, name, options) {
        const iter = this.getUserProvidedFunctionAppsForStaticSitePagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getUserProvidedFunctionAppsForStaticSitePagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getUserProvidedFunctionAppsForStaticSitePagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getUserProvidedFunctionAppsForStaticSitePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getUserProvidedFunctionAppsForStaticSite(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getUserProvidedFunctionAppsForStaticSiteNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getUserProvidedFunctionAppsForStaticSitePagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getUserProvidedFunctionAppsForStaticSitePagingAll_1() {
            var _a, e_15, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getUserProvidedFunctionAppsForStaticSitePagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_15) throw e_15.error; }
            }
        });
    }
    /**
     * Returns details of all backends linked to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param options The options parameters.
     */
    listLinkedBackends(resourceGroupName, name, options) {
        const iter = this.getLinkedBackendsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getLinkedBackendsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getLinkedBackendsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getLinkedBackendsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getLinkedBackends(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getLinkedBackendsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getLinkedBackendsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getLinkedBackendsPagingAll_1() {
            var _a, e_16, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getLinkedBackendsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_16) throw e_16.error; }
            }
        });
    }
    /**
     * Returns details of all backends linked to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param options The options parameters.
     */
    listLinkedBackendsForBuild(resourceGroupName, name, environmentName, options) {
        const iter = this.getLinkedBackendsForBuildPagingAll(resourceGroupName, name, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getLinkedBackendsForBuildPagingPage(resourceGroupName, name, environmentName, options, settings);
            },
        };
    }
    getLinkedBackendsForBuildPagingPage(resourceGroupName, name, environmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getLinkedBackendsForBuildPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getLinkedBackendsForBuild(resourceGroupName, name, environmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getLinkedBackendsForBuildNext(resourceGroupName, name, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getLinkedBackendsForBuildPagingAll(resourceGroupName, name, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getLinkedBackendsForBuildPagingAll_1() {
            var _a, e_17, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getLinkedBackendsForBuildPagingPage(resourceGroupName, name, environmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_17) throw e_17.error; }
            }
        });
    }
    /**
     * Description for Generates a preview workflow file for the static site
     * @param location Location where you plan to create the static site.
     * @param staticSitesWorkflowPreviewRequest A JSON representation of the
     *                                          StaticSitesWorkflowPreviewRequest properties. See example.
     * @param options The options parameters.
     */
    previewWorkflow(location, staticSitesWorkflowPreviewRequest, options) {
        return this.client.sendOperationRequest({ location, staticSitesWorkflowPreviewRequest, options }, previewWorkflowOperationSpec);
    }
    /**
     * Description for Get all Static Sites for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$9);
    }
    /**
     * Description for Gets all static sites in the specified resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _getStaticSitesByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, getStaticSitesByResourceGroupOperationSpec);
    }
    /**
     * Description for Gets the details of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    getStaticSite(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getStaticSiteOperationSpec);
    }
    /**
     * Description for Creates a new static site in an existing resource group, or updates an existing
     * static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to create or update.
     * @param staticSiteEnvelope A JSON representation of the staticsite properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateStaticSite(resourceGroupName, name, staticSiteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, staticSiteEnvelope, options },
                spec: createOrUpdateStaticSiteOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates a new static site in an existing resource group, or updates an existing
     * static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to create or update.
     * @param staticSiteEnvelope A JSON representation of the staticsite properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateStaticSiteAndWait(resourceGroupName, name, staticSiteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateStaticSite(resourceGroupName, name, staticSiteEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to delete.
     * @param options The options parameters.
     */
    beginDeleteStaticSite(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: deleteStaticSiteOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to delete.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteStaticSite(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Creates a new static site in an existing resource group, or updates an existing
     * static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to create or update.
     * @param staticSiteEnvelope A JSON representation of the staticsite properties. See example.
     * @param options The options parameters.
     */
    updateStaticSite(resourceGroupName, name, staticSiteEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, staticSiteEnvelope, options }, updateStaticSiteOperationSpec);
    }
    /**
     * Description for Gets the list of users of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param authprovider The auth provider for the users.
     * @param options The options parameters.
     */
    _listStaticSiteUsers(resourceGroupName, name, authprovider, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, authprovider, options }, listStaticSiteUsersOperationSpec);
    }
    /**
     * Description for Deletes the user entry from the static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the staticsite.
     * @param authprovider The auth provider for this user.
     * @param userid The user id of the user.
     * @param options The options parameters.
     */
    deleteStaticSiteUser(resourceGroupName, name, authprovider, userid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, authprovider, userid, options }, deleteStaticSiteUserOperationSpec);
    }
    /**
     * Description for Updates a user entry with the listed roles
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param authprovider The auth provider for this user.
     * @param userid The user id of the user.
     * @param staticSiteUserEnvelope A JSON representation of the StaticSiteUser properties. See example.
     * @param options The options parameters.
     */
    updateStaticSiteUser(resourceGroupName, name, authprovider, userid, staticSiteUserEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            authprovider,
            userid,
            staticSiteUserEnvelope,
            options,
        }, updateStaticSiteUserOperationSpec);
    }
    /**
     * Description for Gets all static site builds for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    _getStaticSiteBuilds(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getStaticSiteBuildsOperationSpec);
    }
    /**
     * Description for Gets the details of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    getStaticSiteBuild(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, getStaticSiteBuildOperationSpec);
    }
    /**
     * Description for Deletes a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteBuild(resourceGroupName, name, environmentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, environmentName, options },
                spec: deleteStaticSiteBuildOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteBuildAndWait(resourceGroupName, name, environmentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteStaticSiteBuild(resourceGroupName, name, environmentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Creates or updates the app settings of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param appSettings The dictionary containing the static site app settings to update.
     * @param options The options parameters.
     */
    createOrUpdateStaticSiteBuildAppSettings(resourceGroupName, name, environmentName, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, appSettings, options }, createOrUpdateStaticSiteBuildAppSettingsOperationSpec);
    }
    /**
     * Description for Creates or updates the function app settings of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param appSettings The dictionary containing the static site function app settings to update.
     * @param options The options parameters.
     */
    createOrUpdateStaticSiteBuildFunctionAppSettings(resourceGroupName, name, environmentName, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, appSettings, options }, createOrUpdateStaticSiteBuildFunctionAppSettingsOperationSpec);
    }
    /**
     * Returns overviews of database connections for a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    _getBuildDatabaseConnections(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, getBuildDatabaseConnectionsOperationSpec);
    }
    /**
     * Returns overview of a database connection for a static site build by name
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param databaseConnectionName Name of the database connection.
     * @param options The options parameters.
     */
    getBuildDatabaseConnection(resourceGroupName, name, environmentName, databaseConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            environmentName,
            databaseConnectionName,
            options,
        }, getBuildDatabaseConnectionOperationSpec);
    }
    /**
     * Description for Create or update a database connection for a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param databaseConnectionName Name of the database connection.
     * @param databaseConnectionRequestEnvelope A JSON representation of the database connection request
     *                                          properties
     * @param options The options parameters.
     */
    createOrUpdateBuildDatabaseConnection(resourceGroupName, name, environmentName, databaseConnectionName, databaseConnectionRequestEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            environmentName,
            databaseConnectionName,
            databaseConnectionRequestEnvelope,
            options,
        }, createOrUpdateBuildDatabaseConnectionOperationSpec);
    }
    /**
     * Delete a database connection for a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param databaseConnectionName Name of the database connection.
     * @param options The options parameters.
     */
    deleteBuildDatabaseConnection(resourceGroupName, name, environmentName, databaseConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            environmentName,
            databaseConnectionName,
            options,
        }, deleteBuildDatabaseConnectionOperationSpec);
    }
    /**
     * Description for Create or update a database connection for a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param databaseConnectionName Name of the database connection.
     * @param databaseConnectionRequestEnvelope A JSON representation of the database connection request
     *                                          properties
     * @param options The options parameters.
     */
    updateBuildDatabaseConnection(resourceGroupName, name, environmentName, databaseConnectionName, databaseConnectionRequestEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            environmentName,
            databaseConnectionName,
            databaseConnectionRequestEnvelope,
            options,
        }, updateBuildDatabaseConnectionOperationSpec);
    }
    /**
     * Returns details of a database connection for a static site build by name
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param databaseConnectionName Name of the database connection.
     * @param options The options parameters.
     */
    getBuildDatabaseConnectionWithDetails(resourceGroupName, name, environmentName, databaseConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            environmentName,
            databaseConnectionName,
            options,
        }, getBuildDatabaseConnectionWithDetailsOperationSpec);
    }
    /**
     * Description for Gets the functions of a particular static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    _listStaticSiteBuildFunctions(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, listStaticSiteBuildFunctionsOperationSpec);
    }
    /**
     * Description for Gets the application settings of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listStaticSiteBuildAppSettings(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, listStaticSiteBuildAppSettingsOperationSpec);
    }
    /**
     * Description for Gets the application settings of a static site build.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    listStaticSiteBuildFunctionAppSettings(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, listStaticSiteBuildFunctionAppSettingsOperationSpec);
    }
    /**
     * Returns details of database connections for a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    _getBuildDatabaseConnectionsWithDetails(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, getBuildDatabaseConnectionsWithDetailsOperationSpec);
    }
    /**
     * Description for Gets the details of the user provided function apps registered with a static site
     * build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param options The options parameters.
     */
    _getUserProvidedFunctionAppsForStaticSiteBuild(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, getUserProvidedFunctionAppsForStaticSiteBuildOperationSpec);
    }
    /**
     * Description for Gets the details of the user provided function app registered with a static site
     * build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param functionAppName Name of the function app registered with the static site build.
     * @param options The options parameters.
     */
    getUserProvidedFunctionAppForStaticSiteBuild(resourceGroupName, name, environmentName, functionAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, functionAppName, options }, getUserProvidedFunctionAppForStaticSiteBuildOperationSpec);
    }
    /**
     * Description for Register a user provided function app with a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param functionAppName Name of the function app to register with the static site build.
     * @param staticSiteUserProvidedFunctionEnvelope A JSON representation of the user provided function
     *                                               app properties. See example.
     * @param options The options parameters.
     */
    beginRegisterUserProvidedFunctionAppWithStaticSiteBuild(resourceGroupName, name, environmentName, functionAppName, staticSiteUserProvidedFunctionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    environmentName,
                    functionAppName,
                    staticSiteUserProvidedFunctionEnvelope,
                    options,
                },
                spec: registerUserProvidedFunctionAppWithStaticSiteBuildOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Register a user provided function app with a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param functionAppName Name of the function app to register with the static site build.
     * @param staticSiteUserProvidedFunctionEnvelope A JSON representation of the user provided function
     *                                               app properties. See example.
     * @param options The options parameters.
     */
    beginRegisterUserProvidedFunctionAppWithStaticSiteBuildAndWait(resourceGroupName, name, environmentName, functionAppName, staticSiteUserProvidedFunctionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRegisterUserProvidedFunctionAppWithStaticSiteBuild(resourceGroupName, name, environmentName, functionAppName, staticSiteUserProvidedFunctionEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Detach the user provided function app from the static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param functionAppName Name of the function app registered with the static site build.
     * @param options The options parameters.
     */
    detachUserProvidedFunctionAppFromStaticSiteBuild(resourceGroupName, name, environmentName, functionAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, functionAppName, options }, detachUserProvidedFunctionAppFromStaticSiteBuildOperationSpec);
    }
    /**
     * Description for Deploys zipped content to a specific environment of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName Name of the environment.
     * @param staticSiteZipDeploymentEnvelope A JSON representation of the StaticSiteZipDeployment
     *                                        properties. See example.
     * @param options The options parameters.
     */
    beginCreateZipDeploymentForStaticSiteBuild(resourceGroupName, name, environmentName, staticSiteZipDeploymentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    environmentName,
                    staticSiteZipDeploymentEnvelope,
                    options,
                },
                spec: createZipDeploymentForStaticSiteBuildOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deploys zipped content to a specific environment of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName Name of the environment.
     * @param staticSiteZipDeploymentEnvelope A JSON representation of the StaticSiteZipDeployment
     *                                        properties. See example.
     * @param options The options parameters.
     */
    beginCreateZipDeploymentForStaticSiteBuildAndWait(resourceGroupName, name, environmentName, staticSiteZipDeploymentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateZipDeploymentForStaticSiteBuild(resourceGroupName, name, environmentName, staticSiteZipDeploymentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Creates or updates the app settings of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param appSettings The dictionary containing the static site app settings to update.
     * @param options The options parameters.
     */
    createOrUpdateStaticSiteAppSettings(resourceGroupName, name, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettings, options }, createOrUpdateStaticSiteAppSettingsOperationSpec);
    }
    /**
     * Description for Gets the basic auth properties for a static site as a collection.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    _listBasicAuth(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listBasicAuthOperationSpec);
    }
    /**
     * Description for Gets the basic auth properties for a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param basicAuthName name of the basic auth entry.
     * @param options The options parameters.
     */
    getBasicAuth(resourceGroupName, name, basicAuthName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, basicAuthName, options }, getBasicAuthOperationSpec);
    }
    /**
     * Description for Adds or updates basic auth for a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param basicAuthName name of the basic auth entry.
     * @param basicAuthEnvelope A JSON representation of the basic auth properties.
     * @param options The options parameters.
     */
    createOrUpdateBasicAuth(resourceGroupName, name, basicAuthName, basicAuthEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, basicAuthName, basicAuthEnvelope, options }, createOrUpdateBasicAuthOperationSpec);
    }
    /**
     * Description for Creates or updates the function app settings of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param appSettings The dictionary containing the static site function app settings to update.
     * @param options The options parameters.
     */
    createOrUpdateStaticSiteFunctionAppSettings(resourceGroupName, name, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettings, options }, createOrUpdateStaticSiteFunctionAppSettingsOperationSpec);
    }
    /**
     * Description for Creates an invitation link for a user with the role
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param staticSiteUserRolesInvitationEnvelope Static sites user roles invitation resource.
     * @param options The options parameters.
     */
    createUserRolesInvitationLink(resourceGroupName, name, staticSiteUserRolesInvitationEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            staticSiteUserRolesInvitationEnvelope,
            options,
        }, createUserRolesInvitationLinkOperationSpec);
    }
    /**
     * Description for Gets all static site custom domains for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site resource to search in.
     * @param options The options parameters.
     */
    _listStaticSiteCustomDomains(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteCustomDomainsOperationSpec);
    }
    /**
     * Description for Gets an existing custom domain for a particular static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site resource to search in.
     * @param domainName The custom domain name.
     * @param options The options parameters.
     */
    getStaticSiteCustomDomain(resourceGroupName, name, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainName, options }, getStaticSiteCustomDomainOperationSpec);
    }
    /**
     * Description for Creates a new static site custom domain in an existing resource group and static
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to create.
     * @param staticSiteCustomDomainRequestPropertiesEnvelope A JSON representation of the static site
     *                                                        custom domain request properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateStaticSiteCustomDomain(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    domainName,
                    staticSiteCustomDomainRequestPropertiesEnvelope,
                    options,
                },
                spec: createOrUpdateStaticSiteCustomDomainOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates a new static site custom domain in an existing resource group and static
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to create.
     * @param staticSiteCustomDomainRequestPropertiesEnvelope A JSON representation of the static site
     *                                                        custom domain request properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateStaticSiteCustomDomainAndWait(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateStaticSiteCustomDomain(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a custom domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to delete.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteCustomDomain(resourceGroupName, name, domainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, domainName, options },
                spec: deleteStaticSiteCustomDomainOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a custom domain.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to delete.
     * @param options The options parameters.
     */
    beginDeleteStaticSiteCustomDomainAndWait(resourceGroupName, name, domainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteStaticSiteCustomDomain(resourceGroupName, name, domainName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Validates a particular custom domain can be added to a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to validate.
     * @param staticSiteCustomDomainRequestPropertiesEnvelope A JSON representation of the static site
     *                                                        custom domain request properties. See example.
     * @param options The options parameters.
     */
    beginValidateCustomDomainCanBeAddedToStaticSite(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    domainName,
                    staticSiteCustomDomainRequestPropertiesEnvelope,
                    options,
                },
                spec: validateCustomDomainCanBeAddedToStaticSiteOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Validates a particular custom domain can be added to a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param domainName The custom domain to validate.
     * @param staticSiteCustomDomainRequestPropertiesEnvelope A JSON representation of the static site
     *                                                        custom domain request properties. See example.
     * @param options The options parameters.
     */
    beginValidateCustomDomainCanBeAddedToStaticSiteAndWait(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateCustomDomainCanBeAddedToStaticSite(resourceGroupName, name, domainName, staticSiteCustomDomainRequestPropertiesEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns overviews of database connections for a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param options The options parameters.
     */
    _getDatabaseConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getDatabaseConnectionsOperationSpec);
    }
    /**
     * Returns overview of a database connection for a static site by name
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param databaseConnectionName Name of the database connection.
     * @param options The options parameters.
     */
    getDatabaseConnection(resourceGroupName, name, databaseConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, databaseConnectionName, options }, getDatabaseConnectionOperationSpec);
    }
    /**
     * Description for Create or update a database connection for a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param databaseConnectionName Name of the database connection.
     * @param databaseConnectionRequestEnvelope A JSON representation of the database connection request
     *                                          properties
     * @param options The options parameters.
     */
    createOrUpdateDatabaseConnection(resourceGroupName, name, databaseConnectionName, databaseConnectionRequestEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            databaseConnectionName,
            databaseConnectionRequestEnvelope,
            options,
        }, createOrUpdateDatabaseConnectionOperationSpec);
    }
    /**
     * Delete a database connection for a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param databaseConnectionName Name of the database connection.
     * @param options The options parameters.
     */
    deleteDatabaseConnection(resourceGroupName, name, databaseConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, databaseConnectionName, options }, deleteDatabaseConnectionOperationSpec);
    }
    /**
     * Description for Create or update a database connection for a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param databaseConnectionName Name of the database connection.
     * @param databaseConnectionRequestEnvelope A JSON representation of the database connection request
     *                                          properties
     * @param options The options parameters.
     */
    updateDatabaseConnection(resourceGroupName, name, databaseConnectionName, databaseConnectionRequestEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            databaseConnectionName,
            databaseConnectionRequestEnvelope,
            options,
        }, updateDatabaseConnectionOperationSpec);
    }
    /**
     * Returns details of a database connection for a static site by name
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param databaseConnectionName Name of the database connection.
     * @param options The options parameters.
     */
    getDatabaseConnectionWithDetails(resourceGroupName, name, databaseConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, databaseConnectionName, options }, getDatabaseConnectionWithDetailsOperationSpec);
    }
    /**
     * Description for Detaches a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to detach.
     * @param options The options parameters.
     */
    beginDetachStaticSite(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: detachStaticSiteOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Detaches a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site to detach.
     * @param options The options parameters.
     */
    beginDetachStaticSiteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDetachStaticSite(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the functions of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    _listStaticSiteFunctions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteFunctionsOperationSpec);
    }
    /**
     * Description for Gets the application settings of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteAppSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteAppSettingsOperationSpec);
    }
    /**
     * Description for Lists the roles configured for the static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteConfiguredRoles(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteConfiguredRolesOperationSpec);
    }
    /**
     * Description for Gets the application settings of a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteFunctionAppSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteFunctionAppSettingsOperationSpec);
    }
    /**
     * Description for Lists the secrets for an existing static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    listStaticSiteSecrets(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listStaticSiteSecretsOperationSpec);
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionList(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateEndpointConnectionListOperationSpec$1);
    }
    /**
     * Description for Gets a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    getPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, options }, getPrivateEndpointConnectionOperationSpec$1);
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param privateEndpointWrapper Request body.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    privateEndpointConnectionName,
                    privateEndpointWrapper,
                    options,
                },
                spec: approveOrRejectPrivateEndpointConnectionOperationSpec$1,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param privateEndpointWrapper Request body.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, privateEndpointConnectionName, options },
                spec: deletePrivateEndpointConnectionOperationSpec$1,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param options The options parameters.
     */
    getPrivateLinkResources(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateLinkResourcesOperationSpec$1);
    }
    /**
     * Description for Resets the api key for an existing static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param resetPropertiesEnvelope Static Site Reset Properties ARM resource.
     * @param options The options parameters.
     */
    resetStaticSiteApiKey(resourceGroupName, name, resetPropertiesEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, resetPropertiesEnvelope, options }, resetStaticSiteApiKeyOperationSpec);
    }
    /**
     * Returns details of database connections for a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param options The options parameters.
     */
    _getDatabaseConnectionsWithDetails(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getDatabaseConnectionsWithDetailsOperationSpec);
    }
    /**
     * Description for Gets the details of the user provided function apps registered with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param options The options parameters.
     */
    _getUserProvidedFunctionAppsForStaticSite(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getUserProvidedFunctionAppsForStaticSiteOperationSpec);
    }
    /**
     * Description for Gets the details of the user provided function app registered with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param functionAppName Name of the function app registered with the static site.
     * @param options The options parameters.
     */
    getUserProvidedFunctionAppForStaticSite(resourceGroupName, name, functionAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionAppName, options }, getUserProvidedFunctionAppForStaticSiteOperationSpec);
    }
    /**
     * Description for Register a user provided function app with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param functionAppName Name of the function app to register with the static site.
     * @param staticSiteUserProvidedFunctionEnvelope A JSON representation of the user provided function
     *                                               app properties. See example.
     * @param options The options parameters.
     */
    beginRegisterUserProvidedFunctionAppWithStaticSite(resourceGroupName, name, functionAppName, staticSiteUserProvidedFunctionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    functionAppName,
                    staticSiteUserProvidedFunctionEnvelope,
                    options,
                },
                spec: registerUserProvidedFunctionAppWithStaticSiteOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Register a user provided function app with a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param functionAppName Name of the function app to register with the static site.
     * @param staticSiteUserProvidedFunctionEnvelope A JSON representation of the user provided function
     *                                               app properties. See example.
     * @param options The options parameters.
     */
    beginRegisterUserProvidedFunctionAppWithStaticSiteAndWait(resourceGroupName, name, functionAppName, staticSiteUserProvidedFunctionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRegisterUserProvidedFunctionAppWithStaticSite(resourceGroupName, name, functionAppName, staticSiteUserProvidedFunctionEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Detach the user provided function app from the static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param functionAppName Name of the function app registered with the static site.
     * @param options The options parameters.
     */
    detachUserProvidedFunctionAppFromStaticSite(resourceGroupName, name, functionAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionAppName, options }, detachUserProvidedFunctionAppFromStaticSiteOperationSpec);
    }
    /**
     * Description for Deploys zipped content to a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param staticSiteZipDeploymentEnvelope A JSON representation of the StaticSiteZipDeployment
     *                                        properties. See example.
     * @param options The options parameters.
     */
    beginCreateZipDeploymentForStaticSite(resourceGroupName, name, staticSiteZipDeploymentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    staticSiteZipDeploymentEnvelope,
                    options,
                },
                spec: createZipDeploymentForStaticSiteOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deploys zipped content to a static site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param staticSiteZipDeploymentEnvelope A JSON representation of the StaticSiteZipDeployment
     *                                        properties. See example.
     * @param options The options parameters.
     */
    beginCreateZipDeploymentForStaticSiteAndWait(resourceGroupName, name, staticSiteZipDeploymentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateZipDeploymentForStaticSite(resourceGroupName, name, staticSiteZipDeploymentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Validates that a backend can be linked to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginValidateBackend(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    linkedBackendName,
                    staticSiteLinkedBackendEnvelope,
                    options,
                },
                spec: validateBackendOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates that a backend can be linked to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginValidateBackendAndWait(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateBackend(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Validates that a backend can be linked to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginValidateBackendForBuild(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    environmentName,
                    linkedBackendName,
                    staticSiteLinkedBackendEnvelope,
                    options,
                },
                spec: validateBackendForBuildOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates that a backend can be linked to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginValidateBackendForBuildAndWait(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateBackendForBuild(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns details of all backends linked to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param options The options parameters.
     */
    _getLinkedBackends(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getLinkedBackendsOperationSpec);
    }
    /**
     * Returns details of all backends linked to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param options The options parameters.
     */
    _getLinkedBackendsForBuild(resourceGroupName, name, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, options }, getLinkedBackendsForBuildOperationSpec);
    }
    /**
     * Returns the details of a linked backend linked to a static site by name
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param options The options parameters.
     */
    getLinkedBackend(resourceGroupName, name, linkedBackendName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, linkedBackendName, options }, getLinkedBackendOperationSpec);
    }
    /**
     * Link backend to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the backend to link to the static site
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginLinkBackend(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    linkedBackendName,
                    staticSiteLinkedBackendEnvelope,
                    options,
                },
                spec: linkBackendOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Link backend to a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the backend to link to the static site
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginLinkBackendAndWait(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginLinkBackend(resourceGroupName, name, linkedBackendName, staticSiteLinkedBackendEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Unlink a backend from a static site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param linkedBackendName Name of the backend linked to the static site
     * @param options The options parameters.
     */
    unlinkBackend(resourceGroupName, name, linkedBackendName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, linkedBackendName, options }, unlinkBackendOperationSpec);
    }
    /**
     * Returns the details of a linked backend linked to a static site build by name
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the linked backend that should be retrieved
     * @param options The options parameters.
     */
    getLinkedBackendForBuild(resourceGroupName, name, environmentName, linkedBackendName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, linkedBackendName, options }, getLinkedBackendForBuildOperationSpec);
    }
    /**
     * Link backend to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the backend to link to the static site
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginLinkBackendToBuild(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    environmentName,
                    linkedBackendName,
                    staticSiteLinkedBackendEnvelope,
                    options,
                },
                spec: linkBackendToBuildOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Link backend to a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the backend to link to the static site
     * @param staticSiteLinkedBackendEnvelope A JSON representation of the linked backend request
     *                                        properties
     * @param options The options parameters.
     */
    beginLinkBackendToBuildAndWait(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginLinkBackendToBuild(resourceGroupName, name, environmentName, linkedBackendName, staticSiteLinkedBackendEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Unlink a backend from a static site build
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param linkedBackendName Name of the backend linked to the static site
     * @param options The options parameters.
     */
    unlinkBackendFromBuild(resourceGroupName, name, environmentName, linkedBackendName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, linkedBackendName, options }, unlinkBackendFromBuildOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$9);
    }
    /**
     * GetStaticSitesByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the GetStaticSitesByResourceGroup
     *                 method.
     * @param options The options parameters.
     */
    _getStaticSitesByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, getStaticSitesByResourceGroupNextOperationSpec);
    }
    /**
     * ListStaticSiteUsersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param authprovider The auth provider for the users.
     * @param nextLink The nextLink from the previous successful call to the ListStaticSiteUsers method.
     * @param options The options parameters.
     */
    _listStaticSiteUsersNext(resourceGroupName, name, authprovider, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, authprovider, nextLink, options }, listStaticSiteUsersNextOperationSpec);
    }
    /**
     * GetStaticSiteBuildsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param nextLink The nextLink from the previous successful call to the GetStaticSiteBuilds method.
     * @param options The options parameters.
     */
    _getStaticSiteBuildsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getStaticSiteBuildsNextOperationSpec);
    }
    /**
     * GetBuildDatabaseConnectionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param nextLink The nextLink from the previous successful call to the GetBuildDatabaseConnections
     *                 method.
     * @param options The options parameters.
     */
    _getBuildDatabaseConnectionsNext(resourceGroupName, name, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, nextLink, options }, getBuildDatabaseConnectionsNextOperationSpec);
    }
    /**
     * ListStaticSiteBuildFunctionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param nextLink The nextLink from the previous successful call to the ListStaticSiteBuildFunctions
     *                 method.
     * @param options The options parameters.
     */
    _listStaticSiteBuildFunctionsNext(resourceGroupName, name, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, nextLink, options }, listStaticSiteBuildFunctionsNextOperationSpec);
    }
    /**
     * GetBuildDatabaseConnectionsWithDetailsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetBuildDatabaseConnectionsWithDetails method.
     * @param options The options parameters.
     */
    _getBuildDatabaseConnectionsWithDetailsNext(resourceGroupName, name, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, nextLink, options }, getBuildDatabaseConnectionsWithDetailsNextOperationSpec);
    }
    /**
     * GetUserProvidedFunctionAppsForStaticSiteBuildNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param environmentName The stage site identifier.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetUserProvidedFunctionAppsForStaticSiteBuild method.
     * @param options The options parameters.
     */
    _getUserProvidedFunctionAppsForStaticSiteBuildNext(resourceGroupName, name, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, nextLink, options }, getUserProvidedFunctionAppsForStaticSiteBuildNextOperationSpec);
    }
    /**
     * ListBasicAuthNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param nextLink The nextLink from the previous successful call to the ListBasicAuth method.
     * @param options The options parameters.
     */
    _listBasicAuthNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listBasicAuthNextOperationSpec);
    }
    /**
     * ListStaticSiteCustomDomainsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site resource to search in.
     * @param nextLink The nextLink from the previous successful call to the ListStaticSiteCustomDomains
     *                 method.
     * @param options The options parameters.
     */
    _listStaticSiteCustomDomainsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listStaticSiteCustomDomainsNextOperationSpec);
    }
    /**
     * GetDatabaseConnectionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param nextLink The nextLink from the previous successful call to the GetDatabaseConnections method.
     * @param options The options parameters.
     */
    _getDatabaseConnectionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getDatabaseConnectionsNextOperationSpec);
    }
    /**
     * ListStaticSiteFunctionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param nextLink The nextLink from the previous successful call to the ListStaticSiteFunctions
     *                 method.
     * @param options The options parameters.
     */
    _listStaticSiteFunctionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listStaticSiteFunctionsNextOperationSpec);
    }
    /**
     * GetPrivateEndpointConnectionListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetPrivateEndpointConnectionList method.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getPrivateEndpointConnectionListNextOperationSpec$1);
    }
    /**
     * GetDatabaseConnectionsWithDetailsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetDatabaseConnectionsWithDetails method.
     * @param options The options parameters.
     */
    _getDatabaseConnectionsWithDetailsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getDatabaseConnectionsWithDetailsNextOperationSpec);
    }
    /**
     * GetUserProvidedFunctionAppsForStaticSiteNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetUserProvidedFunctionAppsForStaticSite method.
     * @param options The options parameters.
     */
    _getUserProvidedFunctionAppsForStaticSiteNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getUserProvidedFunctionAppsForStaticSiteNextOperationSpec);
    }
    /**
     * GetLinkedBackendsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param nextLink The nextLink from the previous successful call to the GetLinkedBackends method.
     * @param options The options parameters.
     */
    _getLinkedBackendsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getLinkedBackendsNextOperationSpec);
    }
    /**
     * GetLinkedBackendsForBuildNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the static site
     * @param environmentName The stage site identifier
     * @param nextLink The nextLink from the previous successful call to the GetLinkedBackendsForBuild
     *                 method.
     * @param options The options parameters.
     */
    _getLinkedBackendsForBuildNext(resourceGroupName, name, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, environmentName, nextLink, options }, getLinkedBackendsForBuildNextOperationSpec);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const previewWorkflowOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/previewStaticSiteWorkflowFile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StaticSitesWorkflowPreview,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSitesWorkflowPreviewRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/staticSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getStaticSitesByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const createOrUpdateStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteARMResource,
        },
        201: {
            bodyMapper: StaticSiteARMResource,
        },
        202: {
            bodyMapper: StaticSiteARMResource,
        },
        204: {
            bodyMapper: StaticSiteARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const deleteStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const updateStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: StaticSiteARMResource,
        },
        202: {
            bodyMapper: StaticSiteARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const listStaticSiteUsersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/authproviders/{authprovider}/listUsers",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StaticSiteUserCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        authprovider,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const deleteStaticSiteUserOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/authproviders/{authprovider}/users/{userid}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        authprovider,
        userid,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const updateStaticSiteUserOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/authproviders/{authprovider}/users/{userid}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: StaticSiteUserARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteUserEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        authprovider,
        userid,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const getStaticSiteBuildsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteBuildCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteBuildARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const deleteStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const createOrUpdateStaticSiteBuildAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/config/appsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const createOrUpdateStaticSiteBuildFunctionAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/config/functionappsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const getBuildDatabaseConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/databaseConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName2,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getBuildDatabaseConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/databaseConnections/{databaseConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName2,
        databaseConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const createOrUpdateBuildDatabaseConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/databaseConnections/{databaseConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabaseConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: databaseConnectionRequestEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName2,
        databaseConnectionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const deleteBuildDatabaseConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/databaseConnections/{databaseConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName2,
        databaseConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const updateBuildDatabaseConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/databaseConnections/{databaseConnectionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DatabaseConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: databaseConnectionRequestEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName2,
        databaseConnectionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const getBuildDatabaseConnectionWithDetailsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/databaseConnections/{databaseConnectionName}/show",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatabaseConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName2,
        databaseConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteBuildFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/functions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteFunctionOverviewCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteBuildAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/listAppSettings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteBuildFunctionAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/listFunctionAppSettings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getBuildDatabaseConnectionsWithDetailsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/showDatabaseConnections",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatabaseConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName2,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getUserProvidedFunctionAppsForStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppsCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getUserProvidedFunctionAppForStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        functionAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const registerUserProvidedFunctionAppWithStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        201: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        202: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        204: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteUserProvidedFunctionEnvelope,
    queryParameters: [apiVersion, isForced],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        functionAppName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const detachUserProvidedFunctionAppFromStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        functionAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const createZipDeploymentForStaticSiteBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/zipdeploy",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteZipDeploymentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const createOrUpdateStaticSiteAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/config/appsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const listBasicAuthOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/basicAuth",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteBasicAuthPropertiesCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getBasicAuthOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/basicAuth/{basicAuthName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteBasicAuthPropertiesARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        basicAuthName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const createOrUpdateBasicAuthOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/basicAuth/{basicAuthName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteBasicAuthPropertiesARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: basicAuthEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        basicAuthName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const createOrUpdateStaticSiteFunctionAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/config/functionappsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const createUserRolesInvitationLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/createUserInvitation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StaticSiteUserInvitationResponseResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteUserRolesInvitationEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const listStaticSiteCustomDomainsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCustomDomainOverviewCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getStaticSiteCustomDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const createOrUpdateStaticSiteCustomDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource,
        },
        201: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource,
        },
        202: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource,
        },
        204: {
            bodyMapper: StaticSiteCustomDomainOverviewARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteCustomDomainRequestPropertiesEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const deleteStaticSiteCustomDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const validateCustomDomainCanBeAddedToStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/customDomains/{domainName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteCustomDomainRequestPropertiesEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const getDatabaseConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/databaseConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getDatabaseConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/databaseConnections/{databaseConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        databaseConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const createOrUpdateDatabaseConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/databaseConnections/{databaseConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabaseConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: databaseConnectionRequestEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        databaseConnectionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const deleteDatabaseConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/databaseConnections/{databaseConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        databaseConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const updateDatabaseConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/databaseConnections/{databaseConnectionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DatabaseConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: databaseConnectionRequestEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        databaseConnectionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const getDatabaseConnectionWithDetailsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/databaseConnections/{databaseConnectionName}/show",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatabaseConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        databaseConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const detachStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/detach",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/functions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteFunctionOverviewCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listAppSettings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteConfiguredRolesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listConfiguredRoles",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringList,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteFunctionAppSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listFunctionAppSettings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getPrivateEndpointConnectionListOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getPrivateEndpointConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const approveOrRejectPrivateEndpointConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        201: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        202: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        204: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: privateEndpointWrapper,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const deletePrivateEndpointConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getPrivateLinkResourcesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesWrapper,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const resetStaticSiteApiKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/resetapikey",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: resetPropertiesEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const getDatabaseConnectionsWithDetailsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/showDatabaseConnections",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatabaseConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getUserProvidedFunctionAppsForStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppsCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getUserProvidedFunctionAppForStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const registerUserProvidedFunctionAppWithStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        201: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        202: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        204: {
            bodyMapper: StaticSiteUserProvidedFunctionAppARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteUserProvidedFunctionEnvelope,
    queryParameters: [apiVersion, isForced],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionAppName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const detachUserProvidedFunctionAppFromStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/userProvidedFunctionApps/{functionAppName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionAppName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const createZipDeploymentForStaticSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/zipdeploy",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteZipDeploymentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const validateBackendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends/{linkedBackendName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteLinkedBackendEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        linkedBackendName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const validateBackendForBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends/{linkedBackendName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteLinkedBackendEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        linkedBackendName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const getLinkedBackendsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendsCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getLinkedBackendsForBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendsCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getLinkedBackendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends/{linkedBackendName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        linkedBackendName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const linkBackendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends/{linkedBackendName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        201: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        202: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        204: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteLinkedBackendEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        linkedBackendName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const unlinkBackendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/linkedBackends/{linkedBackendName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, isCleaningAuthConfig],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        linkedBackendName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getLinkedBackendForBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends/{linkedBackendName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        linkedBackendName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const linkBackendToBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends/{linkedBackendName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        201: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        202: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        204: {
            bodyMapper: StaticSiteLinkedBackendARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: staticSiteLinkedBackendEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        linkedBackendName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b,
};
const unlinkBackendFromBuildOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/staticSites/{name}/builds/{environmentName}/linkedBackends/{linkedBackendName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, isCleaningAuthConfig],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        environmentName1,
        linkedBackendName,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getStaticSitesByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteUsersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        authprovider,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getStaticSiteBuildsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteBuildCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getBuildDatabaseConnectionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        environmentName2,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteBuildFunctionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteFunctionOverviewCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getBuildDatabaseConnectionsWithDetailsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        environmentName2,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getUserProvidedFunctionAppsForStaticSiteBuildNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppsCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listBasicAuthNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteBasicAuthPropertiesCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteCustomDomainsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteCustomDomainOverviewCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getDatabaseConnectionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const listStaticSiteFunctionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteFunctionOverviewCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getPrivateEndpointConnectionListNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getDatabaseConnectionsWithDetailsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getUserProvidedFunctionAppsForStaticSiteNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteUserProvidedFunctionAppsCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getLinkedBackendsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendsCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};
const getLinkedBackendsForBuildNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticSiteLinkedBackendsCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        environmentName1,
    ],
    headerParameters: [accept],
    serializer: serializer$b,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WebApps operations. */
class WebAppsImpl {
    /**
     * Initialize a new instance of the class WebApps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Description for Get all apps for a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Gets all web, mobile, and API apps in the specified resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listBackups(resourceGroupName, name, options) {
        const iter = this.listBackupsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBackupsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listBackupsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBackupsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBackups(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBackupsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBackupsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBackupsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBackupsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listBasicPublishingCredentialsPolicies(resourceGroupName, name, options) {
        const iter = this.listBasicPublishingCredentialsPoliciesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBasicPublishingCredentialsPoliciesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listBasicPublishingCredentialsPoliciesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicPublishingCredentialsPoliciesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBasicPublishingCredentialsPolicies(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBasicPublishingCredentialsPoliciesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBasicPublishingCredentialsPoliciesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicPublishingCredentialsPoliciesPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBasicPublishingCredentialsPoliciesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for List the configurations of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listConfigurations(resourceGroupName, name, options) {
        const iter = this.listConfigurationsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listConfigurationsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listConfigurationsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listConfigurations(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listConfigurationsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listConfigurationsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listConfigurationsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listAppSettingsKeyVaultReferences(resourceGroupName, name, options) {
        const iter = this.getAppSettingsKeyVaultReferencesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getAppSettingsKeyVaultReferencesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getAppSettingsKeyVaultReferencesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getAppSettingsKeyVaultReferencesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getAppSettingsKeyVaultReferences(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getAppSettingsKeyVaultReferencesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getAppSettingsKeyVaultReferencesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getAppSettingsKeyVaultReferencesPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getAppSettingsKeyVaultReferencesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSiteConnectionStringKeyVaultReferences(resourceGroupName, name, options) {
        const iter = this.getSiteConnectionStringKeyVaultReferencesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getSiteConnectionStringKeyVaultReferencesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getSiteConnectionStringKeyVaultReferencesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getSiteConnectionStringKeyVaultReferencesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getSiteConnectionStringKeyVaultReferences(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getSiteConnectionStringKeyVaultReferencesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getSiteConnectionStringKeyVaultReferencesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getSiteConnectionStringKeyVaultReferencesPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getSiteConnectionStringKeyVaultReferencesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Gets a list of web app configuration snapshots identifiers. Each element of the list
     * contains a timestamp and the ID of the snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listConfigurationSnapshotInfo(resourceGroupName, name, options) {
        const iter = this.listConfigurationSnapshotInfoPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listConfigurationSnapshotInfoPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listConfigurationSnapshotInfoPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSnapshotInfoPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listConfigurationSnapshotInfo(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listConfigurationSnapshotInfoNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listConfigurationSnapshotInfoPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSnapshotInfoPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listConfigurationSnapshotInfoPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Description for List continuous web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listContinuousWebJobs(resourceGroupName, name, options) {
        const iter = this.listContinuousWebJobsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listContinuousWebJobsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listContinuousWebJobsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listContinuousWebJobsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listContinuousWebJobs(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listContinuousWebJobsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listContinuousWebJobsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listContinuousWebJobsPagingAll_1() {
            var _a, e_9, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listContinuousWebJobsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * List deployment statuses for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listProductionSiteDeploymentStatuses(resourceGroupName, name, options) {
        const iter = this.listProductionSiteDeploymentStatusesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listProductionSiteDeploymentStatusesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listProductionSiteDeploymentStatusesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listProductionSiteDeploymentStatusesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listProductionSiteDeploymentStatuses(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listProductionSiteDeploymentStatusesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listProductionSiteDeploymentStatusesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProductionSiteDeploymentStatusesPagingAll_1() {
            var _a, e_10, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listProductionSiteDeploymentStatusesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
    }
    /**
     * Description for List deployments for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listDeployments(resourceGroupName, name, options) {
        const iter = this.listDeploymentsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDeploymentsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listDeploymentsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDeploymentsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDeployments(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDeploymentsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDeploymentsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeploymentsPagingAll_1() {
            var _a, e_11, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDeploymentsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_11) throw e_11.error; }
            }
        });
    }
    /**
     * Description for Lists ownership identifiers for domain associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listDomainOwnershipIdentifiers(resourceGroupName, name, options) {
        const iter = this.listDomainOwnershipIdentifiersPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDomainOwnershipIdentifiersPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listDomainOwnershipIdentifiersPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDomainOwnershipIdentifiersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDomainOwnershipIdentifiers(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDomainOwnershipIdentifiersNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDomainOwnershipIdentifiersPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDomainOwnershipIdentifiersPagingAll_1() {
            var _a, e_12, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDomainOwnershipIdentifiersPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_12) throw e_12.error; }
            }
        });
    }
    /**
     * Description for List the functions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listFunctions(resourceGroupName, name, options) {
        const iter = this.listFunctionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listFunctionsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listFunctionsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listFunctionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listFunctions(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listFunctionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listFunctionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listFunctionsPagingAll_1() {
            var _a, e_13, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listFunctionsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_13) throw e_13.error; }
            }
        });
    }
    /**
     * Description for Get hostname bindings for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listHostNameBindings(resourceGroupName, name, options) {
        const iter = this.listHostNameBindingsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listHostNameBindingsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listHostNameBindingsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listHostNameBindingsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listHostNameBindings(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listHostNameBindingsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listHostNameBindingsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHostNameBindingsPagingAll_1() {
            var _a, e_14, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listHostNameBindingsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_14) throw e_14.error; }
            }
        });
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listInstanceIdentifiers(resourceGroupName, name, options) {
        const iter = this.listInstanceIdentifiersPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceIdentifiersPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listInstanceIdentifiersPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceIdentifiersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceIdentifiers(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceIdentifiersNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceIdentifiersPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceIdentifiersPagingAll_1() {
            var _a, e_15, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceIdentifiersPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_15) throw e_15.error; }
            }
        });
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcesses(resourceGroupName, name, instanceId, options) {
        const iter = this.listInstanceProcessesPagingAll(resourceGroupName, name, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceProcessesPagingPage(resourceGroupName, name, instanceId, options, settings);
            },
        };
    }
    listInstanceProcessesPagingPage(resourceGroupName, name, instanceId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceProcesses(resourceGroupName, name, instanceId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessesNext(resourceGroupName, name, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceProcessesPagingAll(resourceGroupName, name, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessesPagingAll_1() {
            var _a, e_16, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceProcessesPagingPage(resourceGroupName, name, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_16) throw e_16.error; }
            }
        });
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessModules(resourceGroupName, name, processId, instanceId, options) {
        const iter = this.listInstanceProcessModulesPagingAll(resourceGroupName, name, processId, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceProcessModulesPagingPage(resourceGroupName, name, processId, instanceId, options, settings);
            },
        };
    }
    listInstanceProcessModulesPagingPage(resourceGroupName, name, processId, instanceId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessModulesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessModules(resourceGroupName, name, processId, instanceId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessModulesNext(resourceGroupName, name, processId, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceProcessModulesPagingAll(resourceGroupName, name, processId, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessModulesPagingAll_1() {
            var _a, e_17, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceProcessModulesPagingPage(resourceGroupName, name, processId, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_17) throw e_17.error; }
            }
        });
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessThreads(resourceGroupName, name, processId, instanceId, options) {
        const iter = this.listInstanceProcessThreadsPagingAll(resourceGroupName, name, processId, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceProcessThreadsPagingPage(resourceGroupName, name, processId, instanceId, options, settings);
            },
        };
    }
    listInstanceProcessThreadsPagingPage(resourceGroupName, name, processId, instanceId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessThreadsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessThreads(resourceGroupName, name, processId, instanceId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessThreadsNext(resourceGroupName, name, processId, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceProcessThreadsPagingAll(resourceGroupName, name, processId, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessThreadsPagingAll_1() {
            var _a, e_18, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceProcessThreadsPagingPage(resourceGroupName, name, processId, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_18) throw e_18.error; }
            }
        });
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSiteBackups(resourceGroupName, name, options) {
        const iter = this.listSiteBackupsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteBackupsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listSiteBackupsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteBackupsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteBackups(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteBackupsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteBackupsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteBackupsPagingAll_1() {
            var _a, e_19, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteBackupsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_19_1) { e_19 = { error: e_19_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_19) throw e_19.error; }
            }
        });
    }
    /**
     * Description for Gets perfmon counters for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    listPerfMonCounters(resourceGroupName, name, options) {
        const iter = this.listPerfMonCountersPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPerfMonCountersPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listPerfMonCountersPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPerfMonCountersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listPerfMonCounters(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listPerfMonCountersNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPerfMonCountersPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPerfMonCountersPagingAll_1() {
            var _a, e_20, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPerfMonCountersPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_20_1) { e_20 = { error: e_20_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_20) throw e_20.error; }
            }
        });
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param options The options parameters.
     */
    listPrivateEndpointConnectionList(resourceGroupName, name, options) {
        const iter = this.getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionList(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionListNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getPrivateEndpointConnectionListPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListPagingAll_1() {
            var _a, e_21, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getPrivateEndpointConnectionListPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_21_1) { e_21 = { error: e_21_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_21) throw e_21.error; }
            }
        });
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listProcesses(resourceGroupName, name, options) {
        const iter = this.listProcessesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listProcessesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listProcessesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listProcesses(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listProcessesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessesPagingAll_1() {
            var _a, e_22, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listProcessesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_22_1) { e_22 = { error: e_22_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_22) throw e_22.error; }
            }
        });
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    listProcessModules(resourceGroupName, name, processId, options) {
        const iter = this.listProcessModulesPagingAll(resourceGroupName, name, processId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listProcessModulesPagingPage(resourceGroupName, name, processId, options, settings);
            },
        };
    }
    listProcessModulesPagingPage(resourceGroupName, name, processId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessModulesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listProcessModules(resourceGroupName, name, processId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessModulesNext(resourceGroupName, name, processId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listProcessModulesPagingAll(resourceGroupName, name, processId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessModulesPagingAll_1() {
            var _a, e_23, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listProcessModulesPagingPage(resourceGroupName, name, processId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_23_1) { e_23 = { error: e_23_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_23) throw e_23.error; }
            }
        });
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    listProcessThreads(resourceGroupName, name, processId, options) {
        const iter = this.listProcessThreadsPagingAll(resourceGroupName, name, processId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listProcessThreadsPagingPage(resourceGroupName, name, processId, options, settings);
            },
        };
    }
    listProcessThreadsPagingPage(resourceGroupName, name, processId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessThreadsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listProcessThreads(resourceGroupName, name, processId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessThreadsNext(resourceGroupName, name, processId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listProcessThreadsPagingAll(resourceGroupName, name, processId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessThreadsPagingAll_1() {
            var _a, e_24, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listProcessThreadsPagingPage(resourceGroupName, name, processId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_24_1) { e_24 = { error: e_24_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_24) throw e_24.error; }
            }
        });
    }
    /**
     * Description for Get public certificates for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listPublicCertificates(resourceGroupName, name, options) {
        const iter = this.listPublicCertificatesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPublicCertificatesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listPublicCertificatesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicCertificatesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listPublicCertificates(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listPublicCertificatesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPublicCertificatesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicCertificatesPagingAll_1() {
            var _a, e_25, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPublicCertificatesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_25_1) { e_25 = { error: e_25_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_25) throw e_25.error; }
            }
        });
    }
    /**
     * Lists all the site containers of a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSiteContainers(resourceGroupName, name, options) {
        const iter = this.listSiteContainersPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteContainersPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listSiteContainersPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteContainersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteContainers(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteContainersNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteContainersPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteContainersPagingAll_1() {
            var _a, e_26, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteContainersPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_26_1) { e_26 = { error: e_26_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_26) throw e_26.error; }
            }
        });
    }
    /**
     * Description for Get list of siteextensions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listSiteExtensions(resourceGroupName, name, options) {
        const iter = this.listSiteExtensionsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteExtensionsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listSiteExtensionsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteExtensionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteExtensions(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteExtensionsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteExtensionsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteExtensionsPagingAll_1() {
            var _a, e_27, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteExtensionsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_27_1) { e_27 = { error: e_27_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_27) throw e_27.error; }
            }
        });
    }
    /**
     * Description for Gets an app's deployment slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSlots(resourceGroupName, name, options) {
        const iter = this.listSlotsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSlotsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listSlotsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSlots(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSlotsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSlotsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotsPagingAll_1() {
            var _a, e_28, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSlotsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_28_1) { e_28 = { error: e_28_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_28) throw e_28.error; }
            }
        });
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param options The options parameters.
     */
    listBackupsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listBackupsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBackupsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listBackupsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBackupsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBackupsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBackupsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBackupsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBackupsSlotPagingAll_1() {
            var _a, e_29, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBackupsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_29_1) { e_29 = { error: e_29_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_29) throw e_29.error; }
            }
        });
    }
    /**
     * Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    listBasicPublishingCredentialsPoliciesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listBasicPublishingCredentialsPoliciesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBasicPublishingCredentialsPoliciesSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listBasicPublishingCredentialsPoliciesSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicPublishingCredentialsPoliciesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBasicPublishingCredentialsPoliciesSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBasicPublishingCredentialsPoliciesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBasicPublishingCredentialsPoliciesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBasicPublishingCredentialsPoliciesSlotPagingAll_1() {
            var _a, e_30, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBasicPublishingCredentialsPoliciesSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_30_1) { e_30 = { error: e_30_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_30) throw e_30.error; }
            }
        });
    }
    /**
     * Description for List the configurations of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    listConfigurationsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listConfigurationsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listConfigurationsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listConfigurationsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listConfigurationsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listConfigurationsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listConfigurationsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationsSlotPagingAll_1() {
            var _a, e_31, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listConfigurationsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_31_1) { e_31 = { error: e_31_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_31) throw e_31.error; }
            }
        });
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    listAppSettingsKeyVaultReferencesSlot(resourceGroupName, name, slot, options) {
        const iter = this.getAppSettingsKeyVaultReferencesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getAppSettingsKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    getAppSettingsKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getAppSettingsKeyVaultReferencesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getAppSettingsKeyVaultReferencesSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getAppSettingsKeyVaultReferencesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getAppSettingsKeyVaultReferencesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* getAppSettingsKeyVaultReferencesSlotPagingAll_1() {
            var _a, e_32, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getAppSettingsKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_32_1) { e_32 = { error: e_32_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_32) throw e_32.error; }
            }
        });
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    listSiteConnectionStringKeyVaultReferencesSlot(resourceGroupName, name, slot, options) {
        const iter = this.getSiteConnectionStringKeyVaultReferencesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getSiteConnectionStringKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    getSiteConnectionStringKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getSiteConnectionStringKeyVaultReferencesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getSiteConnectionStringKeyVaultReferencesSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getSiteConnectionStringKeyVaultReferencesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getSiteConnectionStringKeyVaultReferencesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* getSiteConnectionStringKeyVaultReferencesSlotPagingAll_1() {
            var _a, e_33, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getSiteConnectionStringKeyVaultReferencesSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_33_1) { e_33 = { error: e_33_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_33) throw e_33.error; }
            }
        });
    }
    /**
     * Description for Gets a list of web app configuration snapshots identifiers. Each element of the list
     * contains a timestamp and the ID of the snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options) {
        const iter = this.listConfigurationSnapshotInfoSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listConfigurationSnapshotInfoSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listConfigurationSnapshotInfoSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSnapshotInfoSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listConfigurationSnapshotInfoSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listConfigurationSnapshotInfoSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSnapshotInfoSlotPagingAll_1() {
            var _a, e_34, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listConfigurationSnapshotInfoSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_34_1) { e_34 = { error: e_34_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_34) throw e_34.error; }
            }
        });
    }
    /**
     * Description for List continuous web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    listContinuousWebJobsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listContinuousWebJobsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listContinuousWebJobsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listContinuousWebJobsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listContinuousWebJobsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listContinuousWebJobsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listContinuousWebJobsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listContinuousWebJobsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listContinuousWebJobsSlotPagingAll_1() {
            var _a, e_35, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listContinuousWebJobsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_35_1) { e_35 = { error: e_35_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_35) throw e_35.error; }
            }
        });
    }
    /**
     * List deployment statuses for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param options The options parameters.
     */
    listSlotSiteDeploymentStatusesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listSlotSiteDeploymentStatusesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSlotSiteDeploymentStatusesSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listSlotSiteDeploymentStatusesSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotSiteDeploymentStatusesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSlotSiteDeploymentStatusesSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSlotSiteDeploymentStatusesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSlotSiteDeploymentStatusesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotSiteDeploymentStatusesSlotPagingAll_1() {
            var _a, e_36, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSlotSiteDeploymentStatusesSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_36_1) { e_36 = { error: e_36_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_36) throw e_36.error; }
            }
        });
    }
    /**
     * Description for List deployments for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listDeploymentsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listDeploymentsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDeploymentsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listDeploymentsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDeploymentsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDeploymentsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDeploymentsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDeploymentsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeploymentsSlotPagingAll_1() {
            var _a, e_37, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDeploymentsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_37_1) { e_37 = { error: e_37_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_37) throw e_37.error; }
            }
        });
    }
    /**
     * Description for Lists ownership identifiers for domain associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param options The options parameters.
     */
    listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options) {
        const iter = this.listDomainOwnershipIdentifiersSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDomainOwnershipIdentifiersSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listDomainOwnershipIdentifiersSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDomainOwnershipIdentifiersSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDomainOwnershipIdentifiersSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDomainOwnershipIdentifiersSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDomainOwnershipIdentifiersSlotPagingAll_1() {
            var _a, e_38, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDomainOwnershipIdentifiersSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_38_1) { e_38 = { error: e_38_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_38) throw e_38.error; }
            }
        });
    }
    /**
     * Description for List the functions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listInstanceFunctionsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listInstanceFunctionsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceFunctionsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listInstanceFunctionsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceFunctionsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceFunctionsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceFunctionsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceFunctionsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceFunctionsSlotPagingAll_1() {
            var _a, e_39, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceFunctionsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_39_1) { e_39 = { error: e_39_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_39) throw e_39.error; }
            }
        });
    }
    /**
     * Description for Get hostname bindings for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param options The options parameters.
     */
    listHostNameBindingsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listHostNameBindingsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listHostNameBindingsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listHostNameBindingsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listHostNameBindingsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listHostNameBindingsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listHostNameBindingsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listHostNameBindingsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHostNameBindingsSlotPagingAll_1() {
            var _a, e_40, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listHostNameBindingsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_40_1) { e_40 = { error: e_40_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_40) throw e_40.error; }
            }
        });
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production
     *             slot instances.
     * @param options The options parameters.
     */
    listInstanceIdentifiersSlot(resourceGroupName, name, slot, options) {
        const iter = this.listInstanceIdentifiersSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceIdentifiersSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listInstanceIdentifiersSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceIdentifiersSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceIdentifiersSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceIdentifiersSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceIdentifiersSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceIdentifiersSlotPagingAll_1() {
            var _a, e_41, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceIdentifiersSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_41_1) { e_41 = { error: e_41_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_41) throw e_41.error; }
            }
        });
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessesSlot(resourceGroupName, name, slot, instanceId, options) {
        const iter = this.listInstanceProcessesSlotPagingAll(resourceGroupName, name, slot, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceProcessesSlotPagingPage(resourceGroupName, name, slot, instanceId, options, settings);
            },
        };
    }
    listInstanceProcessesSlotPagingPage(resourceGroupName, name, slot, instanceId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessesSlot(resourceGroupName, name, slot, instanceId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessesSlotNext(resourceGroupName, name, slot, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceProcessesSlotPagingAll(resourceGroupName, name, slot, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessesSlotPagingAll_1() {
            var _a, e_42, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceProcessesSlotPagingPage(resourceGroupName, name, slot, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_42_1) { e_42 = { error: e_42_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_42) throw e_42.error; }
            }
        });
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessModulesSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        const iter = this.listInstanceProcessModulesSlotPagingAll(resourceGroupName, name, processId, slot, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options, settings);
            },
        };
    }
    listInstanceProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessModulesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessModulesSlot(resourceGroupName, name, processId, slot, instanceId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessModulesSlotNext(resourceGroupName, name, processId, slot, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceProcessModulesSlotPagingAll(resourceGroupName, name, processId, slot, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessModulesSlotPagingAll_1() {
            var _a, e_43, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_43_1) { e_43 = { error: e_43_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_43) throw e_43.error; }
            }
        });
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    listInstanceProcessThreadsSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        const iter = this.listInstanceProcessThreadsSlotPagingAll(resourceGroupName, name, processId, slot, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options, settings);
            },
        };
    }
    listInstanceProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessThreadsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessThreadsSlot(resourceGroupName, name, processId, slot, instanceId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceProcessThreadsSlotNext(resourceGroupName, name, processId, slot, instanceId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceProcessThreadsSlotPagingAll(resourceGroupName, name, processId, slot, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceProcessThreadsSlotPagingAll_1() {
            var _a, e_44, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_44_1) { e_44 = { error: e_44_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_44) throw e_44.error; }
            }
        });
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param options The options parameters.
     */
    listSiteBackupsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listSiteBackupsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteBackupsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listSiteBackupsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteBackupsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteBackupsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteBackupsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteBackupsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteBackupsSlotPagingAll_1() {
            var _a, e_45, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteBackupsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_45_1) { e_45 = { error: e_45_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_45) throw e_45.error; }
            }
        });
    }
    /**
     * Description for Gets perfmon counters for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    listPerfMonCountersSlot(resourceGroupName, name, slot, options) {
        const iter = this.listPerfMonCountersSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPerfMonCountersSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listPerfMonCountersSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPerfMonCountersSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listPerfMonCountersSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listPerfMonCountersSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPerfMonCountersSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPerfMonCountersSlotPagingAll_1() {
            var _a, e_46, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPerfMonCountersSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_46_1) { e_46 = { error: e_46_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_46) throw e_46.error; }
            }
        });
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param slot Name of the site deployment slot.
     * @param options The options parameters.
     */
    listPrivateEndpointConnectionListSlot(resourceGroupName, name, slot, options) {
        const iter = this.getPrivateEndpointConnectionListSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getPrivateEndpointConnectionListSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    getPrivateEndpointConnectionListSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionListSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getPrivateEndpointConnectionListSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getPrivateEndpointConnectionListSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPrivateEndpointConnectionListSlotPagingAll_1() {
            var _a, e_47, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getPrivateEndpointConnectionListSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_47_1) { e_47 = { error: e_47_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_47) throw e_47.error; }
            }
        });
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listProcessesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listProcessesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listProcessesSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listProcessesSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listProcessesSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listProcessesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessesSlotPagingAll_1() {
            var _a, e_48, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listProcessesSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_48_1) { e_48 = { error: e_48_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_48) throw e_48.error; }
            }
        });
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listProcessModulesSlot(resourceGroupName, name, processId, slot, options) {
        const iter = this.listProcessModulesSlotPagingAll(resourceGroupName, name, processId, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, options, settings);
            },
        };
    }
    listProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessModulesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listProcessModulesSlot(resourceGroupName, name, processId, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessModulesSlotNext(resourceGroupName, name, processId, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listProcessModulesSlotPagingAll(resourceGroupName, name, processId, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessModulesSlotPagingAll_1() {
            var _a, e_49, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listProcessModulesSlotPagingPage(resourceGroupName, name, processId, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_49_1) { e_49 = { error: e_49_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_49) throw e_49.error; }
            }
        });
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listProcessThreadsSlot(resourceGroupName, name, processId, slot, options) {
        const iter = this.listProcessThreadsSlotPagingAll(resourceGroupName, name, processId, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, options, settings);
            },
        };
    }
    listProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessThreadsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listProcessThreadsSlot(resourceGroupName, name, processId, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listProcessThreadsSlotNext(resourceGroupName, name, processId, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listProcessThreadsSlotPagingAll(resourceGroupName, name, processId, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listProcessThreadsSlotPagingAll_1() {
            var _a, e_50, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listProcessThreadsSlotPagingPage(resourceGroupName, name, processId, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_50_1) { e_50 = { error: e_50_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_50) throw e_50.error; }
            }
        });
    }
    /**
     * Description for Get public certificates for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param options The options parameters.
     */
    listPublicCertificatesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listPublicCertificatesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPublicCertificatesSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listPublicCertificatesSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicCertificatesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listPublicCertificatesSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listPublicCertificatesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPublicCertificatesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicCertificatesSlotPagingAll_1() {
            var _a, e_51, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPublicCertificatesSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_51_1) { e_51 = { error: e_51_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_51) throw e_51.error; }
            }
        });
    }
    /**
     * Lists all the site containers of a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a list of site
     *             containers for the production slot.
     * @param options The options parameters.
     */
    listSiteContainersSlot(resourceGroupName, name, slot, options) {
        const iter = this.listSiteContainersSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteContainersSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listSiteContainersSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteContainersSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteContainersSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteContainersSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteContainersSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteContainersSlotPagingAll_1() {
            var _a, e_52, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteContainersSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_52_1) { e_52 = { error: e_52_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_52) throw e_52.error; }
            }
        });
    }
    /**
     * Description for Get list of siteextensions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    listSiteExtensionsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listSiteExtensionsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteExtensionsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listSiteExtensionsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteExtensionsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteExtensionsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteExtensionsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteExtensionsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteExtensionsSlotPagingAll_1() {
            var _a, e_53, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteExtensionsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_53_1) { e_53 = { error: e_53_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_53) throw e_53.error; }
            }
        });
    }
    /**
     * Description for Get the difference in configuration settings between two web app slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    listSlotDifferencesSlot(resourceGroupName, name, slot, slotSwapEntity, options) {
        const iter = this.listSlotDifferencesSlotPagingAll(resourceGroupName, name, slot, slotSwapEntity, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSlotDifferencesSlotPagingPage(resourceGroupName, name, slot, slotSwapEntity, options, settings);
            },
        };
    }
    listSlotDifferencesSlotPagingPage(resourceGroupName, name, slot, slotSwapEntity, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotDifferencesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSlotDifferencesSlot(resourceGroupName, name, slot, slotSwapEntity, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSlotDifferencesSlotNext(resourceGroupName, name, slot, slotSwapEntity, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSlotDifferencesSlotPagingAll(resourceGroupName, name, slot, slotSwapEntity, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotDifferencesSlotPagingAll_1() {
            var _a, e_54, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSlotDifferencesSlotPagingPage(resourceGroupName, name, slot, slotSwapEntity, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_54_1) { e_54 = { error: e_54_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_54) throw e_54.error; }
            }
        });
    }
    /**
     * Description for Returns all Snapshots to the user.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param options The options parameters.
     */
    listSnapshotsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listSnapshotsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSnapshotsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listSnapshotsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSnapshotsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSnapshotsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSnapshotsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsSlotPagingAll_1() {
            var _a, e_55, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSnapshotsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_55_1) { e_55 = { error: e_55_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_55) throw e_55.error; }
            }
        });
    }
    /**
     * Description for Returns all Snapshots to the user from DRSecondary endpoint.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param options The options parameters.
     */
    listSnapshotsFromDRSecondarySlot(resourceGroupName, name, slot, options) {
        const iter = this.listSnapshotsFromDRSecondarySlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSnapshotsFromDRSecondarySlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listSnapshotsFromDRSecondarySlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsFromDRSecondarySlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSnapshotsFromDRSecondarySlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSnapshotsFromDRSecondarySlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSnapshotsFromDRSecondarySlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsFromDRSecondarySlotPagingAll_1() {
            var _a, e_56, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSnapshotsFromDRSecondarySlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_56_1) { e_56 = { error: e_56_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_56) throw e_56.error; }
            }
        });
    }
    /**
     * Description for List triggered web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    listTriggeredWebJobsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listTriggeredWebJobsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listTriggeredWebJobsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listTriggeredWebJobsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listTriggeredWebJobsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobsSlotPagingAll_1() {
            var _a, e_57, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listTriggeredWebJobsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_57_1) { e_57 = { error: e_57_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_57) throw e_57.error; }
            }
        });
    }
    /**
     * Description for List a triggered web job's history for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    listTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, slot, options) {
        const iter = this.listTriggeredWebJobHistorySlotPagingAll(resourceGroupName, name, webJobName, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listTriggeredWebJobHistorySlotPagingPage(resourceGroupName, name, webJobName, slot, options, settings);
            },
        };
    }
    listTriggeredWebJobHistorySlotPagingPage(resourceGroupName, name, webJobName, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobHistorySlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobHistorySlotNext(resourceGroupName, name, webJobName, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listTriggeredWebJobHistorySlotPagingAll(resourceGroupName, name, webJobName, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobHistorySlotPagingAll_1() {
            var _a, e_58, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listTriggeredWebJobHistorySlotPagingPage(resourceGroupName, name, webJobName, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_58_1) { e_58 = { error: e_58_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_58) throw e_58.error; }
            }
        });
    }
    /**
     * Description for Gets the quota usage information of an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota
     *             information of the production slot.
     * @param options The options parameters.
     */
    listUsagesSlot(resourceGroupName, name, slot, options) {
        const iter = this.listUsagesSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listUsagesSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listUsagesSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listUsagesSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listUsagesSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listUsagesSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesSlotPagingAll_1() {
            var _a, e_59, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listUsagesSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_59_1) { e_59 = { error: e_59_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_59) throw e_59.error; }
            }
        });
    }
    /**
     * Description for List webjobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listWebJobsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listWebJobsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWebJobsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listWebJobsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWebJobsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWebJobsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWebJobsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWebJobsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebJobsSlotPagingAll_1() {
            var _a, e_60, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWebJobsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_60_1) { e_60 = { error: e_60_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_60) throw e_60.error; }
            }
        });
    }
    /**
     * Description for Get the difference in configuration settings between two web app slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options) {
        const iter = this.listSlotDifferencesFromProductionPagingAll(resourceGroupName, name, slotSwapEntity, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSlotDifferencesFromProductionPagingPage(resourceGroupName, name, slotSwapEntity, options, settings);
            },
        };
    }
    listSlotDifferencesFromProductionPagingPage(resourceGroupName, name, slotSwapEntity, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotDifferencesFromProductionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSlotDifferencesFromProductionNext(resourceGroupName, name, slotSwapEntity, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSlotDifferencesFromProductionPagingAll(resourceGroupName, name, slotSwapEntity, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSlotDifferencesFromProductionPagingAll_1() {
            var _a, e_61, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSlotDifferencesFromProductionPagingPage(resourceGroupName, name, slotSwapEntity, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_61_1) { e_61 = { error: e_61_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_61) throw e_61.error; }
            }
        });
    }
    /**
     * Description for Returns all Snapshots to the user.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param options The options parameters.
     */
    listSnapshots(resourceGroupName, name, options) {
        const iter = this.listSnapshotsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSnapshotsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listSnapshotsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSnapshots(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSnapshotsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSnapshotsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsPagingAll_1() {
            var _a, e_62, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSnapshotsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_62_1) { e_62 = { error: e_62_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_62) throw e_62.error; }
            }
        });
    }
    /**
     * Description for Returns all Snapshots to the user from DRSecondary endpoint.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param options The options parameters.
     */
    listSnapshotsFromDRSecondary(resourceGroupName, name, options) {
        const iter = this.listSnapshotsFromDRSecondaryPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSnapshotsFromDRSecondaryPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listSnapshotsFromDRSecondaryPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsFromDRSecondaryPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSnapshotsFromDRSecondary(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSnapshotsFromDRSecondaryNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSnapshotsFromDRSecondaryPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSnapshotsFromDRSecondaryPagingAll_1() {
            var _a, e_63, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSnapshotsFromDRSecondaryPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_63_1) { e_63 = { error: e_63_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_63) throw e_63.error; }
            }
        });
    }
    /**
     * Description for List triggered web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listTriggeredWebJobs(resourceGroupName, name, options) {
        const iter = this.listTriggeredWebJobsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listTriggeredWebJobsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listTriggeredWebJobsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobs(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listTriggeredWebJobsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobsPagingAll_1() {
            var _a, e_64, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listTriggeredWebJobsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_64_1) { e_64 = { error: e_64_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_64) throw e_64.error; }
            }
        });
    }
    /**
     * Description for List a triggered web job's history for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    listTriggeredWebJobHistory(resourceGroupName, name, webJobName, options) {
        const iter = this.listTriggeredWebJobHistoryPagingAll(resourceGroupName, name, webJobName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listTriggeredWebJobHistoryPagingPage(resourceGroupName, name, webJobName, options, settings);
            },
        };
    }
    listTriggeredWebJobHistoryPagingPage(resourceGroupName, name, webJobName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobHistoryPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobHistory(resourceGroupName, name, webJobName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listTriggeredWebJobHistoryNext(resourceGroupName, name, webJobName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listTriggeredWebJobHistoryPagingAll(resourceGroupName, name, webJobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTriggeredWebJobHistoryPagingAll_1() {
            var _a, e_65, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listTriggeredWebJobHistoryPagingPage(resourceGroupName, name, webJobName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_65_1) { e_65 = { error: e_65_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_65) throw e_65.error; }
            }
        });
    }
    /**
     * Description for Gets the quota usage information of an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, name, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listUsagesPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listUsagesPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listUsages(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listUsagesNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listUsagesPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var _a, e_66, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_66_1) { e_66 = { error: e_66_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_66) throw e_66.error; }
            }
        });
    }
    /**
     * Description for List webjobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listWebJobs(resourceGroupName, name, options) {
        const iter = this.listWebJobsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWebJobsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listWebJobsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWebJobsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWebJobs(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWebJobsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWebJobsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWebJobsPagingAll_1() {
            var _a, e_67, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWebJobsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_67_1) { e_67 = { error: e_67_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_67) throw e_67.error; }
            }
        });
    }
    /**
     * List the workflows for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listInstanceWorkflowsSlot(resourceGroupName, name, slot, options) {
        const iter = this.listInstanceWorkflowsSlotPagingAll(resourceGroupName, name, slot, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInstanceWorkflowsSlotPagingPage(resourceGroupName, name, slot, options, settings);
            },
        };
    }
    listInstanceWorkflowsSlotPagingPage(resourceGroupName, name, slot, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceWorkflowsSlotPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInstanceWorkflowsSlot(resourceGroupName, name, slot, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInstanceWorkflowsSlotNext(resourceGroupName, name, slot, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInstanceWorkflowsSlotPagingAll(resourceGroupName, name, slot, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInstanceWorkflowsSlotPagingAll_1() {
            var _a, e_68, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInstanceWorkflowsSlotPagingPage(resourceGroupName, name, slot, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_68_1) { e_68 = { error: e_68_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_68) throw e_68.error; }
            }
        });
    }
    /**
     * List the workflows for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listWorkflows(resourceGroupName, name, options) {
        const iter = this.listWorkflowsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWorkflowsPagingPage(resourceGroupName, name, options, settings);
            },
        };
    }
    listWorkflowsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkflowsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWorkflows(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWorkflowsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWorkflowsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkflowsPagingAll_1() {
            var _a, e_69, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWorkflowsPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_69_1) { e_69 = { error: e_69_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_69) throw e_69.error; }
            }
        });
    }
    /**
     * Description for Get all apps for a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$8);
    }
    /**
     * Description for Gets all web, mobile, and API apps in the specified resource group.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Description for Gets the details of a web, mobile, or API app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$8);
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, siteEnvelope, options },
                spec: createOrUpdateOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, siteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, siteEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a web, mobile, or API app, or one of the deployment slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param options The options parameters.
     */
    delete(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteOperationSpec);
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, siteEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteEnvelope, options }, updateOperationSpec);
    }
    /**
     * Description for Analyze a custom hostname.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    analyzeCustomHostname(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, analyzeCustomHostnameOperationSpec);
    }
    /**
     * Description for Applies the configuration settings from the target slot onto the current slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    applySlotConfigToProduction(resourceGroupName, name, slotSwapEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slotSwapEntity, options }, applySlotConfigToProductionOperationSpec);
    }
    /**
     * Description for Creates a backup of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Backup configuration. You can use the JSON response from the POST action as input
     *                here.
     * @param options The options parameters.
     */
    backup(resourceGroupName, name, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, request, options }, backupOperationSpec);
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listBackups(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listBackupsOperationSpec);
    }
    /**
     * Description for Gets a backup of an app by its ID.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param options The options parameters.
     */
    getBackupStatus(resourceGroupName, name, backupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, options }, getBackupStatusOperationSpec);
    }
    /**
     * Description for Deletes a backup of an app by its ID.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param options The options parameters.
     */
    deleteBackup(resourceGroupName, name, backupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, options }, deleteBackupOperationSpec);
    }
    /**
     * Description for Gets status of a web app backup that may be in progress, including secrets
     * associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS
     * URL for the backup if a new URL is passed in the request body.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param request Information on backup request.
     * @param options The options parameters.
     */
    listBackupStatusSecrets(resourceGroupName, name, backupId, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, request, options }, listBackupStatusSecretsOperationSpec);
    }
    /**
     * Description for Restores a specific backup to another app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestore(resourceGroupName, name, backupId, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, backupId, request, options },
                spec: restoreOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a specific backup to another app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreAndWait(resourceGroupName, name, backupId, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestore(resourceGroupName, name, backupId, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listBasicPublishingCredentialsPolicies(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listBasicPublishingCredentialsPoliciesOperationSpec);
    }
    /**
     * Description for Returns whether FTP is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getFtpAllowed(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getFtpAllowedOperationSpec);
    }
    /**
     * Description for Updates whether FTP is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param csmPublishingAccessPoliciesEntity Publishing Credentials Policies parameters.
     * @param options The options parameters.
     */
    updateFtpAllowed(resourceGroupName, name, csmPublishingAccessPoliciesEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, csmPublishingAccessPoliciesEntity, options }, updateFtpAllowedOperationSpec);
    }
    /**
     * Description for Returns whether Scm basic auth is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getScmAllowed(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getScmAllowedOperationSpec);
    }
    /**
     * Description for Updates whether user publishing credentials are allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param csmPublishingAccessPoliciesEntity Publishing Credentials Policies parameters.
     * @param options The options parameters.
     */
    updateScmAllowed(resourceGroupName, name, csmPublishingAccessPoliciesEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, csmPublishingAccessPoliciesEntity, options }, updateScmAllowedOperationSpec);
    }
    /**
     * Description for List the configurations of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listConfigurations(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listConfigurationsOperationSpec);
    }
    /**
     * Description for Replaces the application settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettings Application settings of the app.
     * @param options The options parameters.
     */
    updateApplicationSettings(resourceGroupName, name, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettings, options }, updateApplicationSettingsOperationSpec);
    }
    /**
     * Description for Gets the application settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listApplicationSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listApplicationSettingsOperationSpec);
    }
    /**
     * Description for Updates the Authentication / Authorization settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param siteAuthSettings Auth settings associated with web app.
     * @param options The options parameters.
     */
    updateAuthSettings(resourceGroupName, name, siteAuthSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteAuthSettings, options }, updateAuthSettingsOperationSpec);
    }
    /**
     * Description for Gets the Authentication/Authorization settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getAuthSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAuthSettingsOperationSpec);
    }
    /**
     * Description for Gets site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getAuthSettingsV2WithoutSecrets(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAuthSettingsV2WithoutSecretsOperationSpec);
    }
    /**
     * Description for Updates site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param siteAuthSettingsV2 Auth settings associated with web app.
     * @param options The options parameters.
     */
    updateAuthSettingsV2(resourceGroupName, name, siteAuthSettingsV2, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteAuthSettingsV2, options }, updateAuthSettingsV2OperationSpec);
    }
    /**
     * Description for Gets site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getAuthSettingsV2(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAuthSettingsV2OperationSpec);
    }
    /**
     * Description for Updates the Azure storage account configurations of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param azureStorageAccounts Azure storage accounts of the app.
     * @param options The options parameters.
     */
    updateAzureStorageAccounts(resourceGroupName, name, azureStorageAccounts, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, azureStorageAccounts, options }, updateAzureStorageAccountsOperationSpec);
    }
    /**
     * Description for Gets the Azure storage account configurations of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listAzureStorageAccounts(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listAzureStorageAccountsOperationSpec);
    }
    /**
     * Description for Updates the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Edited backup configuration.
     * @param options The options parameters.
     */
    updateBackupConfiguration(resourceGroupName, name, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, request, options }, updateBackupConfigurationOperationSpec);
    }
    /**
     * Description for Deletes the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    deleteBackupConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteBackupConfigurationOperationSpec);
    }
    /**
     * Description for Gets the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getBackupConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getBackupConfigurationOperationSpec);
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _getAppSettingsKeyVaultReferences(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getAppSettingsKeyVaultReferencesOperationSpec);
    }
    /**
     * Description for Gets the config reference and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettingKey App Setting key name.
     * @param options The options parameters.
     */
    getAppSettingKeyVaultReference(resourceGroupName, name, appSettingKey, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettingKey, options }, getAppSettingKeyVaultReferenceOperationSpec);
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _getSiteConnectionStringKeyVaultReferences(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getSiteConnectionStringKeyVaultReferencesOperationSpec);
    }
    /**
     * Description for Gets the config reference and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStringKey
     * @param options The options parameters.
     */
    getSiteConnectionStringKeyVaultReference(resourceGroupName, name, connectionStringKey, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionStringKey, options }, getSiteConnectionStringKeyVaultReferenceOperationSpec);
    }
    /**
     * Description for Replaces the connection strings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @param options The options parameters.
     */
    updateConnectionStrings(resourceGroupName, name, connectionStrings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionStrings, options }, updateConnectionStringsOperationSpec);
    }
    /**
     * Description for Gets the connection strings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listConnectionStrings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listConnectionStringsOperationSpec);
    }
    /**
     * Description for Gets the logging configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getDiagnosticLogsConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getDiagnosticLogsConfigurationOperationSpec);
    }
    /**
     * Description for Updates the logging configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change
     *                       in the "properties" property.
     * @param options The options parameters.
     */
    updateDiagnosticLogsConfig(resourceGroupName, name, siteLogsConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteLogsConfig, options }, updateDiagnosticLogsConfigOperationSpec);
    }
    /**
     * Description for Replaces the metadata of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @param options The options parameters.
     */
    updateMetadata(resourceGroupName, name, metadata, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, metadata, options }, updateMetadataOperationSpec);
    }
    /**
     * Description for Gets the metadata of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listMetadata(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listMetadataOperationSpec);
    }
    /**
     * Description for Gets the Git/FTP publishing credentials of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    beginListPublishingCredentials(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: listPublishingCredentialsOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Gets the Git/FTP publishing credentials of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    beginListPublishingCredentialsAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListPublishingCredentials(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Updates the Push settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param pushSettings Push settings associated with web app.
     * @param options The options parameters.
     */
    updateSitePushSettings(resourceGroupName, name, pushSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, pushSettings, options }, updateSitePushSettingsOperationSpec);
    }
    /**
     * Description for Gets the Push settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    listSitePushSettings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSitePushSettingsOperationSpec);
    }
    /**
     * Description for Gets the names of app settings and connection strings that stick to the slot (not
     * swapped).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSlotConfigurationNames(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSlotConfigurationNamesOperationSpec);
    }
    /**
     * Description for Updates the names of application settings and connection string that remain with the
     * slot during swap operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotConfigNames Names of application settings and connection strings. See example.
     * @param options The options parameters.
     */
    updateSlotConfigurationNames(resourceGroupName, name, slotConfigNames, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slotConfigNames, options }, updateSlotConfigurationNamesOperationSpec);
    }
    /**
     * Description for Gets the configuration of an app, such as platform version and bitness, default
     * documents, virtual applications, Always On, etc.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getConfiguration(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getConfigurationOperationSpec);
    }
    /**
     * Description for Updates the configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param options The options parameters.
     */
    createOrUpdateConfiguration(resourceGroupName, name, siteConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteConfig, options }, createOrUpdateConfigurationOperationSpec);
    }
    /**
     * Description for Updates the configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param options The options parameters.
     */
    updateConfiguration(resourceGroupName, name, siteConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteConfig, options }, updateConfigurationOperationSpec);
    }
    /**
     * Description for Gets a list of web app configuration snapshots identifiers. Each element of the list
     * contains a timestamp and the ID of the snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listConfigurationSnapshotInfo(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listConfigurationSnapshotInfoOperationSpec);
    }
    /**
     * Description for Gets a snapshot of the configuration of an app at a previous point in time.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param options The options parameters.
     */
    getConfigurationSnapshot(resourceGroupName, name, snapshotId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, snapshotId, options }, getConfigurationSnapshotOperationSpec);
    }
    /**
     * Description for Reverts the configuration of an app to a previous snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param options The options parameters.
     */
    recoverSiteConfigurationSnapshot(resourceGroupName, name, snapshotId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, snapshotId, options }, recoverSiteConfigurationSnapshotOperationSpec);
    }
    /**
     * Description for Gets the last lines of docker logs for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getWebSiteContainerLogs(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getWebSiteContainerLogsOperationSpec);
    }
    /**
     * Description for Gets the ZIP archived docker log files for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getContainerLogsZip(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getContainerLogsZipOperationSpec);
    }
    /**
     * Description for List continuous web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listContinuousWebJobs(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listContinuousWebJobsOperationSpec);
    }
    /**
     * Description for Gets a continuous web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    getContinuousWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, getContinuousWebJobOperationSpec);
    }
    /**
     * Description for Delete a continuous web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    deleteContinuousWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, deleteContinuousWebJobOperationSpec);
    }
    /**
     * Description for Start a continuous web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    startContinuousWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, startContinuousWebJobOperationSpec);
    }
    /**
     * Description for Stop a continuous web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    stopContinuousWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, stopContinuousWebJobOperationSpec);
    }
    /**
     * List deployment statuses for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listProductionSiteDeploymentStatuses(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listProductionSiteDeploymentStatusesOperationSpec);
    }
    /**
     * Gets the deployment status for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param deploymentStatusId GUID of the deployment operation.
     * @param options The options parameters.
     */
    beginGetProductionSiteDeploymentStatus(resourceGroupName, name, deploymentStatusId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, deploymentStatusId, options },
                spec: getProductionSiteDeploymentStatusOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the deployment status for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param deploymentStatusId GUID of the deployment operation.
     * @param options The options parameters.
     */
    beginGetProductionSiteDeploymentStatusAndWait(resourceGroupName, name, deploymentStatusId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetProductionSiteDeploymentStatus(resourceGroupName, name, deploymentStatusId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for List deployments for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listDeployments(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listDeploymentsOperationSpec);
    }
    /**
     * Description for Get a deployment by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param options The options parameters.
     */
    getDeployment(resourceGroupName, name, id, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, options }, getDeploymentOperationSpec);
    }
    /**
     * Description for Create a deployment for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param deployment Deployment details.
     * @param options The options parameters.
     */
    createDeployment(resourceGroupName, name, id, deployment, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, deployment, options }, createDeploymentOperationSpec);
    }
    /**
     * Description for Delete a deployment by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param options The options parameters.
     */
    deleteDeployment(resourceGroupName, name, id, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, options }, deleteDeploymentOperationSpec);
    }
    /**
     * Description for List deployment log for specific deployment for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON
     *           response from "GET /api/sites/{siteName}/deployments".
     * @param options The options parameters.
     */
    listDeploymentLog(resourceGroupName, name, id, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, options }, listDeploymentLogOperationSpec);
    }
    /**
     * Description for Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Use this to get information about the databases stored in a backup.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery
     *                of backup.
     * @param options The options parameters.
     */
    discoverBackup(resourceGroupName, name, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, request, options }, discoverBackupOperationSpec);
    }
    /**
     * Description for Lists ownership identifiers for domain associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listDomainOwnershipIdentifiers(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listDomainOwnershipIdentifiersOperationSpec);
    }
    /**
     * Description for Get domain ownership identifier for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param options The options parameters.
     */
    getDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainOwnershipIdentifierName, options }, getDomainOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Creates a domain ownership identifier for web app, or updates an existing ownership
     * identifier.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    createOrUpdateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            domainOwnershipIdentifierName,
            domainOwnershipIdentifier,
            options,
        }, createOrUpdateDomainOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Deletes a domain ownership identifier for a web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param options The options parameters.
     */
    deleteDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainOwnershipIdentifierName, options }, deleteDomainOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Creates a domain ownership identifier for web app, or updates an existing ownership
     * identifier.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    updateDomainOwnershipIdentifier(resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            domainOwnershipIdentifierName,
            domainOwnershipIdentifier,
            options,
        }, updateDomainOwnershipIdentifierOperationSpec);
    }
    /**
     * Description for Get the status of the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getMSDeployStatus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getMSDeployStatusOperationSpec);
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateMSDeployOperation(resourceGroupName, name, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, mSDeploy, options },
                spec: createMSDeployOperationOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateMSDeployOperationAndWait(resourceGroupName, name, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateMSDeployOperation(resourceGroupName, name, mSDeploy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get the MSDeploy Log for the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getMSDeployLog(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getMSDeployLogOperationSpec);
    }
    /**
     * Description for Invoke onedeploy status API /api/deployments and gets the deployment status for the
     * site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getOneDeployStatus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOneDeployStatusOperationSpec);
    }
    /**
     * Description for Invoke the OneDeploy publish web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    createOneDeployOperation(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, createOneDeployOperationOperationSpec);
    }
    /**
     * Description for List the functions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listFunctions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listFunctionsOperationSpec);
    }
    /**
     * Description for Fetch a short lived token that can be exchanged for a master key.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getFunctionsAdminToken(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getFunctionsAdminTokenOperationSpec);
    }
    /**
     * Description for Get function information by its ID for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param options The options parameters.
     */
    getFunction(resourceGroupName, name, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, options }, getFunctionOperationSpec);
    }
    /**
     * Description for Create function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @param options The options parameters.
     */
    beginCreateFunction(resourceGroupName, name, functionName, functionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    functionName,
                    functionEnvelope,
                    options,
                },
                spec: createFunctionOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param functionEnvelope Function details.
     * @param options The options parameters.
     */
    beginCreateFunctionAndWait(resourceGroupName, name, functionName, functionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateFunction(resourceGroupName, name, functionName, functionEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param options The options parameters.
     */
    deleteFunction(resourceGroupName, name, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, options }, deleteFunctionOperationSpec);
    }
    /**
     * Description for Add or update a function secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName The name of the function.
     * @param keyName The name of the key.
     * @param key The key to create or update
     * @param options The options parameters.
     */
    createOrUpdateFunctionSecret(resourceGroupName, name, functionName, keyName, key, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, keyName, key, options }, createOrUpdateFunctionSecretOperationSpec);
    }
    /**
     * Description for Delete a function secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName The name of the function.
     * @param keyName The name of the key.
     * @param options The options parameters.
     */
    deleteFunctionSecret(resourceGroupName, name, functionName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, keyName, options }, deleteFunctionSecretOperationSpec);
    }
    /**
     * Description for Get function keys for a function in a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param options The options parameters.
     */
    listFunctionKeys(resourceGroupName, name, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, options }, listFunctionKeysOperationSpec);
    }
    /**
     * Description for Get function secrets for a function in a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param options The options parameters.
     */
    listFunctionSecrets(resourceGroupName, name, functionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, options }, listFunctionSecretsOperationSpec);
    }
    /**
     * Description for Get host secrets for a function app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listHostKeys(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHostKeysOperationSpec);
    }
    /**
     * Description for This is to allow calling via powershell and ARM template.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSyncStatus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSyncStatusOperationSpec);
    }
    /**
     * Description for Syncs function trigger metadata to the management database
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    syncFunctions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, syncFunctionsOperationSpec);
    }
    /**
     * Description for Add or update a host level secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param keyType The type of host key.
     * @param keyName The name of the key.
     * @param key The key to create or update
     * @param options The options parameters.
     */
    createOrUpdateHostSecret(resourceGroupName, name, keyType, keyName, key, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyType, keyName, key, options }, createOrUpdateHostSecretOperationSpec);
    }
    /**
     * Description for Delete a host level secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param keyType The type of host key.
     * @param keyName The name of the key.
     * @param options The options parameters.
     */
    deleteHostSecret(resourceGroupName, name, keyType, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyType, keyName, options }, deleteHostSecretOperationSpec);
    }
    /**
     * Description for Get hostname bindings for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listHostNameBindings(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHostNameBindingsOperationSpec);
    }
    /**
     * Description for Get the named hostname binding for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param options The options parameters.
     */
    getHostNameBinding(resourceGroupName, name, hostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostName, options }, getHostNameBindingOperationSpec);
    }
    /**
     * Description for Creates a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @param options The options parameters.
     */
    createOrUpdateHostNameBinding(resourceGroupName, name, hostName, hostNameBinding, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostName, hostNameBinding, options }, createOrUpdateHostNameBindingOperationSpec);
    }
    /**
     * Description for Deletes a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param options The options parameters.
     */
    deleteHostNameBinding(resourceGroupName, name, hostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostName, options }, deleteHostNameBindingOperationSpec);
    }
    /**
     * Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param options The options parameters.
     */
    getHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, getHybridConnectionOperationSpec);
    }
    /**
     * Description for Creates a new Hybrid Connection using a Service Bus relay.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param options The options parameters.
     */
    createOrUpdateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            namespaceName,
            relayName,
            connectionEnvelope,
            options,
        }, createOrUpdateHybridConnectionOperationSpec);
    }
    /**
     * Description for Removes a Hybrid Connection from this site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param options The options parameters.
     */
    deleteHybridConnection(resourceGroupName, name, namespaceName, relayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, options }, deleteHybridConnectionOperationSpec);
    }
    /**
     * Description for Creates a new Hybrid Connection using a Service Bus relay.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param options The options parameters.
     */
    updateHybridConnection(resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            namespaceName,
            relayName,
            connectionEnvelope,
            options,
        }, updateHybridConnectionOperationSpec);
    }
    /**
     * Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    listHybridConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listHybridConnectionsOperationSpec);
    }
    /**
     * Description for Gets hybrid connections configured for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listRelayServiceConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listRelayServiceConnectionsOperationSpec);
    }
    /**
     * Description for Gets a hybrid connection configuration by its name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param options The options parameters.
     */
    getRelayServiceConnection(resourceGroupName, name, entityName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, options }, getRelayServiceConnectionOperationSpec);
    }
    /**
     * Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
     * (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param options The options parameters.
     */
    createOrUpdateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, connectionEnvelope, options }, createOrUpdateRelayServiceConnectionOperationSpec);
    }
    /**
     * Description for Deletes a relay service connection by its name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param options The options parameters.
     */
    deleteRelayServiceConnection(resourceGroupName, name, entityName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, options }, deleteRelayServiceConnectionOperationSpec);
    }
    /**
     * Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
     * (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param options The options parameters.
     */
    updateRelayServiceConnection(resourceGroupName, name, entityName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, connectionEnvelope, options }, updateRelayServiceConnectionOperationSpec);
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listInstanceIdentifiers(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listInstanceIdentifiersOperationSpec);
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param instanceId
     * @param options The options parameters.
     */
    getInstanceInfo(resourceGroupName, name, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, options }, getInstanceInfoOperationSpec);
    }
    /**
     * Description for Get the status of the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param options The options parameters.
     */
    getInstanceMsDeployStatus(resourceGroupName, name, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, options }, getInstanceMsDeployStatusOperationSpec);
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateInstanceMSDeployOperation(resourceGroupName, name, instanceId, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, instanceId, mSDeploy, options },
                spec: createInstanceMSDeployOperationOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateInstanceMSDeployOperationAndWait(resourceGroupName, name, instanceId, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateInstanceMSDeployOperation(resourceGroupName, name, instanceId, mSDeploy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get the MSDeploy Log for the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param instanceId ID of web app instance.
     * @param options The options parameters.
     */
    getInstanceMSDeployLog(resourceGroupName, name, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, options }, getInstanceMSDeployLogOperationSpec);
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcesses(resourceGroupName, name, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, options }, listInstanceProcessesOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcess(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, getInstanceProcessOperationSpec);
    }
    /**
     * Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    deleteInstanceProcess(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, deleteInstanceProcessOperationSpec);
    }
    /**
     * Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessDump(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, getInstanceProcessDumpOperationSpec);
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessModules(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, listInstanceProcessModulesOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessModule(resourceGroupName, name, processId, baseAddress, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, baseAddress, instanceId, options }, getInstanceProcessModuleOperationSpec);
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessThreads(resourceGroupName, name, processId, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, options }, listInstanceProcessThreadsOperationSpec);
    }
    /**
     * Description for Shows whether an app can be cloned to another resource group or subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    isCloneable(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, isCloneableOperationSpec);
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listSiteBackups(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSiteBackupsOperationSpec);
    }
    /**
     * Description for This is to allow calling via powershell and ARM template.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listSyncFunctionTriggers(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSyncFunctionTriggersOperationSpec);
    }
    /**
     * Description for Restores a web app.
     * @param subscriptionName Azure subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationOptions Migration migrationOptions.
     * @param options The options parameters.
     */
    beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    subscriptionName,
                    resourceGroupName,
                    name,
                    migrationOptions,
                    options,
                },
                spec: migrateStorageOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a web app.
     * @param subscriptionName Azure subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationOptions Migration migrationOptions.
     * @param options The options parameters.
     */
    beginMigrateStorageAndWait(subscriptionName, resourceGroupName, name, migrationOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateStorage(subscriptionName, resourceGroupName, name, migrationOptions, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Migrates a local (in-app) MySql database to a remote MySql database.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @param options The options parameters.
     */
    beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, migrationRequestEnvelope, options },
                spec: migrateMySqlOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Migrates a local (in-app) MySql database to a remote MySql database.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param migrationRequestEnvelope MySql migration options.
     * @param options The options parameters.
     */
    beginMigrateMySqlAndWait(resourceGroupName, name, migrationRequestEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMySql(resourceGroupName, name, migrationRequestEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns the status of MySql in app migration, if one is active, and whether or not
     * MySql in app is enabled
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getMigrateMySqlStatus(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getMigrateMySqlStatusOperationSpec);
    }
    /**
     * Description for Gets a Swift Virtual Network connection.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getSwiftVirtualNetworkConnection(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getSwiftVirtualNetworkConnectionOperationSpec);
    }
    /**
     * Description for Integrates this Web App with a Virtual Network. This requires that 1)
     * "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
     * already been delegated, and is not
     * in use by another App Service Plan other than the one this App is in.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    createOrUpdateSwiftVirtualNetworkConnectionWithCheck(resourceGroupName, name, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionEnvelope, options }, createOrUpdateSwiftVirtualNetworkConnectionWithCheckOperationSpec);
    }
    /**
     * Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    deleteSwiftVirtualNetwork(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteSwiftVirtualNetworkOperationSpec);
    }
    /**
     * Description for Integrates this Web App with a Virtual Network. This requires that 1)
     * "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
     * already been delegated, and is not
     * in use by another App Service Plan other than the one this App is in.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    updateSwiftVirtualNetworkConnectionWithCheck(resourceGroupName, name, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionEnvelope, options }, updateSwiftVirtualNetworkConnectionWithCheckOperationSpec);
    }
    /**
     * Description for Gets all network features used by the app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. Only "summary" is supported at this time.
     * @param options The options parameters.
     */
    listNetworkFeatures(resourceGroupName, name, view, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, view, options }, listNetworkFeaturesOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param options The options parameters.
     */
    getNetworkTraceOperation(resourceGroupName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, options }, getNetworkTraceOperationOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site (To be deprecated).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    startWebSiteNetworkTrace(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, startWebSiteNetworkTraceOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    beginStartWebSiteNetworkTraceOperation(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: startWebSiteNetworkTraceOperationOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    beginStartWebSiteNetworkTraceOperationAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartWebSiteNetworkTraceOperation(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Stop ongoing capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    stopWebSiteNetworkTrace(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, stopWebSiteNetworkTraceOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param options The options parameters.
     */
    getNetworkTraces(resourceGroupName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, options }, getNetworkTracesOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param options The options parameters.
     */
    getNetworkTraceOperationV2(resourceGroupName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, options }, getNetworkTraceOperationV2OperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param options The options parameters.
     */
    getNetworkTracesV2(resourceGroupName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, options }, getNetworkTracesV2OperationSpec);
    }
    /**
     * Description for Generates a new publishing password for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    generateNewSitePublishingPassword(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, generateNewSitePublishingPasswordOperationSpec);
    }
    /**
     * Description for Gets perfmon counters for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    _listPerfMonCounters(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listPerfMonCountersOperationSpec);
    }
    /**
     * Description for Gets web app's event logs.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    getSitePhpErrorLogFlag(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getSitePhpErrorLogFlagOperationSpec);
    }
    /**
     * Description for Gets the premier add-ons of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listPremierAddOns(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listPremierAddOnsOperationSpec);
    }
    /**
     * Description for Gets a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param options The options parameters.
     */
    getPremierAddOn(resourceGroupName, name, premierAddOnName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, options }, getPremierAddOnOperationSpec);
    }
    /**
     * Description for Updates a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param options The options parameters.
     */
    addPremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, premierAddOn, options }, addPremierAddOnOperationSpec);
    }
    /**
     * Description for Delete a premier add-on from an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param options The options parameters.
     */
    deletePremierAddOn(resourceGroupName, name, premierAddOnName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, options }, deletePremierAddOnOperationSpec);
    }
    /**
     * Description for Updates a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param options The options parameters.
     */
    updatePremierAddOn(resourceGroupName, name, premierAddOnName, premierAddOn, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, premierAddOn, options }, updatePremierAddOnOperationSpec);
    }
    /**
     * Description for Gets data around private site access enablement and authorized Virtual Networks that
     * can access the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    getPrivateAccess(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateAccessOperationSpec);
    }
    /**
     * Description for Sets data around private site access enablement and authorized Virtual Networks that
     * can access the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param access The information for the private access
     * @param options The options parameters.
     */
    putPrivateAccessVnet(resourceGroupName, name, access, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, access, options }, putPrivateAccessVnetOperationSpec);
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionList(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateEndpointConnectionListOperationSpec);
    }
    /**
     * Description for Gets a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param options The options parameters.
     */
    getPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, options }, getPrivateEndpointConnectionOperationSpec);
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param privateEndpointWrapper Remote Private Endpoint Connection ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    privateEndpointConnectionName,
                    privateEndpointWrapper,
                    options,
                },
                spec: approveOrRejectPrivateEndpointConnectionOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param privateEndpointWrapper Remote Private Endpoint Connection ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApproveOrRejectPrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, privateEndpointConnectionName, options },
                spec: deletePrivateEndpointConnectionOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionAndWait(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnection(resourceGroupName, name, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param options The options parameters.
     */
    getPrivateLinkResources(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getPrivateLinkResourcesOperationSpec);
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listProcesses(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listProcessesOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    getProcess(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, getProcessOperationSpec);
    }
    /**
     * Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    deleteProcess(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, deleteProcessOperationSpec);
    }
    /**
     * Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    getProcessDump(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, getProcessDumpOperationSpec);
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    _listProcessModules(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, listProcessModulesOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param options The options parameters.
     */
    getProcessModule(resourceGroupName, name, processId, baseAddress, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, baseAddress, options }, getProcessModuleOperationSpec);
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param options The options parameters.
     */
    _listProcessThreads(resourceGroupName, name, processId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, options }, listProcessThreadsOperationSpec);
    }
    /**
     * Description for Get public certificates for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listPublicCertificates(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listPublicCertificatesOperationSpec);
    }
    /**
     * Description for Get the named public certificate for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param options The options parameters.
     */
    getPublicCertificate(resourceGroupName, name, publicCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, publicCertificateName, options }, getPublicCertificateOperationSpec);
    }
    /**
     * Description for Creates a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param publicCertificate Public certificate details. This is the JSON representation of a
     *                          PublicCertificate object.
     * @param options The options parameters.
     */
    createOrUpdatePublicCertificate(resourceGroupName, name, publicCertificateName, publicCertificate, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            publicCertificateName,
            publicCertificate,
            options,
        }, createOrUpdatePublicCertificateOperationSpec);
    }
    /**
     * Description for Deletes a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param options The options parameters.
     */
    deletePublicCertificate(resourceGroupName, name, publicCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, publicCertificateName, options }, deletePublicCertificateOperationSpec);
    }
    /**
     * Description for Gets the publishing profile for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publishingProfileOptions Specifies publishingProfileOptions for publishing profile. For
     *                                 example, use {"format": "FileZilla3"} to get a FileZilla publishing profile.
     * @param options The options parameters.
     */
    listPublishingProfileXmlWithSecrets(resourceGroupName, name, publishingProfileOptions, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, publishingProfileOptions, options }, listPublishingProfileXmlWithSecretsOperationSpec);
    }
    /**
     * Description for Resets the configuration settings of the current slot if they were previously
     * modified by calling the API with POST.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    resetProductionSlotConfig(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, resetProductionSlotConfigOperationSpec);
    }
    /**
     * Description for Restarts an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    restart(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, restartOperationSpec);
    }
    /**
     * Description for Restores an app from a backup blob in Azure Storage.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreFromBackupBlob(resourceGroupName, name, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, request, options },
                spec: restoreFromBackupBlobOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores an app from a backup blob in Azure Storage.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreFromBackupBlobAndWait(resourceGroupName, name, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreFromBackupBlob(resourceGroupName, name, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Restores a deleted web app to this web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param restoreRequest Deleted web app restore information.
     * @param options The options parameters.
     */
    beginRestoreFromDeletedApp(resourceGroupName, name, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, restoreRequest, options },
                spec: restoreFromDeletedAppOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a deleted web app to this web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param restoreRequest Deleted web app restore information.
     * @param options The options parameters.
     */
    beginRestoreFromDeletedAppAndWait(resourceGroupName, name, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreFromDeletedApp(resourceGroupName, name, restoreRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Restores a web app from a snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param restoreRequest Snapshot restore settings. Snapshot information can be obtained by calling
     *                       GetDeletedSites or GetSiteSnapshots API.
     * @param options The options parameters.
     */
    beginRestoreSnapshot(resourceGroupName, name, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, restoreRequest, options },
                spec: restoreSnapshotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a web app from a snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param restoreRequest Snapshot restore settings. Snapshot information can be obtained by calling
     *                       GetDeletedSites or GetSiteSnapshots API.
     * @param options The options parameters.
     */
    beginRestoreSnapshotAndWait(resourceGroupName, name, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreSnapshot(resourceGroupName, name, restoreRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the site containers of a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listSiteContainers(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSiteContainersOperationSpec);
    }
    /**
     * Gets a site container of a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param containerName Site Container Name
     * @param options The options parameters.
     */
    getSiteContainer(resourceGroupName, name, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, containerName, options }, getSiteContainerOperationSpec);
    }
    /**
     * Creates or Updates a site container for a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param containerName Site Container Name
     * @param request Container Entity
     * @param options The options parameters.
     */
    createOrUpdateSiteContainer(resourceGroupName, name, containerName, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, containerName, request, options }, createOrUpdateSiteContainerOperationSpec);
    }
    /**
     * Deletes a site container for a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param containerName Site Container Name
     * @param options The options parameters.
     */
    deleteSiteContainer(resourceGroupName, name, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, containerName, options }, deleteSiteContainerOperationSpec);
    }
    /**
     * Description for Get list of siteextensions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listSiteExtensions(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSiteExtensionsOperationSpec);
    }
    /**
     * Description for Get site extension information by its ID for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param options The options parameters.
     */
    getSiteExtension(resourceGroupName, name, siteExtensionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteExtensionId, options }, getSiteExtensionOperationSpec);
    }
    /**
     * Description for Install site extension on a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param options The options parameters.
     */
    beginInstallSiteExtension(resourceGroupName, name, siteExtensionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, siteExtensionId, options },
                spec: installSiteExtensionOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Install site extension on a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param options The options parameters.
     */
    beginInstallSiteExtensionAndWait(resourceGroupName, name, siteExtensionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInstallSiteExtension(resourceGroupName, name, siteExtensionId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Remove a site extension from a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param options The options parameters.
     */
    deleteSiteExtension(resourceGroupName, name, siteExtensionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteExtensionId, options }, deleteSiteExtensionOperationSpec);
    }
    /**
     * Description for Gets an app's deployment slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listSlots(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSlotsOperationSpec);
    }
    /**
     * Description for Gets the details of a web, mobile, or API app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns the production slot.
     * @param options The options parameters.
     */
    getSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSlotOperationSpec);
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create
     *             or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSlot(resourceGroupName, name, slot, siteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, siteEnvelope, options },
                spec: createOrUpdateSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create
     *             or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSlotAndWait(resourceGroupName, name, slot, siteEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateSlot(resourceGroupName, name, slot, siteEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a web, mobile, or API app, or one of the deployment slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app to delete.
     * @param slot Name of the deployment slot to delete. By default, the API deletes the production slot.
     * @param options The options parameters.
     */
    deleteSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, deleteSlotOperationSpec);
    }
    /**
     * Description for Creates a new web, mobile, or API app in an existing resource group, or updates an
     * existing app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Unique name of the app to create or update. To create or update a deployment slot, use
     *             the {slot} parameter.
     * @param slot Name of the deployment slot to create or update. By default, this API attempts to create
     *             or modify the production slot.
     * @param siteEnvelope A JSON representation of the app properties. See example.
     * @param options The options parameters.
     */
    updateSlot(resourceGroupName, name, slot, siteEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteEnvelope, options }, updateSlotOperationSpec);
    }
    /**
     * Description for Analyze a custom hostname.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    analyzeCustomHostnameSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, analyzeCustomHostnameSlotOperationSpec);
    }
    /**
     * Description for Applies the configuration settings from the target slot onto the current slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    applySlotConfigurationSlot(resourceGroupName, name, slot, slotSwapEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, slotSwapEntity, options }, applySlotConfigurationSlotOperationSpec);
    }
    /**
     * Description for Creates a backup of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a backup
     *             for the production slot.
     * @param request Backup configuration. You can use the JSON response from the POST action as input
     *                here.
     * @param options The options parameters.
     */
    backupSlot(resourceGroupName, name, slot, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, request, options }, backupSlotOperationSpec);
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param options The options parameters.
     */
    _listBackupsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listBackupsSlotOperationSpec);
    }
    /**
     * Description for Gets a backup of an app by its ID.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a backup of
     *             the production slot.
     * @param options The options parameters.
     */
    getBackupStatusSlot(resourceGroupName, name, backupId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, slot, options }, getBackupStatusSlotOperationSpec);
    }
    /**
     * Description for Deletes a backup of an app by its ID.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a backup of
     *             the production slot.
     * @param options The options parameters.
     */
    deleteBackupSlot(resourceGroupName, name, backupId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, slot, options }, deleteBackupSlotOperationSpec);
    }
    /**
     * Description for Gets status of a web app backup that may be in progress, including secrets
     * associated with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS
     * URL for the backup if a new URL is passed in the request body.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param backupId ID of backup.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param request Information on backup request.
     * @param options The options parameters.
     */
    listBackupStatusSecretsSlot(resourceGroupName, name, backupId, slot, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, backupId, slot, request, options }, listBackupStatusSecretsSlotOperationSpec);
    }
    /**
     * Description for Restores a specific backup to another app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup
     *             of the production slot.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreSlot(resourceGroupName, name, backupId, slot, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, backupId, slot, request, options },
                spec: restoreSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a specific backup to another app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param backupId ID of the backup.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup
     *             of the production slot.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreSlotAndWait(resourceGroupName, name, backupId, slot, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreSlot(resourceGroupName, name, backupId, slot, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    _listBasicPublishingCredentialsPoliciesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listBasicPublishingCredentialsPoliciesSlotOperationSpec);
    }
    /**
     * Description for Returns whether FTP is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    getFtpAllowedSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getFtpAllowedSlotOperationSpec);
    }
    /**
     * Description for Updates whether FTP is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param csmPublishingAccessPoliciesEntity Publishing Credentials Policies parameters.
     * @param options The options parameters.
     */
    updateFtpAllowedSlot(resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            slot,
            csmPublishingAccessPoliciesEntity,
            options,
        }, updateFtpAllowedSlotOperationSpec);
    }
    /**
     * Description for Returns whether Scm basic auth is allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    getScmAllowedSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getScmAllowedSlotOperationSpec);
    }
    /**
     * Description for Updates whether user publishing credentials are allowed on the site or not.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param csmPublishingAccessPoliciesEntity Publishing Credentials Policies parameters.
     * @param options The options parameters.
     */
    updateScmAllowedSlot(resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            slot,
            csmPublishingAccessPoliciesEntity,
            options,
        }, updateScmAllowedSlotOperationSpec);
    }
    /**
     * Description for List the configurations of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    _listConfigurationsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listConfigurationsSlotOperationSpec);
    }
    /**
     * Description for Replaces the application settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the
     *             application settings for the production slot.
     * @param appSettings Application settings of the app.
     * @param options The options parameters.
     */
    updateApplicationSettingsSlot(resourceGroupName, name, slot, appSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, appSettings, options }, updateApplicationSettingsSlotOperationSpec);
    }
    /**
     * Description for Gets the application settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the
     *             application settings for the production slot.
     * @param options The options parameters.
     */
    listApplicationSettingsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listApplicationSettingsSlotOperationSpec);
    }
    /**
     * Description for Updates the Authentication / Authorization settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettings Auth settings associated with web app.
     * @param options The options parameters.
     */
    updateAuthSettingsSlot(resourceGroupName, name, slot, siteAuthSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteAuthSettings, options }, updateAuthSettingsSlotOperationSpec);
    }
    /**
     * Description for Gets the Authentication/Authorization settings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings
     *             for the production slot.
     * @param options The options parameters.
     */
    getAuthSettingsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getAuthSettingsSlotOperationSpec);
    }
    /**
     * Gets site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings
     *             for the production slot.
     * @param options The options parameters.
     */
    getAuthSettingsV2WithoutSecretsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getAuthSettingsV2WithoutSecretsSlotOperationSpec);
    }
    /**
     * Description for Updates site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param siteAuthSettingsV2 Auth settings associated with web app.
     * @param options The options parameters.
     */
    updateAuthSettingsV2Slot(resourceGroupName, name, slot, siteAuthSettingsV2, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteAuthSettingsV2, options }, updateAuthSettingsV2SlotOperationSpec);
    }
    /**
     * Description for Gets site's Authentication / Authorization settings for apps via the V2 format
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the settings
     *             for the production slot.
     * @param options The options parameters.
     */
    getAuthSettingsV2Slot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getAuthSettingsV2SlotOperationSpec);
    }
    /**
     * Description for Updates the Azure storage account configurations of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the Azure
     *             storage account configurations for the production slot.
     * @param azureStorageAccounts Azure storage accounts of the app.
     * @param options The options parameters.
     */
    updateAzureStorageAccountsSlot(resourceGroupName, name, slot, azureStorageAccounts, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, azureStorageAccounts, options }, updateAzureStorageAccountsSlotOperationSpec);
    }
    /**
     * Description for Gets the Azure storage account configurations of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the Azure
     *             storage account configurations for the production slot.
     * @param options The options parameters.
     */
    listAzureStorageAccountsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listAzureStorageAccountsSlotOperationSpec);
    }
    /**
     * Description for Updates the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the backup
     *             configuration for the production slot.
     * @param request Edited backup configuration.
     * @param options The options parameters.
     */
    updateBackupConfigurationSlot(resourceGroupName, name, slot, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, request, options }, updateBackupConfigurationSlotOperationSpec);
    }
    /**
     * Description for Deletes the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the backup
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    deleteBackupConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, deleteBackupConfigurationSlotOperationSpec);
    }
    /**
     * Description for Gets the backup configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the backup
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    getBackupConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getBackupConfigurationSlotOperationSpec);
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    _getAppSettingsKeyVaultReferencesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getAppSettingsKeyVaultReferencesSlotOperationSpec);
    }
    /**
     * Description for Gets the config reference and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param appSettingKey App Setting key name.
     * @param slot
     * @param options The options parameters.
     */
    getAppSettingKeyVaultReferenceSlot(resourceGroupName, name, appSettingKey, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, appSettingKey, slot, options }, getAppSettingKeyVaultReferenceSlotOperationSpec);
    }
    /**
     * Description for Gets the config reference app settings and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param options The options parameters.
     */
    _getSiteConnectionStringKeyVaultReferencesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSiteConnectionStringKeyVaultReferencesSlotOperationSpec);
    }
    /**
     * Description for Gets the config reference and status of an app
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param connectionStringKey
     * @param slot
     * @param options The options parameters.
     */
    getSiteConnectionStringKeyVaultReferenceSlot(resourceGroupName, name, connectionStringKey, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, connectionStringKey, slot, options }, getSiteConnectionStringKeyVaultReferenceSlotOperationSpec);
    }
    /**
     * Description for Replaces the connection strings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the
     *             connection settings for the production slot.
     * @param connectionStrings Connection strings of the app or deployment slot. See example.
     * @param options The options parameters.
     */
    updateConnectionStringsSlot(resourceGroupName, name, slot, connectionStrings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, connectionStrings, options }, updateConnectionStringsSlotOperationSpec);
    }
    /**
     * Description for Gets the connection strings of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the connection
     *             settings for the production slot.
     * @param options The options parameters.
     */
    listConnectionStringsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listConnectionStringsSlotOperationSpec);
    }
    /**
     * Description for Gets the logging configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the logging
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    getDiagnosticLogsConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getDiagnosticLogsConfigurationSlotOperationSpec);
    }
    /**
     * Description for Updates the logging configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the logging
     *             configuration for the production slot.
     * @param siteLogsConfig A SiteLogsConfig JSON object that contains the logging configuration to change
     *                       in the "properties" property.
     * @param options The options parameters.
     */
    updateDiagnosticLogsConfigSlot(resourceGroupName, name, slot, siteLogsConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteLogsConfig, options }, updateDiagnosticLogsConfigSlotOperationSpec);
    }
    /**
     * Description for Replaces the metadata of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the
     *             metadata for the production slot.
     * @param metadata Edited metadata of the app or deployment slot. See example.
     * @param options The options parameters.
     */
    updateMetadataSlot(resourceGroupName, name, slot, metadata, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, metadata, options }, updateMetadataSlotOperationSpec);
    }
    /**
     * Description for Gets the metadata of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the metadata
     *             for the production slot.
     * @param options The options parameters.
     */
    listMetadataSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listMetadataSlotOperationSpec);
    }
    /**
     * Description for Gets the Git/FTP publishing credentials of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing
     *             credentials for the production slot.
     * @param options The options parameters.
     */
    beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, options },
                spec: listPublishingCredentialsSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Gets the Git/FTP publishing credentials of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing
     *             credentials for the production slot.
     * @param options The options parameters.
     */
    beginListPublishingCredentialsSlotAndWait(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListPublishingCredentialsSlot(resourceGroupName, name, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Updates the Push settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param pushSettings Push settings associated with web app.
     * @param options The options parameters.
     */
    updateSitePushSettingsSlot(resourceGroupName, name, slot, pushSettings, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, pushSettings, options }, updateSitePushSettingsSlotOperationSpec);
    }
    /**
     * Description for Gets the Push settings associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    listSitePushSettingsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSitePushSettingsSlotOperationSpec);
    }
    /**
     * Description for Gets the configuration of an app, such as platform version and bitness, default
     * documents, virtual applications, Always On, etc.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    getConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getConfigurationSlotOperationSpec);
    }
    /**
     * Description for Updates the configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update
     *             configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param options The options parameters.
     */
    createOrUpdateConfigurationSlot(resourceGroupName, name, slot, siteConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteConfig, options }, createOrUpdateConfigurationSlotOperationSpec);
    }
    /**
     * Description for Updates the configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update
     *             configuration for the production slot.
     * @param siteConfig JSON representation of a SiteConfig object. See example.
     * @param options The options parameters.
     */
    updateConfigurationSlot(resourceGroupName, name, slot, siteConfig, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteConfig, options }, updateConfigurationSlotOperationSpec);
    }
    /**
     * Description for Gets a list of web app configuration snapshots identifiers. Each element of the list
     * contains a timestamp and the ID of the snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    _listConfigurationSnapshotInfoSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listConfigurationSnapshotInfoSlotOperationSpec);
    }
    /**
     * Description for Gets a snapshot of the configuration of an app at a previous point in time.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    getConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, snapshotId, slot, options }, getConfigurationSnapshotSlotOperationSpec);
    }
    /**
     * Description for Reverts the configuration of an app to a previous snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param snapshotId The ID of the snapshot to read.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param options The options parameters.
     */
    recoverSiteConfigurationSnapshotSlot(resourceGroupName, name, snapshotId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, snapshotId, slot, options }, recoverSiteConfigurationSnapshotSlotOperationSpec);
    }
    /**
     * Description for Gets the last lines of docker logs for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getWebSiteContainerLogsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getWebSiteContainerLogsSlotOperationSpec);
    }
    /**
     * Description for Gets the ZIP archived docker log files for the given site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getContainerLogsZipSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getContainerLogsZipSlotOperationSpec);
    }
    /**
     * Description for List continuous web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    _listContinuousWebJobsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listContinuousWebJobsSlotOperationSpec);
    }
    /**
     * Description for Gets a continuous web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    getContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, getContinuousWebJobSlotOperationSpec);
    }
    /**
     * Description for Delete a continuous web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    deleteContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, deleteContinuousWebJobSlotOperationSpec);
    }
    /**
     * Description for Start a continuous web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    startContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, startContinuousWebJobSlotOperationSpec);
    }
    /**
     * Description for Stop a continuous web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    stopContinuousWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, stopContinuousWebJobSlotOperationSpec);
    }
    /**
     * List deployment statuses for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param options The options parameters.
     */
    _listSlotSiteDeploymentStatusesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSlotSiteDeploymentStatusesSlotOperationSpec);
    }
    /**
     * Gets the deployment status for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param deploymentStatusId GUID of the deployment operation.
     * @param options The options parameters.
     */
    beginGetSlotSiteDeploymentStatusSlot(resourceGroupName, name, slot, deploymentStatusId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, deploymentStatusId, options },
                spec: getSlotSiteDeploymentStatusSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the deployment status for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param deploymentStatusId GUID of the deployment operation.
     * @param options The options parameters.
     */
    beginGetSlotSiteDeploymentStatusSlotAndWait(resourceGroupName, name, slot, deploymentStatusId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetSlotSiteDeploymentStatusSlot(resourceGroupName, name, slot, deploymentStatusId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for List deployments for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listDeploymentsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listDeploymentsSlotOperationSpec);
    }
    /**
     * Description for Get a deployment by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets a deployment for
     *             the production slot.
     * @param options The options parameters.
     */
    getDeploymentSlot(resourceGroupName, name, id, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, slot, options }, getDeploymentSlotOperationSpec);
    }
    /**
     * Description for Create a deployment for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id ID of an existing deployment.
     * @param slot Name of the deployment slot. If a slot is not specified, the API creates a deployment
     *             for the production slot.
     * @param deployment Deployment details.
     * @param options The options parameters.
     */
    createDeploymentSlot(resourceGroupName, name, id, slot, deployment, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, slot, deployment, options }, createDeploymentSlotOperationSpec);
    }
    /**
     * Description for Delete a deployment by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id Deployment ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    deleteDeploymentSlot(resourceGroupName, name, id, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, slot, options }, deleteDeploymentSlotOperationSpec);
    }
    /**
     * Description for List deployment log for specific deployment for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param id The ID of a specific deployment. This is the value of the name property in the JSON
     *           response from "GET /api/sites/{siteName}/deployments".
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    listDeploymentLogSlot(resourceGroupName, name, id, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, id, slot, options }, listDeploymentLogSlotOperationSpec);
    }
    /**
     * Description for Discovers an existing app backup that can be restored from a blob in Azure storage.
     * Use this to get information about the databases stored in a backup.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will perform discovery
     *             for the production slot.
     * @param request A RestoreRequest object that includes Azure storage URL and blog name for discovery
     *                of backup.
     * @param options The options parameters.
     */
    discoverBackupSlot(resourceGroupName, name, slot, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, request, options }, discoverBackupSlotOperationSpec);
    }
    /**
     * Description for Lists ownership identifiers for domain associated with web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param options The options parameters.
     */
    _listDomainOwnershipIdentifiersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listDomainOwnershipIdentifiersSlotOperationSpec);
    }
    /**
     * Description for Get domain ownership identifier for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param options The options parameters.
     */
    getDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainOwnershipIdentifierName, slot, options }, getDomainOwnershipIdentifierSlotOperationSpec);
    }
    /**
     * Description for Creates a domain ownership identifier for web app, or updates an existing ownership
     * identifier.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    createOrUpdateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            domainOwnershipIdentifierName,
            slot,
            domainOwnershipIdentifier,
            options,
        }, createOrUpdateDomainOwnershipIdentifierSlotOperationSpec);
    }
    /**
     * Description for Deletes a domain ownership identifier for a web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param options The options parameters.
     */
    deleteDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, domainOwnershipIdentifierName, slot, options }, deleteDomainOwnershipIdentifierSlotOperationSpec);
    }
    /**
     * Description for Creates a domain ownership identifier for web app, or updates an existing ownership
     * identifier.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param domainOwnershipIdentifierName Name of domain ownership identifier.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param domainOwnershipIdentifier A JSON representation of the domain ownership properties.
     * @param options The options parameters.
     */
    updateDomainOwnershipIdentifierSlot(resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            domainOwnershipIdentifierName,
            slot,
            domainOwnershipIdentifier,
            options,
        }, updateDomainOwnershipIdentifierSlotOperationSpec);
    }
    /**
     * Description for Get the status of the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getMSDeployStatusSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getMSDeployStatusSlotOperationSpec);
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateMSDeployOperationSlot(resourceGroupName, name, slot, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, mSDeploy, options },
                spec: createMSDeployOperationSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateMSDeployOperationSlotAndWait(resourceGroupName, name, slot, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateMSDeployOperationSlot(resourceGroupName, name, slot, mSDeploy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get the MSDeploy Log for the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getMSDeployLogSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getMSDeployLogSlotOperationSpec);
    }
    /**
     * Description for List the functions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    _listInstanceFunctionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listInstanceFunctionsSlotOperationSpec);
    }
    /**
     * Description for Fetch a short lived token that can be exchanged for a master key.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getFunctionsAdminTokenSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getFunctionsAdminTokenSlotOperationSpec);
    }
    /**
     * Description for Get function information by its ID for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    getInstanceFunctionSlot(resourceGroupName, name, functionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, slot, options }, getInstanceFunctionSlotOperationSpec);
    }
    /**
     * Description for Create function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param functionEnvelope Function details.
     * @param options The options parameters.
     */
    beginCreateInstanceFunctionSlot(resourceGroupName, name, functionName, slot, functionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    functionName,
                    slot,
                    functionEnvelope,
                    options,
                },
                spec: createInstanceFunctionSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Create function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param functionEnvelope Function details.
     * @param options The options parameters.
     */
    beginCreateInstanceFunctionSlotAndWait(resourceGroupName, name, functionName, slot, functionEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateInstanceFunctionSlot(resourceGroupName, name, functionName, slot, functionEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Delete a function for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    deleteInstanceFunctionSlot(resourceGroupName, name, functionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, slot, options }, deleteInstanceFunctionSlotOperationSpec);
    }
    /**
     * Description for Add or update a function secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName The name of the function.
     * @param keyName The name of the key.
     * @param slot Name of the deployment slot.
     * @param key The key to create or update
     * @param options The options parameters.
     */
    createOrUpdateFunctionSecretSlot(resourceGroupName, name, functionName, keyName, slot, key, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, keyName, slot, key, options }, createOrUpdateFunctionSecretSlotOperationSpec);
    }
    /**
     * Description for Delete a function secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName The name of the function.
     * @param keyName The name of the key.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    deleteFunctionSecretSlot(resourceGroupName, name, functionName, keyName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, keyName, slot, options }, deleteFunctionSecretSlotOperationSpec);
    }
    /**
     * Description for Get function keys for a function in a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listFunctionKeysSlot(resourceGroupName, name, functionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, slot, options }, listFunctionKeysSlotOperationSpec);
    }
    /**
     * Description for Get function secrets for a function in a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param functionName Function name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listFunctionSecretsSlot(resourceGroupName, name, functionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, functionName, slot, options }, listFunctionSecretsSlotOperationSpec);
    }
    /**
     * Description for Get host secrets for a function app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listHostKeysSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listHostKeysSlotOperationSpec);
    }
    /**
     * Description for This is to allow calling via powershell and ARM template.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listSyncStatusSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSyncStatusSlotOperationSpec);
    }
    /**
     * Description for Syncs function trigger metadata to the management database
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    syncFunctionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, syncFunctionsSlotOperationSpec);
    }
    /**
     * Description for Add or update a host level secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param keyType The type of host key.
     * @param keyName The name of the key.
     * @param slot Name of the deployment slot.
     * @param key The key to create or update
     * @param options The options parameters.
     */
    createOrUpdateHostSecretSlot(resourceGroupName, name, keyType, keyName, slot, key, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyType, keyName, slot, key, options }, createOrUpdateHostSecretSlotOperationSpec);
    }
    /**
     * Description for Delete a host level secret.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param keyType The type of host key.
     * @param keyName The name of the key.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    deleteHostSecretSlot(resourceGroupName, name, keyType, keyName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyType, keyName, slot, options }, deleteHostSecretSlotOperationSpec);
    }
    /**
     * Description for Get hostname bindings for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param options The options parameters.
     */
    _listHostNameBindingsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listHostNameBindingsSlotOperationSpec);
    }
    /**
     * Description for Get the named hostname binding for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for
     *             the production slot.
     * @param hostName Hostname in the hostname binding.
     * @param options The options parameters.
     */
    getHostNameBindingSlot(resourceGroupName, name, slot, hostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, hostName, options }, getHostNameBindingSlotOperationSpec);
    }
    /**
     * Description for Creates a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param hostName Hostname in the hostname binding.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding
     *             for the production slot.
     * @param hostNameBinding Binding details. This is the JSON representation of a HostNameBinding object.
     * @param options The options parameters.
     */
    createOrUpdateHostNameBindingSlot(resourceGroupName, name, hostName, slot, hostNameBinding, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, hostName, slot, hostNameBinding, options }, createOrUpdateHostNameBindingSlotOperationSpec);
    }
    /**
     * Description for Deletes a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param hostName Hostname in the hostname binding.
     * @param options The options parameters.
     */
    deleteHostNameBindingSlot(resourceGroupName, name, slot, hostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, hostName, options }, deleteHostNameBindingSlotOperationSpec);
    }
    /**
     * Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param options The options parameters.
     */
    getHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, slot, options }, getHybridConnectionSlotOperationSpec);
    }
    /**
     * Description for Creates a new Hybrid Connection using a Service Bus relay.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param options The options parameters.
     */
    createOrUpdateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            namespaceName,
            relayName,
            slot,
            connectionEnvelope,
            options,
        }, createOrUpdateHybridConnectionSlotOperationSpec);
    }
    /**
     * Description for Removes a Hybrid Connection from this site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param options The options parameters.
     */
    deleteHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, namespaceName, relayName, slot, options }, deleteHybridConnectionSlotOperationSpec);
    }
    /**
     * Description for Creates a new Hybrid Connection using a Service Bus relay.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param namespaceName The namespace for this hybrid connection.
     * @param relayName The relay name for this hybrid connection.
     * @param slot The name of the slot for the web app.
     * @param connectionEnvelope The details of the hybrid connection.
     * @param options The options parameters.
     */
    updateHybridConnectionSlot(resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            namespaceName,
            relayName,
            slot,
            connectionEnvelope,
            options,
        }, updateHybridConnectionSlotOperationSpec);
    }
    /**
     * Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @param options The options parameters.
     */
    listHybridConnectionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listHybridConnectionsSlotOperationSpec);
    }
    /**
     * Description for Gets hybrid connections configured for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get hybrid
     *             connections for the production slot.
     * @param options The options parameters.
     */
    listRelayServiceConnectionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listRelayServiceConnectionsSlotOperationSpec);
    }
    /**
     * Description for Gets a hybrid connection configuration by its name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a hybrid
     *             connection for the production slot.
     * @param options The options parameters.
     */
    getRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, slot, options }, getRelayServiceConnectionSlotOperationSpec);
    }
    /**
     * Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
     * (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a
     *             hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param options The options parameters.
     */
    createOrUpdateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            entityName,
            slot,
            connectionEnvelope,
            options,
        }, createOrUpdateRelayServiceConnectionSlotOperationSpec);
    }
    /**
     * Description for Deletes a relay service connection by its name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete a hybrid
     *             connection for the production slot.
     * @param options The options parameters.
     */
    deleteRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, entityName, slot, options }, deleteRelayServiceConnectionSlotOperationSpec);
    }
    /**
     * Description for Creates a new hybrid connection configuration (PUT), or updates an existing one
     * (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param entityName Name of the hybrid connection configuration.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create or update a
     *             hybrid connection for the production slot.
     * @param connectionEnvelope Details of the hybrid connection configuration.
     * @param options The options parameters.
     */
    updateRelayServiceConnectionSlot(resourceGroupName, name, entityName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            entityName,
            slot,
            connectionEnvelope,
            options,
        }, updateRelayServiceConnectionSlotOperationSpec);
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production
     *             slot instances.
     * @param options The options parameters.
     */
    _listInstanceIdentifiersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listInstanceIdentifiersSlotOperationSpec);
    }
    /**
     * Description for Gets all scale-out instances of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param instanceId
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production
     *             slot instances.
     * @param options The options parameters.
     */
    getInstanceInfoSlot(resourceGroupName, name, instanceId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, slot, options }, getInstanceInfoSlotOperationSpec);
    }
    /**
     * Description for Get the status of the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param options The options parameters.
     */
    getInstanceMsDeployStatusSlot(resourceGroupName, name, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, instanceId, options }, getInstanceMsDeployStatusSlotOperationSpec);
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateInstanceMSDeployOperationSlot(resourceGroupName, name, slot, instanceId, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, instanceId, mSDeploy, options },
                spec: createInstanceMSDeployOperationSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Invoke the MSDeploy web app extension.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param mSDeploy Details of MSDeploy operation
     * @param options The options parameters.
     */
    beginCreateInstanceMSDeployOperationSlotAndWait(resourceGroupName, name, slot, instanceId, mSDeploy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateInstanceMSDeployOperationSlot(resourceGroupName, name, slot, instanceId, mSDeploy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Get the MSDeploy Log for the last MSDeploy operation.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param instanceId ID of web app instance.
     * @param options The options parameters.
     */
    getInstanceMSDeployLogSlot(resourceGroupName, name, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, instanceId, options }, getInstanceMSDeployLogSlotOperationSpec);
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessesSlot(resourceGroupName, name, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, instanceId, options }, listInstanceProcessesSlotOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, getInstanceProcessSlotOperationSpec);
    }
    /**
     * Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    deleteInstanceProcessSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, deleteInstanceProcessSlotOperationSpec);
    }
    /**
     * Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessDumpSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, getInstanceProcessDumpSlotOperationSpec);
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessModulesSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, listInstanceProcessModulesSlotOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    getInstanceProcessModuleSlot(resourceGroupName, name, processId, baseAddress, slot, instanceId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            processId,
            baseAddress,
            slot,
            instanceId,
            options,
        }, getInstanceProcessModuleSlotOperationSpec);
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param options The options parameters.
     */
    _listInstanceProcessThreadsSlot(resourceGroupName, name, processId, slot, instanceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, instanceId, options }, listInstanceProcessThreadsSlotOperationSpec);
    }
    /**
     * Description for Shows whether an app can be cloned to another resource group or subscription.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. By default, this API returns information on the production
     *             slot.
     * @param options The options parameters.
     */
    isCloneableSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, isCloneableSlotOperationSpec);
    }
    /**
     * Description for Gets existing backups of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param options The options parameters.
     */
    _listSiteBackupsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSiteBackupsSlotOperationSpec);
    }
    /**
     * Description for This is to allow calling via powershell and ARM template.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listSyncFunctionTriggersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSyncFunctionTriggersSlotOperationSpec);
    }
    /**
     * Description for Returns the status of MySql in app migration, if one is active, and whether or not
     * MySql in app is enabled
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    getMigrateMySqlStatusSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getMigrateMySqlStatusSlotOperationSpec);
    }
    /**
     * Description for Gets a Swift Virtual Network connection.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for
     *             the production slot's Virtual Network.
     * @param options The options parameters.
     */
    getSwiftVirtualNetworkConnectionSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSwiftVirtualNetworkConnectionSlotOperationSpec);
    }
    /**
     * Description for Integrates this Web App with a Virtual Network. This requires that 1)
     * "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
     * already been delegated, and is not
     * in use by another App Service Plan other than the one this App is in.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update
     *             connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot(resourceGroupName, name, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, connectionEnvelope, options }, createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOperationSpec);
    }
    /**
     * Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the
     *             connection for the production slot.
     * @param options The options parameters.
     */
    deleteSwiftVirtualNetworkSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, deleteSwiftVirtualNetworkSlotOperationSpec);
    }
    /**
     * Description for Integrates this Web App with a Virtual Network. This requires that 1)
     * "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has
     * already been delegated, and is not
     * in use by another App Service Plan other than the one this App is in.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update
     *             connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    updateSwiftVirtualNetworkConnectionWithCheckSlot(resourceGroupName, name, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, connectionEnvelope, options }, updateSwiftVirtualNetworkConnectionWithCheckSlotOperationSpec);
    }
    /**
     * Description for Gets all network features used by the app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param view The type of view. Only "summary" is supported at this time.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get network
     *             features for the production slot.
     * @param options The options parameters.
     */
    listNetworkFeaturesSlot(resourceGroupName, name, view, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, view, slot, options }, listNetworkFeaturesSlotOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get an operation
     *             for the production slot.
     * @param options The options parameters.
     */
    getNetworkTraceOperationSlot(resourceGroupName, name, operationId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, slot, options }, getNetworkTraceOperationSlotOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site (To be deprecated).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    startWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, startWebSiteNetworkTraceSlotOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    beginStartWebSiteNetworkTraceOperationSlot(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, options },
                spec: startWebSiteNetworkTraceOperationSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    beginStartWebSiteNetworkTraceOperationSlotAndWait(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartWebSiteNetworkTraceOperationSlot(resourceGroupName, name, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Stop ongoing capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    stopWebSiteNetworkTraceSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, stopWebSiteNetworkTraceSlotOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get an operation
     *             for the production slot.
     * @param options The options parameters.
     */
    getNetworkTracesSlot(resourceGroupName, name, operationId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, slot, options }, getNetworkTracesSlotOperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get an operation
     *             for the production slot.
     * @param options The options parameters.
     */
    getNetworkTraceOperationSlotV2(resourceGroupName, name, operationId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, slot, options }, getNetworkTraceOperationSlotV2OperationSpec);
    }
    /**
     * Description for Gets a named operation for a network trace capturing (or deployment slot, if
     * specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param operationId GUID of the operation.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get an operation
     *             for the production slot.
     * @param options The options parameters.
     */
    getNetworkTracesSlotV2(resourceGroupName, name, operationId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, operationId, slot, options }, getNetworkTracesSlotV2OperationSpec);
    }
    /**
     * Description for Generates a new publishing password for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API generate a new
     *             publishing password for the production slot.
     * @param options The options parameters.
     */
    generateNewSitePublishingPasswordSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, generateNewSitePublishingPasswordSlotOperationSpec);
    }
    /**
     * Description for Gets perfmon counters for web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    _listPerfMonCountersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listPerfMonCountersSlotOperationSpec);
    }
    /**
     * Description for Gets web app's event logs.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    getSitePhpErrorLogFlagSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSitePhpErrorLogFlagSlotOperationSpec);
    }
    /**
     * Description for Gets the premier add-ons of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the premier
     *             add-ons for the production slot.
     * @param options The options parameters.
     */
    listPremierAddOnsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listPremierAddOnsSlotOperationSpec);
    }
    /**
     * Description for Gets a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named
     *             add-on for the production slot.
     * @param options The options parameters.
     */
    getPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, slot, options }, getPremierAddOnSlotOperationSpec);
    }
    /**
     * Description for Updates a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named
     *             add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param options The options parameters.
     */
    addPremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, premierAddOn, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            premierAddOnName,
            slot,
            premierAddOn,
            options,
        }, addPremierAddOnSlotOperationSpec);
    }
    /**
     * Description for Delete a premier add-on from an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the named
     *             add-on for the production slot.
     * @param options The options parameters.
     */
    deletePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, premierAddOnName, slot, options }, deletePremierAddOnSlotOperationSpec);
    }
    /**
     * Description for Updates a named add-on of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param premierAddOnName Add-on name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the named
     *             add-on for the production slot.
     * @param premierAddOn A JSON representation of the edited premier add-on.
     * @param options The options parameters.
     */
    updatePremierAddOnSlot(resourceGroupName, name, premierAddOnName, slot, premierAddOn, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            premierAddOnName,
            slot,
            premierAddOn,
            options,
        }, updatePremierAddOnSlotOperationSpec);
    }
    /**
     * Description for Gets data around private site access enablement and authorized Virtual Networks that
     * can access the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @param options The options parameters.
     */
    getPrivateAccessSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getPrivateAccessSlotOperationSpec);
    }
    /**
     * Description for Sets data around private site access enablement and authorized Virtual Networks that
     * can access the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for the web app.
     * @param access The information for the private access
     * @param options The options parameters.
     */
    putPrivateAccessVnetSlot(resourceGroupName, name, slot, access, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, access, options }, putPrivateAccessVnetSlotOperationSpec);
    }
    /**
     * Description for Gets the list of private endpoint connections associated with a site
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param slot Name of the site deployment slot.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getPrivateEndpointConnectionListSlotOperationSpec);
    }
    /**
     * Description for Gets a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName Name of the private endpoint connection.
     * @param slot Name of the site deployment slot.
     * @param options The options parameters.
     */
    getPrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, slot, options }, getPrivateEndpointConnectionSlotOperationSpec);
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param slot
     * @param privateEndpointWrapper Remote Private Endpoint Connection ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    privateEndpointConnectionName,
                    slot,
                    privateEndpointWrapper,
                    options,
                },
                spec: approveOrRejectPrivateEndpointConnectionSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Approves or rejects a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param slot
     * @param privateEndpointWrapper Remote Private Endpoint Connection ARM resource.
     * @param options The options parameters.
     */
    beginApproveOrRejectPrivateEndpointConnectionSlotAndWait(resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApproveOrRejectPrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param slot
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    privateEndpointConnectionName,
                    slot,
                    options,
                },
                spec: deletePrivateEndpointConnectionSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Deletes a private endpoint connection
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param privateEndpointConnectionName
     * @param slot
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionSlotAndWait(resourceGroupName, name, privateEndpointConnectionName, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnectionSlot(resourceGroupName, name, privateEndpointConnectionName, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Gets the private link resources
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param slot
     * @param options The options parameters.
     */
    getPrivateLinkResourcesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getPrivateLinkResourcesSlotOperationSpec);
    }
    /**
     * Description for Get list of processes for a web site, or a deployment slot, or for a specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listProcessesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listProcessesSlotOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    getProcessSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, getProcessSlotOperationSpec);
    }
    /**
     * Description for Terminate a process by its ID for a web site, or a deployment slot, or specific
     * scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    deleteProcessSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, deleteProcessSlotOperationSpec);
    }
    /**
     * Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    getProcessDumpSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, getProcessDumpSlotOperationSpec);
    }
    /**
     * Description for List module information for a process by its ID for a specific scaled-out instance
     * in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listProcessModulesSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, listProcessModulesSlotOperationSpec);
    }
    /**
     * Description for Get process information by its ID for a specific scaled-out instance in a web site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param baseAddress Module base address.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    getProcessModuleSlot(resourceGroupName, name, processId, baseAddress, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, baseAddress, slot, options }, getProcessModuleSlotOperationSpec);
    }
    /**
     * Description for List the threads in a process by its ID for a specific scaled-out instance in a web
     * site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listProcessThreadsSlot(resourceGroupName, name, processId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, options }, listProcessThreadsSlotOperationSpec);
    }
    /**
     * Description for Get public certificates for an app or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param options The options parameters.
     */
    _listPublicCertificatesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listPublicCertificatesSlotOperationSpec);
    }
    /**
     * Description for Get the named public certificate for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API the named binding for
     *             the production slot.
     * @param publicCertificateName Public certificate name.
     * @param options The options parameters.
     */
    getPublicCertificateSlot(resourceGroupName, name, slot, publicCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, publicCertificateName, options }, getPublicCertificateSlotOperationSpec);
    }
    /**
     * Description for Creates a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param publicCertificateName Public certificate name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create a binding
     *             for the production slot.
     * @param publicCertificate Public certificate details. This is the JSON representation of a
     *                          PublicCertificate object.
     * @param options The options parameters.
     */
    createOrUpdatePublicCertificateSlot(resourceGroupName, name, publicCertificateName, slot, publicCertificate, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            publicCertificateName,
            slot,
            publicCertificate,
            options,
        }, createOrUpdatePublicCertificateSlotOperationSpec);
    }
    /**
     * Description for Deletes a hostname binding for an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param publicCertificateName Public certificate name.
     * @param options The options parameters.
     */
    deletePublicCertificateSlot(resourceGroupName, name, slot, publicCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, publicCertificateName, options }, deletePublicCertificateSlotOperationSpec);
    }
    /**
     * Description for Gets the publishing profile for an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the publishing
     *             profile for the production slot.
     * @param publishingProfileOptions Specifies publishingProfileOptions for publishing profile. For
     *                                 example, use {"format": "FileZilla3"} to get a FileZilla publishing profile.
     * @param options The options parameters.
     */
    listPublishingProfileXmlWithSecretsSlot(resourceGroupName, name, slot, publishingProfileOptions, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, publishingProfileOptions, options }, listPublishingProfileXmlWithSecretsSlotOperationSpec);
    }
    /**
     * Description for Resets the configuration settings of the current slot if they were previously
     * modified by calling the API with POST.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API resets configuration
     *             settings for the production slot.
     * @param options The options parameters.
     */
    resetSlotConfigurationSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, resetSlotConfigurationSlotOperationSpec);
    }
    /**
     * Description for Restarts an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restart the
     *             production slot.
     * @param options The options parameters.
     */
    restartSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, restartSlotOperationSpec);
    }
    /**
     * Description for Restores an app from a backup blob in Azure Storage.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup
     *             of the production slot.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreFromBackupBlobSlot(resourceGroupName, name, slot, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, request, options },
                spec: restoreFromBackupBlobSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores an app from a backup blob in Azure Storage.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will restore a backup
     *             of the production slot.
     * @param request Information on restore request .
     * @param options The options parameters.
     */
    beginRestoreFromBackupBlobSlotAndWait(resourceGroupName, name, slot, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreFromBackupBlobSlot(resourceGroupName, name, slot, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Restores a deleted web app to this web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param restoreRequest Deleted web app restore information.
     * @param options The options parameters.
     */
    beginRestoreFromDeletedAppSlot(resourceGroupName, name, slot, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, restoreRequest, options },
                spec: restoreFromDeletedAppSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a deleted web app to this web app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param restoreRequest Deleted web app restore information.
     * @param options The options parameters.
     */
    beginRestoreFromDeletedAppSlotAndWait(resourceGroupName, name, slot, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreFromDeletedAppSlot(resourceGroupName, name, slot, restoreRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Restores a web app from a snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param restoreRequest Snapshot restore settings. Snapshot information can be obtained by calling
     *                       GetDeletedSites or GetSiteSnapshots API.
     * @param options The options parameters.
     */
    beginRestoreSnapshotSlot(resourceGroupName, name, slot, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, restoreRequest, options },
                spec: restoreSnapshotSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Restores a web app from a snapshot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param restoreRequest Snapshot restore settings. Snapshot information can be obtained by calling
     *                       GetDeletedSites or GetSiteSnapshots API.
     * @param options The options parameters.
     */
    beginRestoreSnapshotSlotAndWait(resourceGroupName, name, slot, restoreRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreSnapshotSlot(resourceGroupName, name, slot, restoreRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the site containers of a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a list of site
     *             containers for the production slot.
     * @param options The options parameters.
     */
    _listSiteContainersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSiteContainersSlotOperationSpec);
    }
    /**
     * Gets a site container of a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the Site
     *             Container for the production slot.
     * @param containerName Site Container Name
     * @param options The options parameters.
     */
    getSiteContainerSlot(resourceGroupName, name, slot, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, containerName, options }, getSiteContainerSlotOperationSpec);
    }
    /**
     * Creates or Updates a site container for a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will create the
     *             container for the production slot.
     * @param containerName Site Container Name
     * @param request Container Entity
     * @param options The options parameters.
     */
    createOrUpdateSiteContainerSlot(resourceGroupName, name, slot, containerName, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, containerName, request, options }, createOrUpdateSiteContainerSlotOperationSpec);
    }
    /**
     * Deletes a site container for a site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the
     *             container for the production slot.
     * @param containerName Site Container Name
     * @param options The options parameters.
     */
    deleteSiteContainerSlot(resourceGroupName, name, slot, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, containerName, options }, deleteSiteContainerSlotOperationSpec);
    }
    /**
     * Description for Get list of siteextensions for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    _listSiteExtensionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSiteExtensionsSlotOperationSpec);
    }
    /**
     * Description for Get site extension information by its ID for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    getSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteExtensionId, slot, options }, getSiteExtensionSlotOperationSpec);
    }
    /**
     * Description for Install site extension on a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    beginInstallSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, siteExtensionId, slot, options },
                spec: installSiteExtensionSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Install site extension on a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    beginInstallSiteExtensionSlotAndWait(resourceGroupName, name, siteExtensionId, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInstallSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Remove a site extension from a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param siteExtensionId Site extension name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    deleteSiteExtensionSlot(resourceGroupName, name, siteExtensionId, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteExtensionId, slot, options }, deleteSiteExtensionSlotOperationSpec);
    }
    /**
     * Description for Get the difference in configuration settings between two web app slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    _listSlotDifferencesSlot(resourceGroupName, name, slot, slotSwapEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, slotSwapEntity, options }, listSlotDifferencesSlotOperationSpec);
    }
    /**
     * Description for Swaps two deployment slots of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    beginSwapSlot(resourceGroupName, name, slot, slotSwapEntity, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, slotSwapEntity, options },
                spec: swapSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Swaps two deployment slots of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    beginSwapSlotAndWait(resourceGroupName, name, slot, slotSwapEntity, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSwapSlot(resourceGroupName, name, slot, slotSwapEntity, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns all Snapshots to the user.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param options The options parameters.
     */
    _listSnapshotsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSnapshotsSlotOperationSpec);
    }
    /**
     * Description for Returns all Snapshots to the user from DRSecondary endpoint.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param options The options parameters.
     */
    _listSnapshotsFromDRSecondarySlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listSnapshotsFromDRSecondarySlotOperationSpec);
    }
    /**
     * Description for Gets the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the source
     *             control configuration for the production slot.
     * @param options The options parameters.
     */
    getSourceControlSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, getSourceControlSlotOperationSpec);
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source
     *             control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, slot, siteSourceControl, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, siteSourceControl, options },
                spec: createOrUpdateSourceControlSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source
     *             control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSourceControlSlotAndWait(resourceGroupName, name, slot, siteSourceControl, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateSourceControlSlot(resourceGroupName, name, slot, siteSourceControl, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the source
     *             control configuration for the production slot.
     * @param options The options parameters.
     */
    deleteSourceControlSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, deleteSourceControlSlotOperationSpec);
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will update the source
     *             control configuration for the production slot.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    updateSourceControlSlot(resourceGroupName, name, slot, siteSourceControl, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, siteSourceControl, options }, updateSourceControlSlotOperationSpec);
    }
    /**
     * Description for Starts an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will start the
     *             production slot.
     * @param options The options parameters.
     */
    startSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, startSlotOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    beginStartNetworkTraceSlot(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slot, options },
                spec: startNetworkTraceSlotOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    beginStartNetworkTraceSlotAndWait(resourceGroupName, name, slot, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartNetworkTraceSlot(resourceGroupName, name, slot, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Stops an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will stop the
     *             production slot.
     * @param options The options parameters.
     */
    stopSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, stopSlotOperationSpec);
    }
    /**
     * Description for Stop ongoing capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param slot The name of the slot for this web app.
     * @param options The options parameters.
     */
    stopNetworkTraceSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, stopNetworkTraceSlotOperationSpec);
    }
    /**
     * Description for Sync web app repository.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param options The options parameters.
     */
    syncRepositorySlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, syncRepositorySlotOperationSpec);
    }
    /**
     * Description for Syncs function trigger metadata to the management database
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    syncFunctionTriggersSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, syncFunctionTriggersSlotOperationSpec);
    }
    /**
     * Description for List triggered web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param options The options parameters.
     */
    _listTriggeredWebJobsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listTriggeredWebJobsSlotOperationSpec);
    }
    /**
     * Description for Gets a triggered web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    getTriggeredWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, getTriggeredWebJobSlotOperationSpec);
    }
    /**
     * Description for Delete a triggered web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes web job for the
     *             production slot.
     * @param options The options parameters.
     */
    deleteTriggeredWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, deleteTriggeredWebJobSlotOperationSpec);
    }
    /**
     * Description for List a triggered web job's history for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    _listTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, listTriggeredWebJobHistorySlotOperationSpec);
    }
    /**
     * Description for Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    getTriggeredWebJobHistorySlot(resourceGroupName, name, webJobName, id, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, id, slot, options }, getTriggeredWebJobHistorySlotOperationSpec);
    }
    /**
     * Description for Run a triggered web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param options The options parameters.
     */
    runTriggeredWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, runTriggeredWebJobSlotOperationSpec);
    }
    /**
     * Description for Gets the quota usage information of an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota
     *             information of the production slot.
     * @param options The options parameters.
     */
    _listUsagesSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listUsagesSlotOperationSpec);
    }
    /**
     * Description for Gets the virtual networks the app (or deployment slot) is connected to.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get virtual
     *             network connections for the production slot.
     * @param options The options parameters.
     */
    listVnetConnectionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listVnetConnectionsSlotOperationSpec);
    }
    /**
     * Description for Gets a virtual network the app (or deployment slot) is connected to by name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the named
     *             virtual network for the production slot.
     * @param options The options parameters.
     */
    getVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, slot, options }, getVnetConnectionSlotOperationSpec);
    }
    /**
     * Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
     * properties (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update
     *             connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    createOrUpdateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, slot, connectionEnvelope, options }, createOrUpdateVnetConnectionSlotOperationSpec);
    }
    /**
     * Description for Deletes a connection from an app (or deployment slot to a named virtual network.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the
     *             connection for the production slot.
     * @param options The options parameters.
     */
    deleteVnetConnectionSlot(resourceGroupName, name, vnetName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, slot, options }, deleteVnetConnectionSlotOperationSpec);
    }
    /**
     * Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
     * properties (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update
     *             connections for the production slot.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    updateVnetConnectionSlot(resourceGroupName, name, vnetName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, slot, connectionEnvelope, options }, updateVnetConnectionSlotOperationSpec);
    }
    /**
     * Description for Gets an app's Virtual Network gateway.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a gateway for
     *             the production slot's Virtual Network.
     * @param options The options parameters.
     */
    getVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, gatewayName, slot, options }, getVnetConnectionGatewaySlotOperationSpec);
    }
    /**
     * Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a
     *             gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param options The options parameters.
     */
    createOrUpdateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            slot,
            connectionEnvelope,
            options,
        }, createOrUpdateVnetConnectionGatewaySlotOperationSpec);
    }
    /**
     * Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param slot Name of the deployment slot. If a slot is not specified, the API will add or update a
     *             gateway for the production slot's Virtual Network.
     * @param connectionEnvelope The properties to update this gateway with.
     * @param options The options parameters.
     */
    updateVnetConnectionGatewaySlot(resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            slot,
            connectionEnvelope,
            options,
        }, updateVnetConnectionGatewaySlotOperationSpec);
    }
    /**
     * Description for List webjobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    _listWebJobsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listWebJobsSlotOperationSpec);
    }
    /**
     * Description for Get webjob information for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param options The options parameters.
     */
    getWebJobSlot(resourceGroupName, name, webJobName, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, options }, getWebJobSlotOperationSpec);
    }
    /**
     * Description for Get the difference in configuration settings between two web app slots.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    _listSlotDifferencesFromProduction(resourceGroupName, name, slotSwapEntity, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slotSwapEntity, options }, listSlotDifferencesFromProductionOperationSpec);
    }
    /**
     * Description for Swaps two deployment slots of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, slotSwapEntity, options },
                spec: swapSlotWithProductionOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Swaps two deployment slots of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param options The options parameters.
     */
    beginSwapSlotWithProductionAndWait(resourceGroupName, name, slotSwapEntity, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSwapSlotWithProduction(resourceGroupName, name, slotSwapEntity, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Returns all Snapshots to the user.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param options The options parameters.
     */
    _listSnapshots(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSnapshotsOperationSpec);
    }
    /**
     * Description for Returns all Snapshots to the user from DRSecondary endpoint.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param options The options parameters.
     */
    _listSnapshotsFromDRSecondary(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listSnapshotsFromDRSecondaryOperationSpec);
    }
    /**
     * Description for Gets the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    getSourceControl(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getSourceControlOperationSpec$1);
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, siteSourceControl, options },
                spec: createOrUpdateSourceControlOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSourceControlAndWait(resourceGroupName, name, siteSourceControl, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateSourceControl(resourceGroupName, name, siteSourceControl, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Deletes the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    deleteSourceControl(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteSourceControlOperationSpec);
    }
    /**
     * Description for Updates the source control configuration of an app.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param siteSourceControl JSON representation of a SiteSourceControl object. See example.
     * @param options The options parameters.
     */
    updateSourceControl(resourceGroupName, name, siteSourceControl, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, siteSourceControl, options }, updateSourceControlOperationSpec$1);
    }
    /**
     * Description for Starts an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    start(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, startOperationSpec);
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    beginStartNetworkTrace(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: startNetworkTraceOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Description for Start capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    beginStartNetworkTraceAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartNetworkTrace(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Description for Stops an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    stop(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, stopOperationSpec);
    }
    /**
     * Description for Stop ongoing capturing network packets for the site.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name The name of the web app.
     * @param options The options parameters.
     */
    stopNetworkTrace(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, stopNetworkTraceOperationSpec);
    }
    /**
     * Description for Sync web app repository.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param options The options parameters.
     */
    syncRepository(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, syncRepositoryOperationSpec);
    }
    /**
     * Description for Syncs function trigger metadata to the management database
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    syncFunctionTriggers(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, syncFunctionTriggersOperationSpec);
    }
    /**
     * Description for List triggered web jobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listTriggeredWebJobs(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listTriggeredWebJobsOperationSpec);
    }
    /**
     * Description for Gets a triggered web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    getTriggeredWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, getTriggeredWebJobOperationSpec);
    }
    /**
     * Description for Delete a triggered web job by its ID for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    deleteTriggeredWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, deleteTriggeredWebJobOperationSpec);
    }
    /**
     * Description for List a triggered web job's history for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    _listTriggeredWebJobHistory(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, listTriggeredWebJobHistoryOperationSpec);
    }
    /**
     * Description for Gets a triggered web job's history by its ID for an app, , or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param id History ID.
     * @param options The options parameters.
     */
    getTriggeredWebJobHistory(resourceGroupName, name, webJobName, id, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, id, options }, getTriggeredWebJobHistoryOperationSpec);
    }
    /**
     * Description for Run a triggered web job for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param options The options parameters.
     */
    runTriggeredWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, runTriggeredWebJobOperationSpec);
    }
    /**
     * Description for Gets the quota usage information of an app (or deployment slot, if specified).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listUsagesOperationSpec);
    }
    /**
     * Description for Gets the virtual networks the app (or deployment slot) is connected to.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param options The options parameters.
     */
    listVnetConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listVnetConnectionsOperationSpec);
    }
    /**
     * Description for Gets a virtual network the app (or deployment slot) is connected to by name.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param options The options parameters.
     */
    getVnetConnection(resourceGroupName, name, vnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, options }, getVnetConnectionOperationSpec);
    }
    /**
     * Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
     * properties (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    createOrUpdateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, connectionEnvelope, options }, createOrUpdateVnetConnectionOperationSpec);
    }
    /**
     * Description for Deletes a connection from an app (or deployment slot to a named virtual network.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the virtual network.
     * @param options The options parameters.
     */
    deleteVnetConnection(resourceGroupName, name, vnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, options }, deleteVnetConnectionOperationSpec);
    }
    /**
     * Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection
     * properties (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of an existing Virtual Network.
     * @param connectionEnvelope Properties of the Virtual Network connection. See example.
     * @param options The options parameters.
     */
    updateVnetConnection(resourceGroupName, name, vnetName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, connectionEnvelope, options }, updateVnetConnectionOperationSpec);
    }
    /**
     * Description for Gets an app's Virtual Network gateway.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param options The options parameters.
     */
    getVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, vnetName, gatewayName, options }, getVnetConnectionGatewayOperationSpec);
    }
    /**
     * Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @param options The options parameters.
     */
    createOrUpdateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            connectionEnvelope,
            options,
        }, createOrUpdateVnetConnectionGatewayOperationSpec);
    }
    /**
     * Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param vnetName Name of the Virtual Network.
     * @param gatewayName Name of the gateway. Currently, the only supported string is "primary".
     * @param connectionEnvelope The properties to update this gateway with.
     * @param options The options parameters.
     */
    updateVnetConnectionGateway(resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            vnetName,
            gatewayName,
            connectionEnvelope,
            options,
        }, updateVnetConnectionGatewayOperationSpec);
    }
    /**
     * Description for List webjobs for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listWebJobs(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWebJobsOperationSpec);
    }
    /**
     * Description for Get webjob information for an app, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of the web job.
     * @param options The options parameters.
     */
    getWebJob(resourceGroupName, name, webJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, options }, getWebJobOperationSpec);
    }
    /**
     * Description for Creates the artifacts for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    deployWorkflowArtifacts(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deployWorkflowArtifactsOperationSpec);
    }
    /**
     * Description for Creates the artifacts for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    deployWorkflowArtifactsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, deployWorkflowArtifactsSlotOperationSpec);
    }
    /**
     * List the workflows for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    _listInstanceWorkflowsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listInstanceWorkflowsSlotOperationSpec);
    }
    /**
     * Get workflow information by its ID for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param workflowName Workflow name.
     * @param options The options parameters.
     */
    getInstanceWorkflowSlot(resourceGroupName, name, slot, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, workflowName, options }, getInstanceWorkflowSlotOperationSpec);
    }
    /**
     * Lists logic app's connections for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param options The options parameters.
     */
    listWorkflowsConnectionsSlot(resourceGroupName, name, slot, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, options }, listWorkflowsConnectionsSlotOperationSpec);
    }
    /**
     * List the workflows for a web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    _listWorkflows(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWorkflowsOperationSpec);
    }
    /**
     * Get workflow information by its ID for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName Workflow name.
     * @param options The options parameters.
     */
    getWorkflow(resourceGroupName, name, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, options }, getWorkflowOperationSpec);
    }
    /**
     * Lists logic app's connections for web site, or a deployment slot.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param options The options parameters.
     */
    listWorkflowsConnections(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listWorkflowsConnectionsOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$8);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBackupsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListBackups method.
     * @param options The options parameters.
     */
    _listBackupsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listBackupsNextOperationSpec);
    }
    /**
     * ListBasicPublishingCredentialsPoliciesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListBasicPublishingCredentialsPolicies method.
     * @param options The options parameters.
     */
    _listBasicPublishingCredentialsPoliciesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listBasicPublishingCredentialsPoliciesNextOperationSpec);
    }
    /**
     * ListConfigurationsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListConfigurations method.
     * @param options The options parameters.
     */
    _listConfigurationsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listConfigurationsNextOperationSpec);
    }
    /**
     * GetAppSettingsKeyVaultReferencesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetAppSettingsKeyVaultReferences method.
     * @param options The options parameters.
     */
    _getAppSettingsKeyVaultReferencesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getAppSettingsKeyVaultReferencesNextOperationSpec);
    }
    /**
     * GetSiteConnectionStringKeyVaultReferencesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetSiteConnectionStringKeyVaultReferences method.
     * @param options The options parameters.
     */
    _getSiteConnectionStringKeyVaultReferencesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getSiteConnectionStringKeyVaultReferencesNextOperationSpec);
    }
    /**
     * ListConfigurationSnapshotInfoNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListConfigurationSnapshotInfo
     *                 method.
     * @param options The options parameters.
     */
    _listConfigurationSnapshotInfoNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listConfigurationSnapshotInfoNextOperationSpec);
    }
    /**
     * ListContinuousWebJobsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListContinuousWebJobs method.
     * @param options The options parameters.
     */
    _listContinuousWebJobsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listContinuousWebJobsNextOperationSpec);
    }
    /**
     * ListProductionSiteDeploymentStatusesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListProductionSiteDeploymentStatuses method.
     * @param options The options parameters.
     */
    _listProductionSiteDeploymentStatusesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listProductionSiteDeploymentStatusesNextOperationSpec);
    }
    /**
     * ListDeploymentsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListDeployments method.
     * @param options The options parameters.
     */
    _listDeploymentsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listDeploymentsNextOperationSpec);
    }
    /**
     * ListDomainOwnershipIdentifiersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListDomainOwnershipIdentifiers
     *                 method.
     * @param options The options parameters.
     */
    _listDomainOwnershipIdentifiersNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listDomainOwnershipIdentifiersNextOperationSpec);
    }
    /**
     * ListFunctionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListFunctions method.
     * @param options The options parameters.
     */
    _listFunctionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listFunctionsNextOperationSpec);
    }
    /**
     * ListHostNameBindingsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListHostNameBindings method.
     * @param options The options parameters.
     */
    _listHostNameBindingsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listHostNameBindingsNextOperationSpec);
    }
    /**
     * ListInstanceIdentifiersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListInstanceIdentifiers
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceIdentifiersNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listInstanceIdentifiersNextOperationSpec);
    }
    /**
     * ListInstanceProcessesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcesses method.
     * @param options The options parameters.
     */
    _listInstanceProcessesNext(resourceGroupName, name, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, instanceId, nextLink, options }, listInstanceProcessesNextOperationSpec);
    }
    /**
     * ListInstanceProcessModulesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessModules
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessModulesNext(resourceGroupName, name, processId, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, nextLink, options }, listInstanceProcessModulesNextOperationSpec);
    }
    /**
     * ListInstanceProcessThreadsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessThreads
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessThreadsNext(resourceGroupName, name, processId, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, instanceId, nextLink, options }, listInstanceProcessThreadsNextOperationSpec);
    }
    /**
     * ListSiteBackupsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListSiteBackups method.
     * @param options The options parameters.
     */
    _listSiteBackupsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSiteBackupsNextOperationSpec);
    }
    /**
     * ListPerfMonCountersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param nextLink The nextLink from the previous successful call to the ListPerfMonCounters method.
     * @param options The options parameters.
     */
    _listPerfMonCountersNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listPerfMonCountersNextOperationSpec);
    }
    /**
     * GetPrivateEndpointConnectionListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetPrivateEndpointConnectionList method.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, getPrivateEndpointConnectionListNextOperationSpec);
    }
    /**
     * ListProcessesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListProcesses method.
     * @param options The options parameters.
     */
    _listProcessesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listProcessesNextOperationSpec);
    }
    /**
     * ListProcessModulesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param nextLink The nextLink from the previous successful call to the ListProcessModules method.
     * @param options The options parameters.
     */
    _listProcessModulesNext(resourceGroupName, name, processId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, nextLink, options }, listProcessModulesNextOperationSpec);
    }
    /**
     * ListProcessThreadsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param nextLink The nextLink from the previous successful call to the ListProcessThreads method.
     * @param options The options parameters.
     */
    _listProcessThreadsNext(resourceGroupName, name, processId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, nextLink, options }, listProcessThreadsNextOperationSpec);
    }
    /**
     * ListPublicCertificatesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListPublicCertificates method.
     * @param options The options parameters.
     */
    _listPublicCertificatesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listPublicCertificatesNextOperationSpec);
    }
    /**
     * ListSiteContainersNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListSiteContainers method.
     * @param options The options parameters.
     */
    _listSiteContainersNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSiteContainersNextOperationSpec);
    }
    /**
     * ListSiteExtensionsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListSiteExtensions method.
     * @param options The options parameters.
     */
    _listSiteExtensionsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSiteExtensionsNextOperationSpec);
    }
    /**
     * ListSlotsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListSlots method.
     * @param options The options parameters.
     */
    _listSlotsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSlotsNextOperationSpec);
    }
    /**
     * ListBackupsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param nextLink The nextLink from the previous successful call to the ListBackupsSlot method.
     * @param options The options parameters.
     */
    _listBackupsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listBackupsSlotNextOperationSpec);
    }
    /**
     * ListBasicPublishingCredentialsPoliciesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListBasicPublishingCredentialsPoliciesSlot method.
     * @param options The options parameters.
     */
    _listBasicPublishingCredentialsPoliciesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listBasicPublishingCredentialsPoliciesSlotNextOperationSpec);
    }
    /**
     * ListConfigurationsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListConfigurationsSlot method.
     * @param options The options parameters.
     */
    _listConfigurationsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listConfigurationsSlotNextOperationSpec);
    }
    /**
     * GetAppSettingsKeyVaultReferencesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetAppSettingsKeyVaultReferencesSlot method.
     * @param options The options parameters.
     */
    _getAppSettingsKeyVaultReferencesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, getAppSettingsKeyVaultReferencesSlotNextOperationSpec);
    }
    /**
     * GetSiteConnectionStringKeyVaultReferencesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetSiteConnectionStringKeyVaultReferencesSlot method.
     * @param options The options parameters.
     */
    _getSiteConnectionStringKeyVaultReferencesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, getSiteConnectionStringKeyVaultReferencesSlotNextOperationSpec);
    }
    /**
     * ListConfigurationSnapshotInfoSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will return
     *             configuration for the production slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListConfigurationSnapshotInfoSlot method.
     * @param options The options parameters.
     */
    _listConfigurationSnapshotInfoSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listConfigurationSnapshotInfoSlotNextOperationSpec);
    }
    /**
     * ListContinuousWebJobsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListContinuousWebJobsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listContinuousWebJobsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listContinuousWebJobsSlotNextOperationSpec);
    }
    /**
     * ListSlotSiteDeploymentStatusesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get the deployment
     *             status for the production slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSlotSiteDeploymentStatusesSlot method.
     * @param options The options parameters.
     */
    _listSlotSiteDeploymentStatusesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSlotSiteDeploymentStatusesSlotNextOperationSpec);
    }
    /**
     * ListDeploymentsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListDeploymentsSlot method.
     * @param options The options parameters.
     */
    _listDeploymentsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listDeploymentsSlotNextOperationSpec);
    }
    /**
     * ListDomainOwnershipIdentifiersSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will delete the binding
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListDomainOwnershipIdentifiersSlot method.
     * @param options The options parameters.
     */
    _listDomainOwnershipIdentifiersSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listDomainOwnershipIdentifiersSlotNextOperationSpec);
    }
    /**
     * ListInstanceFunctionsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param nextLink The nextLink from the previous successful call to the ListInstanceFunctionsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceFunctionsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listInstanceFunctionsSlotNextOperationSpec);
    }
    /**
     * ListHostNameBindingsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListHostNameBindingsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listHostNameBindingsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listHostNameBindingsSlotNextOperationSpec);
    }
    /**
     * ListInstanceIdentifiersSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets the production
     *             slot instances.
     * @param nextLink The nextLink from the previous successful call to the ListInstanceIdentifiersSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceIdentifiersSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listInstanceIdentifiersSlotNextOperationSpec);
    }
    /**
     * ListInstanceProcessesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessesSlotNext(resourceGroupName, name, slot, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, instanceId, nextLink, options }, listInstanceProcessesSlotNextOperationSpec);
    }
    /**
     * ListInstanceProcessModulesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessModulesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessModulesSlotNext(resourceGroupName, name, processId, slot, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            processId,
            slot,
            instanceId,
            nextLink,
            options,
        }, listInstanceProcessModulesSlotNextOperationSpec);
    }
    /**
     * ListInstanceProcessThreadsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param instanceId ID of a specific scaled-out instance. This is the value of the name property in
     *                   the JSON response from "GET api/sites/{siteName}/instances".
     * @param nextLink The nextLink from the previous successful call to the ListInstanceProcessThreadsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceProcessThreadsSlotNext(resourceGroupName, name, processId, slot, instanceId, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            processId,
            slot,
            instanceId,
            nextLink,
            options,
        }, listInstanceProcessThreadsSlotNextOperationSpec);
    }
    /**
     * ListSiteBackupsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get backups of the
     *             production slot.
     * @param nextLink The nextLink from the previous successful call to the ListSiteBackupsSlot method.
     * @param options The options parameters.
     */
    _listSiteBackupsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSiteBackupsSlotNextOperationSpec);
    }
    /**
     * ListPerfMonCountersSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of web app.
     * @param slot Name of web app slot. If not specified then will default to production slot.
     * @param nextLink The nextLink from the previous successful call to the ListPerfMonCountersSlot
     *                 method.
     * @param options The options parameters.
     */
    _listPerfMonCountersSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listPerfMonCountersSlotNextOperationSpec);
    }
    /**
     * GetPrivateEndpointConnectionListSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the site.
     * @param slot Name of the site deployment slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetPrivateEndpointConnectionListSlot method.
     * @param options The options parameters.
     */
    _getPrivateEndpointConnectionListSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, getPrivateEndpointConnectionListSlotNextOperationSpec);
    }
    /**
     * ListProcessesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListProcessesSlot method.
     * @param options The options parameters.
     */
    _listProcessesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listProcessesSlotNextOperationSpec);
    }
    /**
     * ListProcessModulesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListProcessModulesSlot method.
     * @param options The options parameters.
     */
    _listProcessModulesSlotNext(resourceGroupName, name, processId, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, nextLink, options }, listProcessModulesSlotNextOperationSpec);
    }
    /**
     * ListProcessThreadsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param processId PID.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListProcessThreadsSlot method.
     * @param options The options parameters.
     */
    _listProcessThreadsSlotNext(resourceGroupName, name, processId, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, processId, slot, nextLink, options }, listProcessThreadsSlotNextOperationSpec);
    }
    /**
     * ListPublicCertificatesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API gets hostname bindings
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListPublicCertificatesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listPublicCertificatesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listPublicCertificatesSlotNextOperationSpec);
    }
    /**
     * ListSiteContainersSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get a list of site
     *             containers for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListSiteContainersSlot method.
     * @param options The options parameters.
     */
    _listSiteContainersSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSiteContainersSlotNextOperationSpec);
    }
    /**
     * ListSiteExtensionsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param nextLink The nextLink from the previous successful call to the ListSiteExtensionsSlot method.
     * @param options The options parameters.
     */
    _listSiteExtensionsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSiteExtensionsSlotNextOperationSpec);
    }
    /**
     * ListSlotDifferencesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the source slot. If a slot is not specified, the production slot is used as the
     *             source slot.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param nextLink The nextLink from the previous successful call to the ListSlotDifferencesSlot
     *                 method.
     * @param options The options parameters.
     */
    _listSlotDifferencesSlotNext(resourceGroupName, name, slot, slotSwapEntity, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, slotSwapEntity, nextLink, options }, listSlotDifferencesSlotNextOperationSpec);
    }
    /**
     * ListSnapshotsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param nextLink The nextLink from the previous successful call to the ListSnapshotsSlot method.
     * @param options The options parameters.
     */
    _listSnapshotsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSnapshotsSlotNextOperationSpec);
    }
    /**
     * ListSnapshotsFromDRSecondarySlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param slot Website Slot.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSnapshotsFromDRSecondarySlot method.
     * @param options The options parameters.
     */
    _listSnapshotsFromDRSecondarySlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listSnapshotsFromDRSecondarySlotNextOperationSpec);
    }
    /**
     * ListTriggeredWebJobsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API deletes a deployment
     *             for the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListTriggeredWebJobsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listTriggeredWebJobsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listTriggeredWebJobsSlotNextOperationSpec);
    }
    /**
     * ListTriggeredWebJobHistorySlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param slot Name of the deployment slot. If a slot is not specified, the API uses the production
     *             slot.
     * @param nextLink The nextLink from the previous successful call to the ListTriggeredWebJobHistorySlot
     *                 method.
     * @param options The options parameters.
     */
    _listTriggeredWebJobHistorySlotNext(resourceGroupName, name, webJobName, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, slot, nextLink, options }, listTriggeredWebJobHistorySlotNextOperationSpec);
    }
    /**
     * ListUsagesSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slot Name of the deployment slot. If a slot is not specified, the API will get quota
     *             information of the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListUsagesSlot method.
     * @param options The options parameters.
     */
    _listUsagesSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listUsagesSlotNextOperationSpec);
    }
    /**
     * ListWebJobsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot. If a slot is not specified, the API returns deployments for
     *             the production slot.
     * @param nextLink The nextLink from the previous successful call to the ListWebJobsSlot method.
     * @param options The options parameters.
     */
    _listWebJobsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listWebJobsSlotNextOperationSpec);
    }
    /**
     * ListSlotDifferencesFromProductionNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param slotSwapEntity JSON object that contains the target slot name. See example.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSlotDifferencesFromProduction method.
     * @param options The options parameters.
     */
    _listSlotDifferencesFromProductionNext(resourceGroupName, name, slotSwapEntity, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slotSwapEntity, nextLink, options }, listSlotDifferencesFromProductionNextOperationSpec);
    }
    /**
     * ListSnapshotsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param nextLink The nextLink from the previous successful call to the ListSnapshots method.
     * @param options The options parameters.
     */
    _listSnapshotsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSnapshotsNextOperationSpec);
    }
    /**
     * ListSnapshotsFromDRSecondaryNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Website Name.
     * @param nextLink The nextLink from the previous successful call to the ListSnapshotsFromDRSecondary
     *                 method.
     * @param options The options parameters.
     */
    _listSnapshotsFromDRSecondaryNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listSnapshotsFromDRSecondaryNextOperationSpec);
    }
    /**
     * ListTriggeredWebJobsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListTriggeredWebJobs method.
     * @param options The options parameters.
     */
    _listTriggeredWebJobsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listTriggeredWebJobsNextOperationSpec);
    }
    /**
     * ListTriggeredWebJobHistoryNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param webJobName Name of Web Job.
     * @param nextLink The nextLink from the previous successful call to the ListTriggeredWebJobHistory
     *                 method.
     * @param options The options parameters.
     */
    _listTriggeredWebJobHistoryNext(resourceGroupName, name, webJobName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, webJobName, nextLink, options }, listTriggeredWebJobHistoryNextOperationSpec);
    }
    /**
     * ListUsagesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Name of the app.
     * @param nextLink The nextLink from the previous successful call to the ListUsages method.
     * @param options The options parameters.
     */
    _listUsagesNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listUsagesNextOperationSpec);
    }
    /**
     * ListWebJobsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListWebJobs method.
     * @param options The options parameters.
     */
    _listWebJobsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listWebJobsNextOperationSpec);
    }
    /**
     * ListInstanceWorkflowsSlotNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param slot Name of the deployment slot.
     * @param nextLink The nextLink from the previous successful call to the ListInstanceWorkflowsSlot
     *                 method.
     * @param options The options parameters.
     */
    _listInstanceWorkflowsSlotNext(resourceGroupName, name, slot, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, slot, nextLink, options }, listInstanceWorkflowsSlotNextOperationSpec);
    }
    /**
     * ListWorkflowsNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param nextLink The nextLink from the previous successful call to the ListWorkflows method.
     * @param options The options parameters.
     */
    _listWorkflowsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listWorkflowsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, includeSlots],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Site,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Site,
        },
        201: {
            bodyMapper: Site,
        },
        202: {
            bodyMapper: Site,
        },
        204: {
            bodyMapper: Site,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        deleteMetrics,
        deleteEmptyServerFarm,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Site,
        },
        202: {
            bodyMapper: Site,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const analyzeCustomHostnameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomHostnameAnalysisResult,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, hostName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const applySlotConfigToProductionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const backupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItem,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listBackupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getBackupStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItem,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        backupId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteBackupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        backupId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listBackupStatusSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItem,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        backupId,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const restoreOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        backupId,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listBasicPublishingCredentialsPoliciesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublishingCredentialsPoliciesCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getFtpAllowedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateFtpAllowedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: csmPublishingAccessPoliciesEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getScmAllowedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateScmAllowedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: csmPublishingAccessPoliciesEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResourceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateApplicationSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listApplicationSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateAuthSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteAuthSettings,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteAuthSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getAuthSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteAuthSettings,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getAuthSettingsV2WithoutSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateAuthSettingsV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteAuthSettingsV2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getAuthSettingsV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2/list",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateAzureStorageAccountsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AzureStoragePropertyDictionaryResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: azureStorageAccounts,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listAzureStorageAccountsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AzureStoragePropertyDictionaryResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateBackupConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackupRequest,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteBackupConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getBackupConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupRequest,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getAppSettingsKeyVaultReferencesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getAppSettingKeyVaultReferenceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings/{appSettingKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReference,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        appSettingKey,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteConnectionStringKeyVaultReferencesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteConnectionStringKeyVaultReferenceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings/{connectionStringKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReference,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        connectionStringKey,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateConnectionStringsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectionStringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionStrings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listConnectionStringsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectionStringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getDiagnosticLogsConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteLogsConfig,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateDiagnosticLogsConfigOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteLogsConfig,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteLogsConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const updateMetadataOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: metadata,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listMetadataOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPublishingCredentialsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: User,
        },
        201: {
            bodyMapper: User,
        },
        202: {
            bodyMapper: User,
        },
        204: {
            bodyMapper: User,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateSitePushSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PushSettings,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: pushSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listSitePushSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PushSettings,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSlotConfigurationNamesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SlotConfigNamesResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateSlotConfigurationNamesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SlotConfigNamesResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: slotConfigNames,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteConfigResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const updateConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SiteConfigResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listConfigurationSnapshotInfoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigurationSnapshotInfoCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getConfigurationSnapshotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        snapshotId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const recoverSiteConfigurationSnapshotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        snapshotId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getWebSiteContainerLogsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        204: {},
        default: {},
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept1],
    serializer: serializer$a,
};
const getContainerLogsZipOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs/zip/download",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        204: {},
        default: {},
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept2],
    serializer: serializer$a,
};
const listContinuousWebJobsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getContinuousWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJob,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteContinuousWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const startContinuousWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const stopContinuousWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProductionSiteDeploymentStatusesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deploymentStatus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatusCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getProductionSiteDeploymentStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deploymentStatus/{deploymentStatusId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatus,
        },
        201: {
            bodyMapper: CsmDeploymentStatus,
        },
        202: {
            bodyMapper: CsmDeploymentStatus,
        },
        204: {
            bodyMapper: CsmDeploymentStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        deploymentStatusId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listDeploymentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getDeploymentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Deployment,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        id,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createDeploymentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Deployment,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: deployment,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        id,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteDeploymentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        id,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listDeploymentLogOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Deployment,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        id,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const discoverBackupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/discoverbackup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RestoreRequest,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listDomainOwnershipIdentifiersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getDomainOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Identifier,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainOwnershipIdentifierName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateDomainOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Identifier,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: domainOwnershipIdentifier1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainOwnershipIdentifierName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteDomainOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainOwnershipIdentifierName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateDomainOwnershipIdentifierOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Identifier,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: domainOwnershipIdentifier1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        domainOwnershipIdentifierName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getMSDeployStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createMSDeployOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MSDeployStatus,
        },
        201: {
            bodyMapper: MSDeployStatus,
        },
        202: {
            bodyMapper: MSDeployStatus,
        },
        204: {
            bodyMapper: MSDeployStatus,
        },
        409: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: mSDeploy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getMSDeployLogOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployLog,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getOneDeployStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/onedeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOneDeployOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/onedeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelopeCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getFunctionsAdminTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/admin/token",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelope,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FunctionEnvelope,
        },
        201: {
            bodyMapper: FunctionEnvelope,
        },
        202: {
            bodyMapper: FunctionEnvelope,
        },
        204: {
            bodyMapper: FunctionEnvelope,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: functionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateFunctionSecretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyInfo,
        },
        201: {
            bodyMapper: KeyInfo,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: key,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName,
        keyName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteFunctionSecretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName,
        keyName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listFunctionKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listkeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listFunctionSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listsecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FunctionSecrets,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        functionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listHostKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listkeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: HostKeys,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSyncStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listsyncstatus",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const syncFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/sync",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateHostSecretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyInfo,
        },
        201: {
            bodyMapper: KeyInfo,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: key,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        keyName,
        keyType,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteHostSecretOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        keyName,
        keyType,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listHostNameBindingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBindingCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getHostNameBindingOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBinding,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostName1,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateHostNameBindingOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HostNameBinding,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: hostNameBinding,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostName1,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteHostNameBindingOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        hostName1,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HybridConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateHybridConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: HybridConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listHybridConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listRelayServiceConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getRelayServiceConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        entityName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateRelayServiceConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        entityName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteRelayServiceConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        entityName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateRelayServiceConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        entityName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listInstanceIdentifiersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppInstanceStatusCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceInfoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebSiteInstanceStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceMsDeployStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createInstanceMSDeployOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MSDeployStatus,
        },
        201: {
            bodyMapper: MSDeployStatus,
        },
        202: {
            bodyMapper: MSDeployStatus,
        },
        204: {
            bodyMapper: MSDeployStatus,
        },
        409: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: mSDeploy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getInstanceMSDeployLogOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployLog,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceProcessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteInstanceProcessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceProcessDumpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/dump",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessModulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceProcessModuleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId,
        baseAddress,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessThreadsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const isCloneableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteCloneability,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteBackupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listbackups",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItemCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSyncFunctionTriggersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listsyncfunctiontriggerstatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FunctionSecrets,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const migrateStorageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StorageMigrationResponse,
        },
        201: {
            bodyMapper: StorageMigrationResponse,
        },
        202: {
            bodyMapper: StorageMigrationResponse,
        },
        204: {
            bodyMapper: StorageMigrationResponse,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: migrationOptions,
    queryParameters: [apiVersion, subscriptionName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const migrateMySqlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Operation,
        },
        201: {
            bodyMapper: Operation,
        },
        202: {
            bodyMapper: Operation,
        },
        204: {
            bodyMapper: Operation,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: migrationRequestEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getMigrateMySqlStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MigrateMySqlStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSwiftVirtualNetworkConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateSwiftVirtualNetworkConnectionWithCheckOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteSwiftVirtualNetworkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateSwiftVirtualNetworkConnectionWithCheckOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listNetworkFeaturesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkFeatures,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        view,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getNetworkTraceOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/operationresults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        operationId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const startWebSiteNetworkTraceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const startWebSiteNetworkTraceOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/startOperation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        201: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        204: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const stopWebSiteNetworkTraceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getNetworkTracesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        operationId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getNetworkTraceOperationV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/current/operationresults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        operationId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getNetworkTracesV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        operationId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const generateNewSitePublishingPasswordOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPerfMonCountersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PerfMonCounterCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSitePhpErrorLogFlagOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SitePhpErrorLogFlag,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPremierAddOnsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOn,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPremierAddOnOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOn,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        premierAddOnName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const addPremierAddOnOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PremierAddOn,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: premierAddOn,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        premierAddOnName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deletePremierAddOnOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        premierAddOnName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updatePremierAddOnOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PremierAddOn,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: premierAddOn1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        premierAddOnName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getPrivateAccessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateAccess,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const putPrivateAccessVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateAccess,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: access,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getPrivateEndpointConnectionListOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const approveOrRejectPrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        201: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        202: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        204: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: privateEndpointWrapper,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deletePrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPrivateLinkResourcesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesWrapper,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getProcessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteProcessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getProcessDumpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/dump",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessModulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getProcessModuleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules/{baseAddress}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId,
        baseAddress,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessThreadsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPublicCertificatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPublicCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificate,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        publicCertificateName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdatePublicCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PublicCertificate,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: publicCertificate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        publicCertificateName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deletePublicCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        publicCertificateName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPublishingProfileXmlWithSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: publishingProfileOptions,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [contentType, accept3],
    mediaType: "json",
    serializer: serializer$a,
};
const resetProductionSlotConfigOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const restartOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        softRestart,
        synchronous,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const restoreFromBackupBlobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromBackupBlob",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const restoreFromDeletedAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromDeletedApp",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: restoreRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const restoreSnapshotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreSnapshot",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: restoreRequest1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listSiteContainersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sitecontainers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteContainerCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteContainerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sitecontainers/{containerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteContainer,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateSiteContainerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sitecontainers/{containerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteContainer,
        },
        201: {
            bodyMapper: SiteContainer,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteSiteContainerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sitecontainers/{containerName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        containerName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteExtensionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteExtensionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteExtensionId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const installSiteExtensionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfo,
        },
        201: {
            bodyMapper: SiteExtensionInfo,
        },
        202: {
            bodyMapper: SiteExtensionInfo,
        },
        204: {
            bodyMapper: SiteExtensionInfo,
        },
        429: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteExtensionId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteSiteExtensionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        siteExtensionId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSlotsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Site,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Site,
        },
        201: {
            bodyMapper: Site,
        },
        202: {
            bodyMapper: Site,
        },
        204: {
            bodyMapper: Site,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        deleteMetrics,
        deleteEmptyServerFarm,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Site,
        },
        202: {
            bodyMapper: Site,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const analyzeCustomHostnameSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomHostnameAnalysisResult,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, hostName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const applySlotConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const backupSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItem,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listBackupsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getBackupStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItem,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        backupId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteBackupSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        backupId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listBackupStatusSecretsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItem,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        backupId,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const restoreSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        backupId,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listBasicPublishingCredentialsPoliciesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublishingCredentialsPoliciesCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getFtpAllowedSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateFtpAllowedSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: csmPublishingAccessPoliciesEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getScmAllowedSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateScmAllowedSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CsmPublishingCredentialsPoliciesEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: csmPublishingAccessPoliciesEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listConfigurationsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResourceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateApplicationSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: appSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listApplicationSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateAuthSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteAuthSettings,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteAuthSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getAuthSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteAuthSettings,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getAuthSettingsV2WithoutSecretsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateAuthSettingsV2SlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteAuthSettingsV2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getAuthSettingsV2SlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2/list",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteAuthSettingsV2,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateAzureStorageAccountsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AzureStoragePropertyDictionaryResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: azureStorageAccounts,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listAzureStorageAccountsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AzureStoragePropertyDictionaryResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateBackupConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackupRequest,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteBackupConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getBackupConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupRequest,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getAppSettingsKeyVaultReferencesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getAppSettingKeyVaultReferenceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings/{appSettingKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReference,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        appSettingKey,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteConnectionStringKeyVaultReferencesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteConnectionStringKeyVaultReferenceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings/{connectionStringKey}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReference,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        connectionStringKey,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateConnectionStringsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectionStringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionStrings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listConnectionStringsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectionStringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getDiagnosticLogsConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteLogsConfig,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateDiagnosticLogsConfigSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteLogsConfig,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteLogsConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const updateMetadataSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: metadata,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listMetadataSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPublishingCredentialsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: User,
        },
        201: {
            bodyMapper: User,
        },
        202: {
            bodyMapper: User,
        },
        204: {
            bodyMapper: User,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateSitePushSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PushSettings,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: pushSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listSitePushSettingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PushSettings,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteConfigResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const updateConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SiteConfigResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteConfig,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listConfigurationSnapshotInfoSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigurationSnapshotInfoCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getConfigurationSnapshotSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        snapshotId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const recoverSiteConfigurationSnapshotSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        snapshotId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getWebSiteContainerLogsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        204: {},
        default: {},
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept1],
    serializer: serializer$a,
};
const getContainerLogsZipSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs/zip/download",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        204: {},
        default: {},
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept2],
    serializer: serializer$a,
};
const listContinuousWebJobsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getContinuousWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJob,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteContinuousWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const startContinuousWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const stopContinuousWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSlotSiteDeploymentStatusesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deploymentStatus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatusCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSlotSiteDeploymentStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deploymentStatus/{deploymentStatusId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatus,
        },
        201: {
            bodyMapper: CsmDeploymentStatus,
        },
        202: {
            bodyMapper: CsmDeploymentStatus,
        },
        204: {
            bodyMapper: CsmDeploymentStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        deploymentStatusId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listDeploymentsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getDeploymentSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Deployment,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        id,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createDeploymentSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Deployment,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: deployment,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        id,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteDeploymentSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        id,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listDeploymentLogSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Deployment,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        id,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const discoverBackupSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/discoverbackup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RestoreRequest,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listDomainOwnershipIdentifiersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getDomainOwnershipIdentifierSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Identifier,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        domainOwnershipIdentifierName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateDomainOwnershipIdentifierSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Identifier,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: domainOwnershipIdentifier1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        domainOwnershipIdentifierName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteDomainOwnershipIdentifierSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        domainOwnershipIdentifierName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateDomainOwnershipIdentifierSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Identifier,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: domainOwnershipIdentifier1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        domainOwnershipIdentifierName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getMSDeployStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createMSDeployOperationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MSDeployStatus,
        },
        201: {
            bodyMapper: MSDeployStatus,
        },
        202: {
            bodyMapper: MSDeployStatus,
        },
        204: {
            bodyMapper: MSDeployStatus,
        },
        409: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: mSDeploy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getMSDeployLogSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployLog,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceFunctionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelopeCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getFunctionsAdminTokenSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/admin/token",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceFunctionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelope,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createInstanceFunctionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FunctionEnvelope,
        },
        201: {
            bodyMapper: FunctionEnvelope,
        },
        202: {
            bodyMapper: FunctionEnvelope,
        },
        204: {
            bodyMapper: FunctionEnvelope,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: functionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteInstanceFunctionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateFunctionSecretSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyInfo,
        },
        201: {
            bodyMapper: KeyInfo,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: key,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName,
        keyName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteFunctionSecretSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName,
        keyName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listFunctionKeysSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listkeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: StringDictionary,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listFunctionSecretsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listsecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FunctionSecrets,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        functionName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listHostKeysSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listkeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: HostKeys,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSyncStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listsyncstatus",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const syncFunctionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/sync",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateHostSecretSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyInfo,
        },
        201: {
            bodyMapper: KeyInfo,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: key,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        keyName,
        keyType,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteHostSecretSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        keyName,
        keyType,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listHostNameBindingsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBindingCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getHostNameBindingSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBinding,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        hostName1,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateHostNameBindingSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HostNameBinding,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: hostNameBinding,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        hostName1,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteHostNameBindingSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        hostName1,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getHybridConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateHybridConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HybridConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteHybridConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateHybridConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: HybridConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        namespaceName,
        relayName,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listHybridConnectionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridConnection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listRelayServiceConnectionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getRelayServiceConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        entityName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateRelayServiceConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        entityName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteRelayServiceConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        entityName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateRelayServiceConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RelayServiceConnectionEntity,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        entityName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listInstanceIdentifiersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppInstanceStatusCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceInfoSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebSiteInstanceStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceMsDeployStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createInstanceMSDeployOperationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MSDeployStatus,
        },
        201: {
            bodyMapper: MSDeployStatus,
        },
        202: {
            bodyMapper: MSDeployStatus,
        },
        204: {
            bodyMapper: MSDeployStatus,
        },
        409: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: mSDeploy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getInstanceMSDeployLogSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy/log",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MSDeployLog,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceProcessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteInstanceProcessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceProcessDumpSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/dump",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessModulesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceProcessModuleSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId,
        baseAddress,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessThreadsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const isCloneableSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SiteCloneability,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteBackupsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listbackups",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupItemCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSyncFunctionTriggersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listsyncfunctiontriggerstatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FunctionSecrets,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getMigrateMySqlStatusSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MigrateMySqlStatus,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSwiftVirtualNetworkConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteSwiftVirtualNetworkSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateSwiftVirtualNetworkConnectionWithCheckSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SwiftVirtualNetwork,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listNetworkFeaturesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkFeatures,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        view,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getNetworkTraceOperationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/operationresults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        operationId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const startWebSiteNetworkTraceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const startWebSiteNetworkTraceOperationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/startOperation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        201: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        204: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const stopWebSiteNetworkTraceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getNetworkTracesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        operationId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getNetworkTraceOperationSlotV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/current/operationresults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        operationId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getNetworkTracesSlotV2OperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        operationId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const generateNewSitePublishingPasswordSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPerfMonCountersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PerfMonCounterCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSitePhpErrorLogFlagSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SitePhpErrorLogFlag,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPremierAddOnsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOn,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPremierAddOnSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOn,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        premierAddOnName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const addPremierAddOnSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PremierAddOn,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: premierAddOn,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        premierAddOnName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deletePremierAddOnSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        premierAddOnName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updatePremierAddOnSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PremierAddOn,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: premierAddOn1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        premierAddOnName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getPrivateAccessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateAccess,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const putPrivateAccessVnetSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateAccess,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: access,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getPrivateEndpointConnectionListSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPrivateEndpointConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const approveOrRejectPrivateEndpointConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        201: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        202: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        204: {
            bodyMapper: RemotePrivateEndpointConnectionARMResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: privateEndpointWrapper,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deletePrivateEndpointConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        201: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        202: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        204: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        privateEndpointConnectionName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPrivateLinkResourcesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesWrapper,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getProcessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteProcessSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getProcessDumpSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/dump",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessModulesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getProcessModuleSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules/{baseAddress}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId,
        baseAddress,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessThreadsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPublicCertificatesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPublicCertificateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificate,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        publicCertificateName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdatePublicCertificateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PublicCertificate,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: publicCertificate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        publicCertificateName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deletePublicCertificateSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        publicCertificateName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPublishingProfileXmlWithSecretsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse",
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: publishingProfileOptions,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [contentType, accept3],
    mediaType: "json",
    serializer: serializer$a,
};
const resetSlotConfigurationSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const restartSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        softRestart,
        synchronous,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const restoreFromBackupBlobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromBackupBlob",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const restoreFromDeletedAppSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromDeletedApp",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: restoreRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const restoreSnapshotSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreSnapshot",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: restoreRequest1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listSiteContainersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sitecontainers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteContainerCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteContainerSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sitecontainers/{containerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteContainer,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        containerName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateSiteContainerSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sitecontainers/{containerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteContainer,
        },
        201: {
            bodyMapper: SiteContainer,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: request3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        containerName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteSiteContainerSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sitecontainers/{containerName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        containerName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteExtensionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteExtensionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfo,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        siteExtensionId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const installSiteExtensionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfo,
        },
        201: {
            bodyMapper: SiteExtensionInfo,
        },
        202: {
            bodyMapper: SiteExtensionInfo,
        },
        204: {
            bodyMapper: SiteExtensionInfo,
        },
        429: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        siteExtensionId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteSiteExtensionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        siteExtensionId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSlotDifferencesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SlotDifferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const swapSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listSnapshotsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSnapshotsFromDRSecondarySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshotsdr",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSourceControlSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteSourceControl,
        },
        201: {
            bodyMapper: SiteSourceControl,
        },
        202: {
            bodyMapper: SiteSourceControl,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateSourceControlSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteSourceControl,
        },
        201: {
            bodyMapper: SiteSourceControl,
        },
        202: {
            bodyMapper: SiteSourceControl,
        },
        204: {
            bodyMapper: SiteSourceControl,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteSourceControl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteSourceControlSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web",
    httpMethod: "DELETE",
    responses: {
        200: {},
        202: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, additionalFlags],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateSourceControlSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SiteSourceControl,
        },
        201: {
            bodyMapper: SiteSourceControl,
        },
        202: {
            bodyMapper: SiteSourceControl,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteSourceControl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const startSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const startNetworkTraceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/startNetworkTrace",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        201: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        204: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const stopSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const stopNetworkTraceSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stopNetworkTrace",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const syncRepositorySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const syncFunctionTriggersSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/syncfunctiontriggers",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listTriggeredWebJobsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getTriggeredWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJob,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteTriggeredWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listTriggeredWebJobHistorySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistoryCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getTriggeredWebJobHistorySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistory,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
        id,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const runTriggeredWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/run",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listUsagesSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listVnetConnectionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "VnetInfoResource" },
                    },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getVnetConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetInfoResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateVnetConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetInfoResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteVnetConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateVnetConnectionSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetInfoResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getVnetConnectionGatewaySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetGateway,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateVnetConnectionGatewaySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetGateway,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const updateVnetConnectionGatewaySlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetGateway,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listWebJobsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getWebJobSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJob,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSlotDifferencesFromProductionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SlotDifferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const swapSlotWithProductionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: slotSwapEntity,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listSnapshotsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSnapshotsFromDRSecondaryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshotsdr",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSourceControlOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteSourceControl,
        },
        201: {
            bodyMapper: SiteSourceControl,
        },
        202: {
            bodyMapper: SiteSourceControl,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateSourceControlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SiteSourceControl,
        },
        201: {
            bodyMapper: SiteSourceControl,
        },
        202: {
            bodyMapper: SiteSourceControl,
        },
        204: {
            bodyMapper: SiteSourceControl,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteSourceControl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteSourceControlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web",
    httpMethod: "DELETE",
    responses: {
        200: {},
        202: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, additionalFlags],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateSourceControlOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SiteSourceControl,
        },
        201: {
            bodyMapper: SiteSourceControl,
        },
        202: {
            bodyMapper: SiteSourceControl,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: siteSourceControl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const startNetworkTraceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/startNetworkTrace",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        201: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        202: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        204: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "NetworkTrace" } },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        durationInSeconds,
        maxFrameLength,
        sasUrl,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const stopNetworkTraceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stopNetworkTrace",
    httpMethod: "POST",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const syncRepositoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const syncFunctionTriggersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/syncfunctiontriggers",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listTriggeredWebJobsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getTriggeredWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJob,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deleteTriggeredWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listTriggeredWebJobHistoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistoryCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getTriggeredWebJobHistoryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistory,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
        id,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const runTriggeredWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/run",
    httpMethod: "POST",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listUsagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listVnetConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "VnetInfoResource" },
                    },
                },
            },
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getVnetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetInfoResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateVnetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetInfoResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deleteVnetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const updateVnetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetInfoResource,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const getVnetConnectionGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VnetGateway,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const createOrUpdateVnetConnectionGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VnetGateway,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const updateVnetConnectionGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VnetGateway,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: connectionEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        vnetName,
        gatewayName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listWebJobsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getWebJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs/{webJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJob,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const deployWorkflowArtifactsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployWorkflowArtifacts",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: workflowArtifacts,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const deployWorkflowArtifactsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployWorkflowArtifacts",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: workflowArtifacts,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listInstanceWorkflowsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/workflows",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowEnvelopeCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getInstanceWorkflowSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/workflows/{workflowName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowEnvelope,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
        workflowName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listWorkflowsConnectionsSlotOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listWorkflowsConnections",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowEnvelope,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listWorkflowsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/workflows",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowEnvelopeCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getWorkflowOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/workflows/{workflowName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowEnvelope,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listWorkflowsConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listWorkflowsConnections",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowEnvelope,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listBackupsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listBasicPublishingCredentialsPoliciesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublishingCredentialsPoliciesCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listConfigurationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResourceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getAppSettingsKeyVaultReferencesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteConnectionStringKeyVaultReferencesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listConfigurationSnapshotInfoNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigurationSnapshotInfoCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listContinuousWebJobsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProductionSiteDeploymentStatusesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatusCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listDeploymentsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listDomainOwnershipIdentifiersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listFunctionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelopeCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listHostNameBindingsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBindingCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceIdentifiersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppInstanceStatusCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessModulesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessThreadsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteBackupsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPerfMonCountersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PerfMonCounterCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPrivateEndpointConnectionListNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessModulesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessThreadsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPublicCertificatesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteContainersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteContainerCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteExtensionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSlotsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listBackupsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listBasicPublishingCredentialsPoliciesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublishingCredentialsPoliciesCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listConfigurationsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigResourceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getAppSettingsKeyVaultReferencesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getSiteConnectionStringKeyVaultReferencesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiKVReferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listConfigurationSnapshotInfoSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteConfigurationSnapshotInfoCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listContinuousWebJobsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContinuousWebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSlotSiteDeploymentStatusesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmDeploymentStatusCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listDeploymentsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listDomainOwnershipIdentifiersSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceFunctionsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FunctionEnvelopeCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listHostNameBindingsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HostNameBindingCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceIdentifiersSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebAppInstanceStatusCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        instanceId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessModulesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceProcessThreadsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        instanceId,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteBackupsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupItemCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPerfMonCountersSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PerfMonCounterCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const getPrivateEndpointConnectionListSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessModulesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessModuleInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listProcessThreadsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProcessThreadInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        processId,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listPublicCertificatesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicCertificateCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteContainersSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteContainerCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSiteExtensionsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteExtensionInfoCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSlotDifferencesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SlotDifferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listSnapshotsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSnapshotsFromDRSecondarySlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listTriggeredWebJobsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listTriggeredWebJobHistorySlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistoryCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listUsagesSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listWebJobsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSlotDifferencesFromProductionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SlotDifferenceCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a,
};
const listSnapshotsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listSnapshotsFromDRSecondaryNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listTriggeredWebJobsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredWebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listTriggeredWebJobHistoryNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggeredJobHistoryCollection,
        },
        404: {
            isError: true,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        webJobName,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listUsagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CsmUsageQuotaCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listWebJobsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebJobCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listInstanceWorkflowsSlotNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowEnvelopeCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        slot,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};
const listWorkflowsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowEnvelopeCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$a,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Workflows operations. */
class WorkflowsImpl {
    /**
     * Initialize a new instance of the class Workflows class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Regenerates the callback URL access key for request triggers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param keyType The access key type.
     * @param options The options parameters.
     */
    regenerateAccessKey(resourceGroupName, name, workflowName, keyType, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, keyType, options }, regenerateAccessKeyOperationSpec);
    }
    /**
     * Validates the workflow definition.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param validate The workflow.
     * @param options The options parameters.
     */
    validate(resourceGroupName, name, workflowName, validate, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, validate, options }, validateOperationSpec$1);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const regenerateAccessKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/regenerateAccessKey",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: keyType1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9,
};
const validateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: validate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRuns operations. */
class WorkflowRunsImpl {
    /**
     * Initialize a new instance of the class WorkflowRuns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow runs.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, name, workflowName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow runs.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, options }, listOperationSpec$7);
    }
    /**
     * Gets a workflow run.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, options }, getOperationSpec$7);
    }
    /**
     * Cancels a workflow run.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    cancel(resourceGroupName, name, workflowName, runName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, options }, cancelOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRun,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/cancel",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActions operations. */
class WorkflowRunActionsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow run actions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, runName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, runName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, name, workflowName, runName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, runName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, runName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, runName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, runName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, runName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, options) {
        const iter = this.listExpressionTracesPagingAll(resourceGroupName, name, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, options, settings);
            },
        };
    }
    listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, options));
                let page = result.inputs || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listExpressionTracesNext(resourceGroupName, name, workflowName, runName, actionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.inputs || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listExpressionTracesPagingAll(resourceGroupName, name, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of workflow run actions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, runName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, options }, listOperationSpec$6);
    }
    /**
     * Gets a workflow run action.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, actionName, options }, getOperationSpec$6);
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, actionName, options }, listExpressionTracesOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, runName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, nextLink, options }, listNextOperationSpec$6);
    }
    /**
     * ListExpressionTracesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param nextLink The nextLink from the previous successful call to the ListExpressionTraces method.
     * @param options The options parameters.
     */
    _listExpressionTracesNext(resourceGroupName, name, workflowName, runName, actionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            nextLink,
            options,
        }, listExpressionTracesNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunAction,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
        actionName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const listExpressionTracesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/listExpressionTraces",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressionTraces,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
        actionName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
        runName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const listExpressionTracesNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressionTraces,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
        runName,
        actionName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionRepetitions operations. */
class WorkflowRunActionRepetitionsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionRepetitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all of a workflow run action repetitions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, runName, actionName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, runName, actionName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, runName, actionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        const iter = this.listExpressionTracesPagingAll(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options, settings);
            },
        };
    }
    listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options));
                let page = result.inputs || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listExpressionTracesNext(resourceGroupName, name, workflowName, runName, actionName, repetitionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.inputs || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listExpressionTracesPagingAll(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listExpressionTracesPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all of a workflow run action repetitions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, actionName, options }, listOperationSpec$5);
    }
    /**
     * Get a workflow run action repetition.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options,
        }, getOperationSpec$5);
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    _listExpressionTraces(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options,
        }, listExpressionTracesOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, runName, actionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            nextLink,
            options,
        }, listNextOperationSpec$5);
    }
    /**
     * ListExpressionTracesNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param nextLink The nextLink from the previous successful call to the ListExpressionTraces method.
     * @param options The options parameters.
     */
    _listExpressionTracesNext(resourceGroupName, name, workflowName, runName, actionName, repetitionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            nextLink,
            options,
        }, listExpressionTracesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
        actionName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinition,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
        actionName,
        repetitionName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const listExpressionTracesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}/listExpressionTraces",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressionTraces,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
        actionName,
        repetitionName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
        runName,
        actionName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const listExpressionTracesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressionTraces,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
        runName,
        actionName,
        repetitionName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionRepetitionsRequestHistories operations. */
class WorkflowRunActionRepetitionsRequestHistoriesImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionRepetitionsRequestHistories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List a workflow run repetition request history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, runName, actionName, repetitionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List a workflow run repetition request history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options,
        }, listOperationSpec$4);
    }
    /**
     * Gets a workflow run repetition request history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param requestHistoryName The request history name.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, actionName, repetitionName, requestHistoryName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            requestHistoryName,
            options,
        }, getOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, runName, actionName, repetitionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            nextLink,
            options,
        }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}/requestHistories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistoryListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
        actionName,
        repetitionName,
    ],
    headerParameters: [accept],
    serializer: serializer$5,
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}/requestHistories/{requestHistoryName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistory,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
        actionName,
        repetitionName,
        requestHistoryName,
    ],
    headerParameters: [accept],
    serializer: serializer$5,
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistoryListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
        runName,
        actionName,
        repetitionName,
    ],
    headerParameters: [accept],
    serializer: serializer$5,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionScopeRepetitions operations. */
class WorkflowRunActionScopeRepetitionsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionScopeRepetitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the workflow run action scoped repetitions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, runName, actionName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, runName, actionName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, runName, actionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, runName, actionName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List the workflow run action scoped repetitions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, runName, actionName, options }, listOperationSpec$3);
    }
    /**
     * Get a workflow run action scoped repetition.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options,
        }, getOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, runName, actionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            runName,
            actionName,
            nextLink,
            options,
        }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/scopeRepetitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
        actionName,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/runs/{runName}/actions/{actionName}/scopeRepetitions/{repetitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinition,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        runName,
        actionName,
        repetitionName,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
        runName,
        actionName,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowTriggers operations. */
class WorkflowTriggersImpl {
    /**
     * Initialize a new instance of the class WorkflowTriggers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow triggers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, name, workflowName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow triggers.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, options }, listOperationSpec$2);
    }
    /**
     * Gets a workflow trigger.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, options }, getOperationSpec$2);
    }
    /**
     * Get the callback URL for a workflow trigger.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    listCallbackUrl(resourceGroupName, name, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, options }, listCallbackUrlOperationSpec);
    }
    /**
     * Runs a workflow trigger.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    beginRun(resourceGroupName, name, workflowName, triggerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, workflowName, triggerName, options },
                spec: runOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Runs a workflow trigger.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    beginRunAndWait(resourceGroupName, name, workflowName, triggerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRun(resourceGroupName, name, workflowName, triggerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the trigger schema as JSON.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    getSchemaJson(resourceGroupName, name, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, options }, getSchemaJsonOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTrigger,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        triggerName,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};
const listCallbackUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/listCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        triggerName,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};
const runOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/run",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        triggerName,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};
const getSchemaJsonOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/schemas/json",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JsonSchema,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        triggerName,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
    ],
    headerParameters: [accept],
    serializer: serializer$3,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowTriggerHistories operations. */
class WorkflowTriggerHistoriesImpl {
    /**
     * Initialize a new instance of the class WorkflowTriggerHistories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow trigger histories.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, triggerName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, triggerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, name, workflowName, triggerName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, triggerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, triggerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, triggerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, triggerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, triggerName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow trigger histories.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, options }, listOperationSpec$1);
    }
    /**
     * Gets a workflow trigger history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param historyName The workflow trigger history name. Corresponds to the run name for triggers that
     *                    resulted in a run.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, triggerName, historyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            workflowName,
            triggerName,
            historyName,
            options,
        }, getOperationSpec$1);
    }
    /**
     * Resubmits a workflow run based on the trigger history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param historyName The workflow trigger history name. Corresponds to the run name for triggers that
     *                    resulted in a run.
     * @param options The options parameters.
     */
    beginResubmit(resourceGroupName, name, workflowName, triggerName, historyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    name,
                    workflowName,
                    triggerName,
                    historyName,
                    options,
                },
                spec: resubmitOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resubmits a workflow run based on the trigger history.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param historyName The workflow trigger history name. Corresponds to the run name for triggers that
     *                    resulted in a run.
     * @param options The options parameters.
     */
    beginResubmitAndWait(resourceGroupName, name, workflowName, triggerName, historyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResubmit(resourceGroupName, name, workflowName, triggerName, historyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, triggerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, triggerName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/histories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerHistoryListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion, top1, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        triggerName,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/histories/{historyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerHistory,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        triggerName,
        historyName,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};
const resubmitOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/triggers/{triggerName}/histories/{historyName}/resubmit",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        triggerName,
        historyName,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerHistoryListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
        triggerName,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowVersions operations. */
class WorkflowVersionsImpl {
    /**
     * Initialize a new instance of the class WorkflowVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow versions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, workflowName, options) {
        const iter = this.listPagingAll(resourceGroupName, name, workflowName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, name, workflowName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, name, workflowName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, name, workflowName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, workflowName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, name, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, workflowName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow versions.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, options }, listOperationSpec);
    }
    /**
     * Gets a workflow version.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param versionId The workflow versionId.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, workflowName, versionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, versionId, options }, getOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param name Site name.
     * @param workflowName The workflow name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, workflowName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, workflowName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowVersionListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion, top1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostruntime/runtime/webhooks/workflow/api/management/workflows/{workflowName}/versions/{versionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowVersion,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        workflowName1,
        versionId,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowVersionListResult,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        nextLink,
        workflowName1,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
class WebSiteManagementClient extends coreClient__namespace.ServiceClient {
    constructor(credentials, subscriptionIdOrOptions, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        let subscriptionId;
        if (typeof subscriptionIdOrOptions === "string") {
            subscriptionId = subscriptionIdOrOptions;
        }
        else if (typeof subscriptionIdOrOptions === "object") {
            options = subscriptionIdOrOptions;
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials,
        };
        const packageDetails = `azsdk-js-arm-appservice/15.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName,
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge,
                },
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-12-01";
        this.appServiceCertificateOrders = new AppServiceCertificateOrdersImpl(this);
        this.certificateOrdersDiagnostics = new CertificateOrdersDiagnosticsImpl(this);
        this.certificateRegistrationProvider =
            new CertificateRegistrationProviderImpl(this);
        this.domains = new DomainsImpl(this);
        this.topLevelDomains = new TopLevelDomainsImpl(this);
        this.domainRegistrationProvider = new DomainRegistrationProviderImpl(this);
        this.appServiceEnvironments = new AppServiceEnvironmentsImpl(this);
        this.appServicePlans = new AppServicePlansImpl(this);
        this.certificates = new CertificatesImpl(this);
        this.containerApps = new ContainerAppsImpl(this);
        this.containerAppsRevisions = new ContainerAppsRevisionsImpl(this);
        this.deletedWebApps = new DeletedWebAppsImpl(this);
        this.diagnostics = new DiagnosticsImpl(this);
        this.global = new GlobalImpl(this);
        this.kubeEnvironments = new KubeEnvironmentsImpl(this);
        this.provider = new ProviderImpl(this);
        this.recommendations = new RecommendationsImpl(this);
        this.resourceHealthMetadataOperations =
            new ResourceHealthMetadataOperationsImpl(this);
        this.getUsagesInLocation = new GetUsagesInLocationImpl(this);
        this.staticSites = new StaticSitesImpl(this);
        this.webApps = new WebAppsImpl(this);
        this.workflows = new WorkflowsImpl(this);
        this.workflowRuns = new WorkflowRunsImpl(this);
        this.workflowRunActions = new WorkflowRunActionsImpl(this);
        this.workflowRunActionRepetitions = new WorkflowRunActionRepetitionsImpl(this);
        this.workflowRunActionRepetitionsRequestHistories =
            new WorkflowRunActionRepetitionsRequestHistoriesImpl(this);
        this.workflowRunActionScopeRepetitions =
            new WorkflowRunActionScopeRepetitionsImpl(this);
        this.workflowTriggers = new WorkflowTriggersImpl(this);
        this.workflowTriggerHistories = new WorkflowTriggerHistoriesImpl(this);
        this.workflowVersions = new WorkflowVersionsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            },
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Description for Gets the source controls available for Azure websites.
     * @param options The options parameters.
     */
    listSourceControls(options) {
        const iter = this.listSourceControlsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSourceControlsPagingPage(options, settings);
            },
        };
    }
    listSourceControlsPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSourceControlsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSourceControls(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSourceControlsNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSourceControlsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listSourceControlsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSourceControlsPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Description for Gets a list of meters for a given location.
     * @param options The options parameters.
     */
    listBillingMeters(options) {
        const iter = this.listBillingMetersPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBillingMetersPagingPage(options, settings);
            },
        };
    }
    listBillingMetersPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBillingMetersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBillingMeters(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBillingMetersNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBillingMetersPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBillingMetersPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBillingMetersPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get custom hostnames under this subscription
     * @param options The options parameters.
     */
    listCustomHostNameSites(options) {
        const iter = this.listCustomHostNameSitesPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCustomHostNameSitesPagingPage(options, settings);
            },
        };
    }
    listCustomHostNameSitesPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listCustomHostNameSitesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listCustomHostNameSites(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listCustomHostNameSitesNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listCustomHostNameSitesPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listCustomHostNameSitesPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listCustomHostNameSitesPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Description for get a list of available ASE regions and its supported Skus.
     * @param options The options parameters.
     */
    listAseRegions(options) {
        const iter = this.listAseRegionsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAseRegionsPagingPage(options, settings);
            },
        };
    }
    listAseRegionsPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAseRegionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAseRegions(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAseRegionsNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAseRegionsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAseRegionsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listAseRegionsPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Description for Get a list of available geographical regions.
     * @param options The options parameters.
     */
    listGeoRegions(options) {
        const iter = this.listGeoRegionsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGeoRegionsPagingPage(options, settings);
            },
        };
    }
    listGeoRegionsPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listGeoRegionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listGeoRegions(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listGeoRegionsNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listGeoRegionsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listGeoRegionsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listGeoRegionsPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Description for List all apps that are assigned to a hostname.
     * @param nameIdentifier Hostname information.
     * @param options The options parameters.
     */
    listSiteIdentifiersAssignedToHostName(nameIdentifier, options) {
        const iter = this.listSiteIdentifiersAssignedToHostNamePagingAll(nameIdentifier, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSiteIdentifiersAssignedToHostNamePagingPage(nameIdentifier, options, settings);
            },
        };
    }
    listSiteIdentifiersAssignedToHostNamePagingPage(nameIdentifier, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteIdentifiersAssignedToHostNamePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSiteIdentifiersAssignedToHostName(nameIdentifier, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSiteIdentifiersAssignedToHostNameNext(nameIdentifier, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSiteIdentifiersAssignedToHostNamePagingAll(nameIdentifier, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSiteIdentifiersAssignedToHostNamePagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSiteIdentifiersAssignedToHostNamePagingPage(nameIdentifier, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Description for List all premier add-on offers.
     * @param options The options parameters.
     */
    listPremierAddOnOffers(options) {
        const iter = this.listPremierAddOnOffersPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPremierAddOnOffersPagingPage(options, settings);
            },
        };
    }
    listPremierAddOnOffersPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPremierAddOnOffersPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listPremierAddOnOffers(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listPremierAddOnOffersNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPremierAddOnOffersPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPremierAddOnOffersPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPremierAddOnOffersPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Description for Gets publishing user
     * @param options The options parameters.
     */
    getPublishingUser(options) {
        return this.sendOperationRequest({ options }, getPublishingUserOperationSpec);
    }
    /**
     * Description for Updates publishing user
     * @param userDetails Details of publishing user
     * @param options The options parameters.
     */
    updatePublishingUser(userDetails, options) {
        return this.sendOperationRequest({ userDetails, options }, updatePublishingUserOperationSpec);
    }
    /**
     * Description for Gets the source controls available for Azure websites.
     * @param options The options parameters.
     */
    _listSourceControls(options) {
        return this.sendOperationRequest({ options }, listSourceControlsOperationSpec);
    }
    /**
     * Description for Gets source control token
     * @param sourceControlType Type of source control
     * @param options The options parameters.
     */
    getSourceControl(sourceControlType, options) {
        return this.sendOperationRequest({ sourceControlType, options }, getSourceControlOperationSpec);
    }
    /**
     * Description for Updates source control token
     * @param sourceControlType Type of source control
     * @param requestMessage Source control token information
     * @param options The options parameters.
     */
    updateSourceControl(sourceControlType, requestMessage, options) {
        return this.sendOperationRequest({ sourceControlType, requestMessage, options }, updateSourceControlOperationSpec);
    }
    /**
     * Description for Gets a list of meters for a given location.
     * @param options The options parameters.
     */
    _listBillingMeters(options) {
        return this.sendOperationRequest({ options }, listBillingMetersOperationSpec);
    }
    /**
     * Description for Check if a resource name is available.
     * @param name Resource name to verify.
     * @param typeParam Resource type used for verification.
     * @param options The options parameters.
     */
    checkNameAvailability(name, typeParam, options) {
        return this.sendOperationRequest({ name, typeParam, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Get custom hostnames under this subscription
     * @param options The options parameters.
     */
    _listCustomHostNameSites(options) {
        return this.sendOperationRequest({ options }, listCustomHostNameSitesOperationSpec);
    }
    /**
     * Description for Gets list of available geo regions plus ministamps
     * @param options The options parameters.
     */
    getSubscriptionDeploymentLocations(options) {
        return this.sendOperationRequest({ options }, getSubscriptionDeploymentLocationsOperationSpec);
    }
    /**
     * Description for get a list of available ASE regions and its supported Skus.
     * @param options The options parameters.
     */
    _listAseRegions(options) {
        return this.sendOperationRequest({ options }, listAseRegionsOperationSpec);
    }
    /**
     * Description for Get a list of available geographical regions.
     * @param options The options parameters.
     */
    _listGeoRegions(options) {
        return this.sendOperationRequest({ options }, listGeoRegionsOperationSpec);
    }
    /**
     * Description for List all apps that are assigned to a hostname.
     * @param nameIdentifier Hostname information.
     * @param options The options parameters.
     */
    _listSiteIdentifiersAssignedToHostName(nameIdentifier, options) {
        return this.sendOperationRequest({ nameIdentifier, options }, listSiteIdentifiersAssignedToHostNameOperationSpec);
    }
    /**
     * Description for List all premier add-on offers.
     * @param options The options parameters.
     */
    _listPremierAddOnOffers(options) {
        return this.sendOperationRequest({ options }, listPremierAddOnOffersOperationSpec);
    }
    /**
     * Description for List all SKUs.
     * @param options The options parameters.
     */
    listSkus(options) {
        return this.sendOperationRequest({ options }, listSkusOperationSpec);
    }
    /**
     * Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the
     * Network Security Group rules.
     * @param parameters VNET information
     * @param options The options parameters.
     */
    verifyHostingEnvironmentVnet(parameters, options) {
        return this.sendOperationRequest({ parameters, options }, verifyHostingEnvironmentVnetOperationSpec);
    }
    /**
     * Description for Move resources between resource groups.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @param options The options parameters.
     */
    move(resourceGroupName, moveResourceEnvelope, options) {
        return this.sendOperationRequest({ resourceGroupName, moveResourceEnvelope, options }, moveOperationSpec);
    }
    /**
     * Description for Validate if a resource can be created.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param validateRequest Request with the resources to validate.
     * @param options The options parameters.
     */
    validate(resourceGroupName, validateRequest, options) {
        return this.sendOperationRequest({ resourceGroupName, validateRequest, options }, validateOperationSpec);
    }
    /**
     * Description for Validate whether a resource can be moved.
     * @param resourceGroupName Name of the resource group to which the resource belongs.
     * @param moveResourceEnvelope Object that represents the resource to move.
     * @param options The options parameters.
     */
    validateMove(resourceGroupName, moveResourceEnvelope, options) {
        return this.sendOperationRequest({ resourceGroupName, moveResourceEnvelope, options }, validateMoveOperationSpec);
    }
    /**
     * ListSourceControlsNext
     * @param nextLink The nextLink from the previous successful call to the ListSourceControls method.
     * @param options The options parameters.
     */
    _listSourceControlsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listSourceControlsNextOperationSpec);
    }
    /**
     * ListBillingMetersNext
     * @param nextLink The nextLink from the previous successful call to the ListBillingMeters method.
     * @param options The options parameters.
     */
    _listBillingMetersNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listBillingMetersNextOperationSpec);
    }
    /**
     * ListCustomHostNameSitesNext
     * @param nextLink The nextLink from the previous successful call to the ListCustomHostNameSites
     *                 method.
     * @param options The options parameters.
     */
    _listCustomHostNameSitesNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listCustomHostNameSitesNextOperationSpec);
    }
    /**
     * ListAseRegionsNext
     * @param nextLink The nextLink from the previous successful call to the ListAseRegions method.
     * @param options The options parameters.
     */
    _listAseRegionsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listAseRegionsNextOperationSpec);
    }
    /**
     * ListGeoRegionsNext
     * @param nextLink The nextLink from the previous successful call to the ListGeoRegions method.
     * @param options The options parameters.
     */
    _listGeoRegionsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listGeoRegionsNextOperationSpec);
    }
    /**
     * ListSiteIdentifiersAssignedToHostNameNext
     * @param nameIdentifier Hostname information.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSiteIdentifiersAssignedToHostName method.
     * @param options The options parameters.
     */
    _listSiteIdentifiersAssignedToHostNameNext(nameIdentifier, nextLink, options) {
        return this.sendOperationRequest({ nameIdentifier, nextLink, options }, listSiteIdentifiersAssignedToHostNameNextOperationSpec);
    }
    /**
     * ListPremierAddOnOffersNext
     * @param nextLink The nextLink from the previous successful call to the ListPremierAddOnOffers method.
     * @param options The options parameters.
     */
    _listPremierAddOnOffersNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, listPremierAddOnOffersNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getPublishingUserOperationSpec = {
    path: "/providers/Microsoft.Web/publishingUsers/web",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: User,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer,
};
const updatePublishingUserOperationSpec = {
    path: "/providers/Microsoft.Web/publishingUsers/web",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: User,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: userDetails,
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer,
};
const listSourceControlsOperationSpec = {
    path: "/providers/Microsoft.Web/sourcecontrols",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SourceControlCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer,
};
const getSourceControlOperationSpec = {
    path: "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SourceControl,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, sourceControlType],
    headerParameters: [accept],
    serializer,
};
const updateSourceControlOperationSpec = {
    path: "/providers/Microsoft.Web/sourcecontrols/{sourceControlType}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SourceControl,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: requestMessage,
    queryParameters: [apiVersion],
    urlParameters: [$host, sourceControlType],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer,
};
const listBillingMetersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/billingMeters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BillingMeterCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        billingLocation,
        osType,
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer,
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ResourceNameAvailability,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: {
        parameterPath: {
            name: ["name"],
            typeParam: ["typeParam"],
            isFqdn: ["options", "isFqdn"],
            environmentId: ["options", "environmentId"],
        },
        mapper: Object.assign(Object.assign({}, ResourceNameAvailabilityRequest), { required: true }),
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer,
};
const listCustomHostNameSitesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/customhostnameSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomHostnameSitesCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion, hostname],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer,
};
const getSubscriptionDeploymentLocationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deploymentLocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeploymentLocations,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer,
};
const listAseRegionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/aseRegions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AseRegionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer,
};
const listGeoRegionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GeoRegionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [
        apiVersion,
        sku,
        linuxWorkersEnabled,
        xenonWorkersEnabled,
        linuxDynamicWorkersEnabled,
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer,
};
const listSiteIdentifiersAssignedToHostNameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/listSitesAssignedToHostName",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: nameIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer,
};
const listPremierAddOnOffersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOnOfferCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer,
};
const listSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuInfos,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer,
};
const verifyHostingEnvironmentVnetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Web/verifyHostingEnvironmentVnet",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VnetValidationFailureDetails,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer,
};
const moveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: moveResourceEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer,
};
const validateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ValidateResponse,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: validateRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer,
};
const validateMoveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    requestBody: moveResourceEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer,
};
const listSourceControlsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SourceControlCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer,
};
const listBillingMetersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BillingMeterCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer,
};
const listCustomHostNameSitesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomHostnameSitesCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer,
};
const listAseRegionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AseRegionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer,
};
const listGeoRegionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GeoRegionCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer,
};
const listSiteIdentifiersAssignedToHostNameNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IdentifierCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer,
};
const listPremierAddOnOffersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PremierAddOnOfferCollection,
        },
        default: {
            bodyMapper: DefaultErrorResponse,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer,
};

exports.WebSiteManagementClient = WebSiteManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
